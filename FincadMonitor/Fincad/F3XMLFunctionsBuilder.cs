using Microsoft.VisualBasic;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;


namespace FincadMonitor.Fincad
{
	// <summary>A class that implements a convenient interface to all registered FINCAD Financial Framework functions.</summary>
	public class F3XMLFunctionsBuilder
	{


		// <summary>
		// Form a curve tag for a remaining notional curve of an ABCDS.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object ABCDSRemainingNotionalCurveTag(object CreditContract)
		{

			Hashtable ABCDSRemainingNotionalCurveTag_args = new Hashtable();
			ABCDSRemainingNotionalCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("ABCDSRemainingNotionalCurveTag", ABCDSRemainingNotionalCurveTag_args);
		}

		// <summary>
		// Calculate an accrual fraction.
		// </summary>
		// <param name="Roll">Coupon Roll.</param>
		// <param name="TradeDate">Trade date.</param>
		// <param name="SettlementDate">Settlement Date.</param>
		// <param name="AccrualConvention">Accrual convention to use.</param>
		public object AccrualFraction(object Roll, object TradeDate, object SettlementDate, object AccrualConvention)
		{

			Hashtable AccrualFraction_args = new Hashtable();
			AccrualFraction_args.Add("Roll", Roll);
			AccrualFraction_args.Add("TradeDate", TradeDate);
			AccrualFraction_args.Add("SettlementDate", SettlementDate);
			AccrualFraction_args.Add("AccrualConvention", AccrualConvention);
			return F3Formatter.f3_style_serialization("AccrualFraction", AccrualFraction_args);
		}

		// <summary>
		// Add all market data in the repository to a model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddAllRepositoryMarketDataToModel(object ModelName, object BaseModel)
		{

			Hashtable AddAllRepositoryMarketDataToModel_args = new Hashtable();
			AddAllRepositoryMarketDataToModel_args.Add("ModelName", ModelName);
			AddAllRepositoryMarketDataToModel_args.Add("BaseModel", BaseModel);
			return F3Formatter.f3_style_serialization("AddAllRepositoryMarketDataToModel", AddAllRepositoryMarketDataToModel_args);
		}

		// <summary>
		// Form a model from an existing model with the addition of a bond quote.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="SourceModel">Underlying model.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="Quote">Bond price or yield.</param>
		// <param name="FundingCurveID">General collateral funding curve identifier. Default value: default-constructed instance of type general_collateral_name.</param>
		// <param name="AlternativeQuoteConvention">Alternative yield convention specifying the type of the quote in which it is desired to represent the bond quote in the model. Default value: default-constructed instance of type yield_convention.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddBondQuoteToModel(object ModelName, object SourceModel, object Bond, object Quote, object FundingCurveID, object AlternativeQuoteConvention)
		{

			Hashtable AddBondQuoteToModel_args = new Hashtable();
			AddBondQuoteToModel_args.Add("ModelName", ModelName);
			AddBondQuoteToModel_args.Add("SourceModel", SourceModel);
			AddBondQuoteToModel_args.Add("Bond", Bond);
			AddBondQuoteToModel_args.Add("Quote", Quote);
			AddBondQuoteToModel_args.Add("FundingCurveID", FundingCurveID);
			AddBondQuoteToModel_args.Add("AlternativeQuoteConvention", AlternativeQuoteConvention);
			return F3Formatter.f3_style_serialization("AddBondQuoteToModel", AddBondQuoteToModel_args);
		}

		// <summary>
		// Form a model from an existing model with the addition of quotes on a list of bonds.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="SourceModel">Underlying model.</param>
		// <param name="Bonds">A vector of bonds.</param>
		// <param name="Quotes">A vector of real numbers representing quoted prices or yields of the bonds.</param>
		// <param name="QuoteConventions">Yield convention specifying the type of the quote, or a list of such conventions. Default value: CleanPrice.</param>
		// <param name="FundingCurveID">General collateral funding curve identifier. Default value: default-constructed instance of type general_collateral_name.</param>
		// <param name="AlternativeQuoteConventions">Alternative yield convention specifying the type of the quote in which it is desired to represent the bond quote in the model. Default value: default-constructed instance of type yield_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddBondQuotesToModel(object ModelName, object SourceModel, object Bonds, object Quotes, object QuoteConventions, object FundingCurveID, object AlternativeQuoteConventions)
		{

			Hashtable AddBondQuotesToModel_args = new Hashtable();
			AddBondQuotesToModel_args.Add("ModelName", ModelName);
			AddBondQuotesToModel_args.Add("SourceModel", SourceModel);
			AddBondQuotesToModel_args.Add("Bonds", Bonds);
			AddBondQuotesToModel_args.Add("Quotes", Quotes);
			AddBondQuotesToModel_args.Add("QuoteConventions", QuoteConventions);
			AddBondQuotesToModel_args.Add("FundingCurveID", FundingCurveID);
			AddBondQuotesToModel_args.Add("AlternativeQuoteConventions", AlternativeQuoteConventions);
			return F3Formatter.f3_style_serialization("AddBondQuotesToModel", AddBondQuotesToModel_args);
		}

		// <summary>
		// Create a model from an existing model plus a calibrated FX quadratic volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="FXRateIndex">Index specifying the FX rate.</param>
		// <param name="MarketDataSets">Set of market data objects for building the volatility surface.</param>
		// <param name="InstrumentStrategy">An instrument strategy collection. Default value: default-constructed instance of type instrument_strategy.</param>
		// <param name="FlaggedFunctions">Specification of initial guesses for the three quadratic parameters.</param>
		// <param name="Optimizer">Method for calibration. Default value: DefaultLeastSquares.</param>
		// <param name="Constraints">An optional array of calibration constraints, one per each parameter that is to be calibrated. Default value: <s>GreaterThanZero</s><s>NoBoundConstraint</s><s>NoBoundConstraint</s>.</param>
		// <param name="InterpolationMethod">An interpolation method to be used for the curves created in the model. Default value: Linear.</param>
		// <param name="HoldFixed">Numerical (zero-based) indices indicating which parameters not to calibrate. Default value: default-constructed instance of type unsigned_small_integers.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddCalibratedQuadraticVolatilitySurfaceToModel(object ModelName, object BaseModel, object FXRateIndex, object MarketDataSets, object InstrumentStrategy, object FlaggedFunctions, object Optimizer, object Constraints, object InterpolationMethod, object HoldFixed)
		{

			Hashtable AddCalibratedQuadraticVolatilitySurfaceToModel_args = new Hashtable();
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("ModelName", ModelName);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("BaseModel", BaseModel);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("FXRateIndex", FXRateIndex);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("MarketDataSets", MarketDataSets);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("InstrumentStrategy", InstrumentStrategy);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("FlaggedFunctions", FlaggedFunctions);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("Optimizer", Optimizer);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("Constraints", Constraints);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("InterpolationMethod", InterpolationMethod);
			AddCalibratedQuadraticVolatilitySurfaceToModel_args.Add("HoldFixed", HoldFixed);
			return F3Formatter.f3_style_serialization("AddCalibratedQuadraticVolatilitySurfaceToModel", AddCalibratedQuadraticVolatilitySurfaceToModel_args);
		}

		// <summary>
		// Create a model from an existing model plus a calibrated volatility surface..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="InstrumentStrategy">Instruments to be valued in the calibration.</param>
		// <param name="OptionPricingVolatilityType">Type of volatility surface to be constructed.</param>
		// <param name="InitialValueFunctions">Initial value functions, one per target curve.</param>
		// <param name="HoldFixed">Numerical (zero-based) indices indicating which parameters not to calibrate. Default value: default-constructed instance of type unsigned_small_integers.</param>
		// <param name="Constraints">An optional array of calibration constraints, one per InitialValueFunction. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="InterpolationMethods">Interpolation methods used for calibrating the curves. Default value: default-constructed instance of type interpolation_methods.</param>
		// <param name="Optimizer">Method for calibration. Default value: DefaultLeastSquares.</param>
		// <param name="SourceVolatilityType">Used to build a source valuation specification for ExtendModelWithCalibratedCurves. Default value: Black.</param>
		// <param name="Index">Index being modeled. Default value: default-constructed instance of type index.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddCalibratedVolatilitySurfaceToModel(object ModelName, object BaseModel, object InstrumentStrategy, object OptionPricingVolatilityType, object InitialValueFunctions, object HoldFixed, object Constraints, object InterpolationMethods, object Optimizer, object SourceVolatilityType,
		object Index)
		{

			Hashtable AddCalibratedVolatilitySurfaceToModel_args = new Hashtable();
			AddCalibratedVolatilitySurfaceToModel_args.Add("ModelName", ModelName);
			AddCalibratedVolatilitySurfaceToModel_args.Add("BaseModel", BaseModel);
			AddCalibratedVolatilitySurfaceToModel_args.Add("InstrumentStrategy", InstrumentStrategy);
			AddCalibratedVolatilitySurfaceToModel_args.Add("OptionPricingVolatilityType", OptionPricingVolatilityType);
			AddCalibratedVolatilitySurfaceToModel_args.Add("InitialValueFunctions", InitialValueFunctions);
			AddCalibratedVolatilitySurfaceToModel_args.Add("HoldFixed", HoldFixed);
			AddCalibratedVolatilitySurfaceToModel_args.Add("Constraints", Constraints);
			AddCalibratedVolatilitySurfaceToModel_args.Add("InterpolationMethods", InterpolationMethods);
			AddCalibratedVolatilitySurfaceToModel_args.Add("Optimizer", Optimizer);
			AddCalibratedVolatilitySurfaceToModel_args.Add("SourceVolatilityType", SourceVolatilityType);
			AddCalibratedVolatilitySurfaceToModel_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("AddCalibratedVolatilitySurfaceToModel", AddCalibratedVolatilitySurfaceToModel_args);
		}

		// <summary>
		// Form a model from an existing model with the addition of a discount curve implied from a cheapest-to-deliver rate.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="NumeraireRate">Index representing the numeraire rate.</param>
		// <param name="CollateralAgreement">Agreement that specifies the rate that collateral earns in each currency.</param>
		// <param name="SamplingScheduleEnd">Maturity used to form the sampling schedule for the cheapest-to-deliver rate.</param>
		// <param name="SamplingMarketConventions">Market conventions used to form the sampling schedule for the cheapest-to-deliver rate. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="UseBootstrapping">Flag indicating use of bootstrapping versus simple implied discounting calculation. Default value: False.</param>
		// <param name="InterpolationMethod">Interpolation method for the discount curve. Default value: LogLinear.</param>
		// <param name="Fixings">Fixings for the cheapest-to-deliver rate. Default value: default-constructed instance of type fixings.</param>
		// <param name="ValuationControl">Valuation methodology for the calibration or compounded rate calculation. Default value: default-constructed instance of type calculation_strategy.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddCheapestToDeliverDiscountCurveToModel(object ModelName, object BaseModel, object NumeraireRate, object CollateralAgreement, object SamplingScheduleEnd, object SamplingMarketConventions, object UseBootstrapping, object InterpolationMethod, object Fixings, object ValuationControl)
		{

			Hashtable AddCheapestToDeliverDiscountCurveToModel_args = new Hashtable();
			AddCheapestToDeliverDiscountCurveToModel_args.Add("ModelName", ModelName);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("BaseModel", BaseModel);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("NumeraireRate", NumeraireRate);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("CollateralAgreement", CollateralAgreement);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("SamplingScheduleEnd", SamplingScheduleEnd);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("SamplingMarketConventions", SamplingMarketConventions);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("UseBootstrapping", UseBootstrapping);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("Fixings", Fixings);
			AddCheapestToDeliverDiscountCurveToModel_args.Add("ValuationControl", ValuationControl);
			return F3Formatter.f3_style_serialization("AddCheapestToDeliverDiscountCurveToModel", AddCheapestToDeliverDiscountCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a collateralized trade fixings curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Fixings">Fixings for the collateral.</param>
		// <param name="CollateralAgreement">collateral agreement used to determine how much collateral to post.</param>
		// <param name="Trade">trade with fixings id which is the product being collateralized.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddCollateralFixingsToModel(object ModelName, object BaseModel, object Fixings, object CollateralAgreement, object Trade)
		{

			Hashtable AddCollateralFixingsToModel_args = new Hashtable();
			AddCollateralFixingsToModel_args.Add("ModelName", ModelName);
			AddCollateralFixingsToModel_args.Add("BaseModel", BaseModel);
			AddCollateralFixingsToModel_args.Add("Fixings", Fixings);
			AddCollateralFixingsToModel_args.Add("CollateralAgreement", CollateralAgreement);
			AddCollateralFixingsToModel_args.Add("Trade", Trade);
			return F3Formatter.f3_style_serialization("AddCollateralFixingsToModel", AddCollateralFixingsToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an FX fixings curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Fixings">Fixings for the FX rate.</param>
		// <param name="FXRateIndex">Index specifying the FX rate.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddFXFixingsCurveToModel(object ModelName, object BaseModel, object Fixings, object FXRateIndex)
		{

			Hashtable AddFXFixingsCurveToModel_args = new Hashtable();
			AddFXFixingsCurveToModel_args.Add("ModelName", ModelName);
			AddFXFixingsCurveToModel_args.Add("BaseModel", BaseModel);
			AddFXFixingsCurveToModel_args.Add("Fixings", Fixings);
			AddFXFixingsCurveToModel_args.Add("FXRateIndex", FXRateIndex);
			return F3Formatter.f3_style_serialization("AddFXFixingsCurveToModel", AddFXFixingsCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an FX rates curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying base model.</param>
		// <param name="FXSpotQuotes">A two-column table of (FX index, quote) pairs.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddFXForwardCurvesToModel(object ModelName, object BaseModel, object FXSpotQuotes)
		{

			Hashtable AddFXForwardCurvesToModel_args = new Hashtable();
			AddFXForwardCurvesToModel_args.Add("ModelName", ModelName);
			AddFXForwardCurvesToModel_args.Add("BaseModel", BaseModel);
			AddFXForwardCurvesToModel_args.Add("FXSpotQuotes", FXSpotQuotes);
			return F3Formatter.f3_style_serialization("AddFXForwardCurvesToModel", AddFXForwardCurvesToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a futures convexity adjustment curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="ConvexityInfo">Specification of the futures convexity curve to be added.</param>
		// <param name="Index">Floating rate underlying the futures contract to which the convexity adjustment applies. Default value: default-constructed instance of type index.</param>
		// <param name="Tenor">Rate tenor to be used in convexity adjustment calculation. Needs to be supplied only when it cannot be determined from the index. Default value: default-constructed instance of type real_if_any.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddFuturesConvexityAdjustmentCurveToModel(object ModelName, object BaseModel, object ConvexityInfo, object Index, object Tenor)
		{

			Hashtable AddFuturesConvexityAdjustmentCurveToModel_args = new Hashtable();
			AddFuturesConvexityAdjustmentCurveToModel_args.Add("ModelName", ModelName);
			AddFuturesConvexityAdjustmentCurveToModel_args.Add("BaseModel", BaseModel);
			AddFuturesConvexityAdjustmentCurveToModel_args.Add("ConvexityInfo", ConvexityInfo);
			AddFuturesConvexityAdjustmentCurveToModel_args.Add("Index", Index);
			AddFuturesConvexityAdjustmentCurveToModel_args.Add("Tenor", Tenor);
			return F3Formatter.f3_style_serialization("AddFuturesConvexityAdjustmentCurveToModel", AddFuturesConvexityAdjustmentCurveToModel_args);
		}

		// <summary>
		// Form the LIBOR or overnight rate curve implied by the discount curve..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Index">Index representing the LIBOR or overnight rate.</param>
		// <param name="CollateralAgreement">Collateral agreement identifying the discount curve used to imply the rate. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddImpliedRateCurveToModel(object ModelName, object BaseModel, object Index, object CollateralAgreement)
		{

			Hashtable AddImpliedRateCurveToModel_args = new Hashtable();
			AddImpliedRateCurveToModel_args.Add("ModelName", ModelName);
			AddImpliedRateCurveToModel_args.Add("BaseModel", BaseModel);
			AddImpliedRateCurveToModel_args.Add("Index", Index);
			AddImpliedRateCurveToModel_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("AddImpliedRateCurveToModel", AddImpliedRateCurveToModel_args);
		}

		// <summary>
		// Form a model capable of providing a scaled inflation curve implied by inflation swap market data.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="InflationIndex">Index representing the inflation swap rate.</param>
		// <param name="MarketDataSet">Market data set containing inflation swap quotes to constrain the curve.</param>
		// <param name="BaseIndexValue">Base index value for the inflation index. Default value: 0.01.</param>
		// <param name="InterpolationMethod">Methodology for interpolation of the inflation curve. Default value: LogLinear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddInflationCurveToModel(object ModelName, object BaseModel, object InflationIndex, object MarketDataSet, object BaseIndexValue, object InterpolationMethod)
		{

			Hashtable AddInflationCurveToModel_args = new Hashtable();
			AddInflationCurveToModel_args.Add("ModelName", ModelName);
			AddInflationCurveToModel_args.Add("BaseModel", BaseModel);
			AddInflationCurveToModel_args.Add("InflationIndex", InflationIndex);
			AddInflationCurveToModel_args.Add("MarketDataSet", MarketDataSet);
			AddInflationCurveToModel_args.Add("BaseIndexValue", BaseIndexValue);
			AddInflationCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("AddInflationCurveToModel", AddInflationCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolated discount curve deducted from zero coupon bond prices.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Currency">Currency of the zero coupon bond.</param>
		// <param name="Maturities">Vector of bond maturities.</param>
		// <param name="Quotes">Vector of bond prices or yields.</param>
		// <param name="YieldConvention">The yield convention in which the bond prices are quoted. Default value: DirtyPrice.</param>
		// <param name="MaturityCalculator">Method for calculating the maturities of zero coupon bonds. Default value: BasicMonthYear.</param>
		// <param name="MarketDataTag">Zero coupon bond price market data tag. Default value: default-constructed instance of type marketdata_tag.</param>
		// <param name="InterpolationMethod">Interpolation method for the discount curve. Default value: LogLinear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddInterpolatedZeroCouponBondPriceDiscountCurveToModel(object ModelName, object BaseModel, object Currency, object Maturities, object Quotes, object YieldConvention, object MaturityCalculator, object MarketDataTag, object InterpolationMethod)
		{

			Hashtable AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args = new Hashtable();
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("ModelName", ModelName);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("BaseModel", BaseModel);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("Currency", Currency);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("Maturities", Maturities);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("Quotes", Quotes);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("YieldConvention", YieldConvention);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("MaturityCalculator", MaturityCalculator);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("MarketDataTag", MarketDataTag);
			AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("AddInterpolatedZeroCouponBondPriceDiscountCurveToModel", AddInterpolatedZeroCouponBondPriceDiscountCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a simple asset price curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Price">Asset price on the settlement date.</param>
		// <param name="FundingCurveInfo">Specification of the funding curve.</param>
		// <param name="AssetIndex">Index of the underlying asset.</param>
		// <param name="MarketDataName">Name part of market data tags for underlying asset price and funding info. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="AssetPriceType">Type part of market data tag for underlying asset price. Default value: AssetPriceQuote.</param>
		// <param name="FundingType">Type part of market data tag for funding info. Default value: FundingParams.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleAssetPriceCurveToModel(object ModelName, object BaseModel, object Price, object FundingCurveInfo, object AssetIndex, object MarketDataName, object AssetPriceType, object FundingType)
		{

			Hashtable AddSimpleAssetPriceCurveToModel_args = new Hashtable();
			AddSimpleAssetPriceCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleAssetPriceCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleAssetPriceCurveToModel_args.Add("Price", Price);
			AddSimpleAssetPriceCurveToModel_args.Add("FundingCurveInfo", FundingCurveInfo);
			AddSimpleAssetPriceCurveToModel_args.Add("AssetIndex", AssetIndex);
			AddSimpleAssetPriceCurveToModel_args.Add("MarketDataName", MarketDataName);
			AddSimpleAssetPriceCurveToModel_args.Add("AssetPriceType", AssetPriceType);
			AddSimpleAssetPriceCurveToModel_args.Add("FundingType", FundingType);
			return F3Formatter.f3_style_serialization("AddSimpleAssetPriceCurveToModel", AddSimpleAssetPriceCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a simple closed-form Black option pricing capability.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="BlackVolInfo">Specification of the Black volatility.</param>
		// <param name="Asset">Asset (equity or currency) whose volatility is being modeled.</param>
		// <param name="VolName">Name to identify Black volatility input in risk reports.</param>
		// <param name="VolType">Type to identify Black volatility input in risk reports.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleBlackVolatilitySurfaceToModel(object ModelName, object BaseModel, object BlackVolInfo, object Asset, object VolName, object VolType)
		{

			Hashtable AddSimpleBlackVolatilitySurfaceToModel_args = new Hashtable();
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("ModelName", ModelName);
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("BaseModel", BaseModel);
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("BlackVolInfo", BlackVolInfo);
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("Asset", Asset);
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("VolName", VolName);
			AddSimpleBlackVolatilitySurfaceToModel_args.Add("VolType", VolType);
			return F3Formatter.f3_style_serialization("AddSimpleBlackVolatilitySurfaceToModel", AddSimpleBlackVolatilitySurfaceToModel_args);
		}

		// <summary>
		// Form a model from an existing model with the addition of a discount curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketDataSets">Vector of market data objects for building the discount factor curve.</param>
		// <param name="Currency">Currency of the market data sets.</param>
		// <param name="FuturesConvexity">Specification of the volatility curve for futures convexity. Default value: default-constructed instance of type futures_convexity.</param>
		// <param name="TurnPressureCurve">Specification of the turn pressure curve. Default value: default-constructed instance of type turn_pressure.</param>
		// <param name="InterpolationMethod">Methodology for interpolation of the discount factor curve. Default value: LogLinear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleBootstrappedDiscountCurveToModel(object ModelName, object BaseModel, object MarketDataSets, object Currency, object FuturesConvexity, object TurnPressureCurve, object InterpolationMethod)
		{

			Hashtable AddSimpleBootstrappedDiscountCurveToModel_args = new Hashtable();
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("MarketDataSets", MarketDataSets);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("Currency", Currency);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("FuturesConvexity", FuturesConvexity);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("TurnPressureCurve", TurnPressureCurve);
			AddSimpleBootstrappedDiscountCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("AddSimpleBootstrappedDiscountCurveToModel", AddSimpleBootstrappedDiscountCurveToModel_args);
		}

		// <summary>
		// Form the discount factor curve implied by market data dependent on an overnight rate.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="OvernightRateIndex">Index representing the overnight rate.</param>
		// <param name="MarketDataSet">Market data set containing quotes to constrain the curve.</param>
		// <param name="InterpolationMethod">Methodology for interpolation of the discount factor curve. Default value: LogLinear.</param>
		// <param name="TurnPressure">Specification of the turn pressure curve. Default value: default-constructed instance of type turn_pressure.</param>
		// <param name="TimePointMethod">Method for determining the curve time points for bootstrapping. Default value: DropIfNotIncreasing.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleBootstrappedOISDiscountCurveToModel(object ModelName, object BaseModel, object OvernightRateIndex, object MarketDataSet, object InterpolationMethod, object TurnPressure, object TimePointMethod)
		{

			Hashtable AddSimpleBootstrappedOISDiscountCurveToModel_args = new Hashtable();
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("OvernightRateIndex", OvernightRateIndex);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("MarketDataSet", MarketDataSet);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("TurnPressure", TurnPressure);
			AddSimpleBootstrappedOISDiscountCurveToModel_args.Add("TimePointMethod", TimePointMethod);
			return F3Formatter.f3_style_serialization("AddSimpleBootstrappedOISDiscountCurveToModel", AddSimpleBootstrappedOISDiscountCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a parameterization curve of the LIBOR Market Model and the associated covariance curve..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="InstrumentStrategy">Calibration Instruments.</param>
		// <param name="LiborIndex">LIBOR index. Default value: default-constructed instance of type index.</param>
		// <param name="InitialValues">Initial parameter values. Default value: <d>0.0</d><d>0.0</d><d>1.0</d><d>1.0</d><d>0.5</d><d>0.5</d>.</param>
		// <param name="BoundConstraints">Bound constraints for parameters. Default value: <s>NoBoundConstraint</s><s>NoBoundConstraint</s><s>GreaterThanZero</s><s>GreaterThanZero</s><s>BetweenZeroAndOne</s><s>BetweenZeroAndOne</s>.</param>
		// <param name="FixedIndices">Indices for fixed parameters. Default value: default-constructed instance of type unsigned_small_integer_vector.</param>
		// <param name="Optimizer">Method for calibration. Default value: DefaultLeastSquares.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleCalibratedExponentialDecayCovarianceCurveToModel(object ModelName, object BaseModel, object InstrumentStrategy, object LiborIndex, object InitialValues, object BoundConstraints, object FixedIndices, object Optimizer)
		{

			Hashtable AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args = new Hashtable();
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("InstrumentStrategy", InstrumentStrategy);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("LiborIndex", LiborIndex);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("InitialValues", InitialValues);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("BoundConstraints", BoundConstraints);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("FixedIndices", FixedIndices);
			AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args.Add("Optimizer", Optimizer);
			return F3Formatter.f3_style_serialization("AddSimpleCalibratedExponentialDecayCovarianceCurveToModel", AddSimpleCalibratedExponentialDecayCovarianceCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a simple discount curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="DiscountCurveInfo">Specification of the discount factors.</param>
		// <param name="Currency">Currency in which discount will take place.</param>
		// <param name="DiscountingName">Name to identify discounting input in risk reports. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="DiscountingType">Type to identify discounting input in risk reports. Default value: DiscountingParams.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleDiscountCurveToModel(object ModelName, object BaseModel, object DiscountCurveInfo, object Currency, object DiscountingName, object DiscountingType)
		{

			Hashtable AddSimpleDiscountCurveToModel_args = new Hashtable();
			AddSimpleDiscountCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleDiscountCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleDiscountCurveToModel_args.Add("DiscountCurveInfo", DiscountCurveInfo);
			AddSimpleDiscountCurveToModel_args.Add("Currency", Currency);
			AddSimpleDiscountCurveToModel_args.Add("DiscountingName", DiscountingName);
			AddSimpleDiscountCurveToModel_args.Add("DiscountingType", DiscountingType);
			return F3Formatter.f3_style_serialization("AddSimpleDiscountCurveToModel", AddSimpleDiscountCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a covariance curve used by the LIBOR Market Model..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="LiborIndex">LIBOR index.</param>
		// <param name="LMMParameters">Parameters to model.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleExponentialDecayCovarianceCurveToModel(object ModelName, object BaseModel, object LiborIndex, object LMMParameters)
		{

			Hashtable AddSimpleExponentialDecayCovarianceCurveToModel_args = new Hashtable();
			AddSimpleExponentialDecayCovarianceCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleExponentialDecayCovarianceCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleExponentialDecayCovarianceCurveToModel_args.Add("LiborIndex", LiborIndex);
			AddSimpleExponentialDecayCovarianceCurveToModel_args.Add("LMMParameters", LMMParameters);
			return F3Formatter.f3_style_serialization("AddSimpleExponentialDecayCovarianceCurveToModel", AddSimpleExponentialDecayCovarianceCurveToModel_args);
		}

		// <summary>
		// Add the given fixings to a model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Fixings">Fixings for the observable.</param>
		// <param name="Index">Index representing the observable whose fixings are supplied.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleFixingsCurveToModel(object ModelName, object BaseModel, object Fixings, object Index)
		{

			Hashtable AddSimpleFixingsCurveToModel_args = new Hashtable();
			AddSimpleFixingsCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleFixingsCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleFixingsCurveToModel_args.Add("Fixings", Fixings);
			AddSimpleFixingsCurveToModel_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("AddSimpleFixingsCurveToModel", AddSimpleFixingsCurveToModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a futures convexity adjustment curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="VolatilityData">A two-column table of (maturity, volatility) pairs.</param>
		// <param name="Index">Floating rate underlying the futures contract to which the convexity adjustment applies.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the volatility curve. Default value: PiecewiseConstantLeft.</param>
		// <param name="Tenor">Rate tenor to be used in convexity adjustment calculation. Needs to be supplied only when it cannot be determined from the index. Default value: default-constructed instance of type real_if_any.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel(object ModelName, object BaseModel, object VolatilityData, object Index, object InterpolationMethod, object Tenor)
		{

			Hashtable AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args = new Hashtable();
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("ModelName", ModelName);
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("BaseModel", BaseModel);
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("VolatilityData", VolatilityData);
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("Index", Index);
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("InterpolationMethod", InterpolationMethod);
			AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args.Add("Tenor", Tenor);
			return F3Formatter.f3_style_serialization("AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel", AddSimpleHoLeeFuturesConvexityAdjustmentCurveToModel_args);
		}

		// <summary>
		// Adjust a date using a modifier.
		// </summary>
		// <param name="StartDate">Starting date.</param>
		// <param name="DateModifier">Date modifier.</param>
		public object AdjustDate(object StartDate, object DateModifier)
		{

			Hashtable AdjustDate_args = new Hashtable();
			AdjustDate_args.Add("StartDate", StartDate);
			AdjustDate_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("AdjustDate", AdjustDate_args);
		}

		// <summary>
		// Returns a set of objects from a repository according to the filter settings..
		// </summary>
		// <param name="RepositoryFilter">repository_filter.</param>
		public object ApplyFilter(object RepositoryFilter)
		{

			Hashtable ApplyFilter_args = new Hashtable();
			ApplyFilter_args.Add("RepositoryFilter", RepositoryFilter);
			return F3Formatter.f3_style_serialization("ApplyFilter", ApplyFilter_args);
		}

		// <summary>
		// Create a new market data set by applying a scenario to an existing one.
		// </summary>
		// <param name="MarketDataSetName">Name of the new market data set.</param>
		// <param name="MarketDataSet">Existing market data set.</param>
		// <param name="Scenario">Scenario to be applied to the market data.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object ApplyScenarioToMarketData(object MarketDataSetName, object MarketDataSet, object Scenario)
		{

			Hashtable ApplyScenarioToMarketData_args = new Hashtable();
			ApplyScenarioToMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			ApplyScenarioToMarketData_args.Add("MarketDataSet", MarketDataSet);
			ApplyScenarioToMarketData_args.Add("Scenario", Scenario);
			return F3Formatter.f3_style_serialization("ApplyScenarioToMarketData", ApplyScenarioToMarketData_args);
		}

		// <summary>
		// Create a new model from an existing model by applying a scenario to the market data of the model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Existing model.</param>
		// <param name="Scenario">Scenario to be applied to the market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ApplyScenarioToModel(object ModelName, object BaseModel, object Scenario)
		{

			Hashtable ApplyScenarioToModel_args = new Hashtable();
			ApplyScenarioToModel_args.Add("ModelName", ModelName);
			ApplyScenarioToModel_args.Add("BaseModel", BaseModel);
			ApplyScenarioToModel_args.Add("Scenario", Scenario);
			return F3Formatter.f3_style_serialization("ApplyScenarioToModel", ApplyScenarioToModel_args);
		}

		// <summary>
		// Filter individual rows out of an array input, based on a single column's value..
		// </summary>
		// <param name="InputArray">Input range.</param>
		// <param name="FilterColumn">Column to filter upon, with 1 being the leftmost column.</param>
		// <param name="FilterValue">Value must match filter column in order to include row.</param>
		public object ArrayFilter(object InputArray, object FilterColumn, object FilterValue)
		{

			Hashtable ArrayFilter_args = new Hashtable();
			ArrayFilter_args.Add("InputArray", InputArray);
			ArrayFilter_args.Add("FilterColumn", FilterColumn);
			ArrayFilter_args.Add("FilterValue", FilterValue);
			return F3Formatter.f3_style_serialization("ArrayFilter", ArrayFilter_args);
		}

		// <summary>
		// Stack two or more values together vertically.
		// </summary>
		// <param name="Argument1">Array 1 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument2">Array 2 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument3">Array 3 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument4">Array 4 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument5">Array 5 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument6">Array 6 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument7">Array 7 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument8">Array 8 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument9">Array 9 to be stacked. Default value: default-constructed instance of type object.</param>
		public object ArrayStack(object Argument1, object Argument2, object Argument3, object Argument4, object Argument5, object Argument6, object Argument7, object Argument8, object Argument9)
		{

			Hashtable ArrayStack_args = new Hashtable();
			ArrayStack_args.Add("Argument1", Argument1);
			ArrayStack_args.Add("Argument2", Argument2);
			ArrayStack_args.Add("Argument3", Argument3);
			ArrayStack_args.Add("Argument4", Argument4);
			ArrayStack_args.Add("Argument5", Argument5);
			ArrayStack_args.Add("Argument6", Argument6);
			ArrayStack_args.Add("Argument7", Argument7);
			ArrayStack_args.Add("Argument8", Argument8);
			ArrayStack_args.Add("Argument9", Argument9);
			return F3Formatter.f3_style_serialization("ArrayStack", ArrayStack_args);
		}

		// <summary>
		// Form a curve tag for an asset price curve.
		// </summary>
		// <param name="AssetCurveIdentifier">Unique curve identifier.</param>
		// <param name="SettlementNotTradeDate">Interpret time as based on settlement not trade date. Default value: true.</param>
		public object AssetPriceCurveTag(object AssetCurveIdentifier, object SettlementNotTradeDate)
		{

			Hashtable AssetPriceCurveTag_args = new Hashtable();
			AssetPriceCurveTag_args.Add("AssetCurveIdentifier", AssetCurveIdentifier);
			AssetPriceCurveTag_args.Add("SettlementNotTradeDate", SettlementNotTradeDate);
			return F3Formatter.f3_style_serialization("AssetPriceCurveTag", AssetPriceCurveTag_args);
		}

		// <summary>
		// List the notionals calculated by associating those for one roll schedule with another.
		// </summary>
		// <param name="Notionals">Notional structure.</param>
		// <param name="MainSchedule">Main roll schedule.</param>
		// <param name="AssociatedSchedule">Associated roll schedule.</param>
		public object AssociatedNotionals(object Notionals, object MainSchedule, object AssociatedSchedule)
		{

			Hashtable AssociatedNotionals_args = new Hashtable();
			AssociatedNotionals_args.Add("Notionals", Notionals);
			AssociatedNotionals_args.Add("MainSchedule", MainSchedule);
			AssociatedNotionals_args.Add("AssociatedSchedule", AssociatedSchedule);
			return F3Formatter.f3_style_serialization("AssociatedNotionals", AssociatedNotionals_args);
		}

		// <summary>
		// Return the number of hardware threads available on the system.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object AvailableHardwareThreads(object DummyArgument)
		{

			Hashtable AvailableHardwareThreads_args = new Hashtable();
			AvailableHardwareThreads_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("AvailableHardwareThreads", AvailableHardwareThreads_args);
		}

		// <summary>
		// Value a barrier option.
		// </summary>
		// <param name="Forward">Forward value of the underlying asset.</param>
		// <param name="Strike">Strike specification.</param>
		// <param name="TimeToExpiry">Time to expiry, in years.</param>
		// <param name="BarrierSpecification">Barrier specification.</param>
		// <param name="Payoff">Payoff specification.</param>
		// <param name="Volatility">Volatility specification for the option.</param>
		// <param name="ForwardFactorCurve">Real function specifying the factor for converting the underlying asset's forward value to its valuation time value.</param>
		// <param name="Requests">Array of requests of valuation information. Default value: Value.</param>
		public object BarrierOption(object Forward, object Strike, object TimeToExpiry, object BarrierSpecification, object Payoff, object Volatility, object ForwardFactorCurve, object Requests)
		{

			Hashtable BarrierOption_args = new Hashtable();
			BarrierOption_args.Add("Forward", Forward);
			BarrierOption_args.Add("Strike", Strike);
			BarrierOption_args.Add("TimeToExpiry", TimeToExpiry);
			BarrierOption_args.Add("BarrierSpecification", BarrierSpecification);
			BarrierOption_args.Add("Payoff", Payoff);
			BarrierOption_args.Add("Volatility", Volatility);
			BarrierOption_args.Add("ForwardFactorCurve", ForwardFactorCurve);
			BarrierOption_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("BarrierOption", BarrierOption_args);
		}

		// <summary>
		// Returns a reference date for testing purposes.
		// </summary>
		// <param name="Dummy">Dummy argument for flow control.</param>
		public object BaseDateForTesting(object Dummy)
		{

			Hashtable BaseDateForTesting_args = new Hashtable();
			BaseDateForTesting_args.Add("Dummy", Dummy);
			return F3Formatter.f3_style_serialization("BaseDateForTesting", BaseDateForTesting_args);
		}

		// <summary>
		// Returns the entry numbers for all bibliography entries..
		// </summary>
		// <param name="Dummy">A Dummy argument.</param>
		public object BibliographyEntries(object Dummy)
		{

			Hashtable BibliographyEntries_args = new Hashtable();
			BibliographyEntries_args.Add("Dummy", Dummy);
			return F3Formatter.f3_style_serialization("BibliographyEntries", BibliographyEntries_args);
		}

		// <summary>
		// Analyze a bond.
		// </summary>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="SettlementDetails">Settlement details.</param>
		// <param name="Price">Bond price or yield according to some convention.</param>
		// <param name="Model">Optional pricing model. Default value: NullModel.</param>
		// <param name="ValuationMethod">Valuation methodology. Default value: Default.</param>
		// <param name="Requests">Array of information requests.</param>
		public object Bond(object Bond_, object SettlementDetails, object Price, object Model, object ValuationMethod, object Requests)
		{

			Hashtable Bond_args = new Hashtable();
			Bond_args.Add("Bond", Bond_);
			Bond_args.Add("SettlementDetails", SettlementDetails);
			Bond_args.Add("Price", Price);
			Bond_args.Add("Model", Model);
			Bond_args.Add("ValuationMethod", ValuationMethod);
			Bond_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("Bond", Bond_args);
		}

		// <summary>
		// Form a dirty price curve tag from a bond.
		// </summary>
		// <param name="Bond">Bond for which a dirty price curve is to be formed.</param>
		public object BondDirtyPriceCurveTag(object Bond)
		{

			Hashtable BondDirtyPriceCurveTag_args = new Hashtable();
			BondDirtyPriceCurveTag_args.Add("Bond", Bond);
			return F3Formatter.f3_style_serialization("BondDirtyPriceCurveTag", BondDirtyPriceCurveTag_args);
		}

		// <summary>
		// Form a fixings curve tag from a bond price or yield index.
		// </summary>
		// <param name="Index">Bond price or yield index for which a fixings curve is to be formed.</param>
		public object BondFixingsCurveTag(object Index)
		{

			Hashtable BondFixingsCurveTag_args = new Hashtable();
			BondFixingsCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("BondFixingsCurveTag", BondFixingsCurveTag_args);
		}

		// <summary>
		// Form a funding curve tag from a bond.
		// </summary>
		// <param name="Bond">Bond for which a funding curve tag is to be formed.</param>
		public object BondFundingCurveTag(object Bond)
		{

			Hashtable BondFundingCurveTag_args = new Hashtable();
			BondFundingCurveTag_args.Add("Bond", Bond);
			return F3Formatter.f3_style_serialization("BondFundingCurveTag", BondFundingCurveTag_args);
		}

		// <summary>
		// Launch web browser for the server referenced by ServerName..
		// </summary>
		// <param name="ServerName">Object name.</param>
		// <param name="Path">Optional path to view. Default value: /.</param>
		public object BrowseServer(object ServerName, object Path)
		{

			Hashtable BrowseServer_args = new Hashtable();
			BrowseServer_args.Add("ServerName", ServerName);
			BrowseServer_args.Add("Path", Path);
			return F3Formatter.f3_style_serialization("BrowseServer", BrowseServer_args);
		}

		// <summary>
		// Return build information about this library instance.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object BuildInformation(object DummyArgument)
		{

			Hashtable BuildInformation_args = new Hashtable();
			BuildInformation_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("BuildInformation", BuildInformation_args);
		}

		// <summary>
		// Form a list of instruments given a collection of numerical indices.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set object.</param>
		// <param name="InstrumentIndices">Index of each instrument in the list.</param>
		// <param name="MarketDataName">Name-part of the tag identifying the element whose instruments are to be listed.</param>
		// <param name="MarketDataType">Type-part of the tag identifying the element whose instruments are to be listed.</param>
		public object BuildInstrumentList(object MarketDataSetName, object InstrumentIndices, object MarketDataName, object MarketDataType)
		{

			Hashtable BuildInstrumentList_args = new Hashtable();
			BuildInstrumentList_args.Add("MarketDataSetName", MarketDataSetName);
			BuildInstrumentList_args.Add("InstrumentIndices", InstrumentIndices);
			BuildInstrumentList_args.Add("MarketDataName", MarketDataName);
			BuildInstrumentList_args.Add("MarketDataType", MarketDataType);
			return F3Formatter.f3_style_serialization("BuildInstrumentList", BuildInstrumentList_args);
		}

		// <summary>
		// Build a roll from a reference point and an underlying roll.
		// </summary>
		// <param name="RollBuilder">Roll builder used to generate the roll.</param>
		// <param name="ReferencePoint">Reference point supplied to the roll builder.</param>
		// <param name="UnderlyingRoll">Underlying roll supplied to the roll builder.</param>
		public object BuildRoll(object RollBuilder, object ReferencePoint, object UnderlyingRoll)
		{

			Hashtable BuildRoll_args = new Hashtable();
			BuildRoll_args.Add("RollBuilder", RollBuilder);
			BuildRoll_args.Add("ReferencePoint", ReferencePoint);
			BuildRoll_args.Add("UnderlyingRoll", UnderlyingRoll);
			return F3Formatter.f3_style_serialization("BuildRoll", BuildRoll_args);
		}

		// <summary>
		// Form a curve tag for a butterfly strategy quote curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object ButterflyCurveTag(object UnderlyingIndex)
		{

			Hashtable ButterflyCurveTag_args = new Hashtable();
			ButterflyCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("ButterflyCurveTag", ButterflyCurveTag_args);
		}

		// <summary>
		// Store repository objects in a cache.
		// </summary>
		// <param name="RepositoryNames">Array of repository names, one per object.</param>
		// <param name="ObjectNames">Array of object names.</param>
		public object CacheObjects(object RepositoryNames, object ObjectNames)
		{

			Hashtable CacheObjects_args = new Hashtable();
			CacheObjects_args.Add("RepositoryNames", RepositoryNames);
			CacheObjects_args.Add("ObjectNames", ObjectNames);
			return F3Formatter.f3_style_serialization("CacheObjects", CacheObjects_args);
		}

		// <summary>
		// Call another function by name, using supplied named argument values.
		// </summary>
		// <param name="FunctionName">Name of function to call.</param>
		// <param name="NamedArguments">Named arguments for function call.</param>
		public object CallFunction(object FunctionName, object NamedArguments)
		{

			Hashtable CallFunction_args = new Hashtable();
			CallFunction_args.Add("FunctionName", FunctionName);
			CallFunction_args.Add("NamedArguments", NamedArguments);
			return F3Formatter.f3_style_serialization("CallFunction", CallFunction_args);
		}

		// <summary>
		// Call the function identified by the first argument with the given inputs..
		// </summary>
		// <param name="Function">Function to call.</param>
		// <param name="Arg1">The first input to the function.</param>
		// <param name="Arg2">The second input to the function.</param>
		// <param name="Arg3">The third input to the function.</param>
		// <param name="Arg4">The fourth input to the function.</param>
		// <param name="Arg5">The fifth input to the function.</param>
		// <param name="Arg6">The sixth input to the function.</param>
		// <param name="Arg7">The seventh input to the function.</param>
		// <param name="Arg8">The eighth input to the function.</param>
		// <param name="Arg9">The ninth input to the function.</param>
		// <param name="Arg10">The tenth input to the function.</param>
		// <param name="Arg11">The eleventh input to the function.</param>
		// <param name="Arg12">The twelfth input to the function.</param>
		// <param name="Arg13">The thirteenth input to the function.</param>
		// <param name="Arg14">The fourteenth input to the function.</param>
		// <param name="Arg15">The fifteenth input to the function.</param>
		// <param name="Arg16">The sixteenth input to the function.</param>
		// <param name="Arg17">The seventeenth input to the function.</param>
		// <param name="Arg18">The eighteenth input to the function.</param>
		// <param name="Arg19">The nineteenth input to the function.</param>
		// <param name="Arg20">The twentieth input to the function.</param>
		// <param name="Arg21">The twenty first input to the function.</param>
		// <param name="Arg22">The twenty second input to the function.</param>
		// <param name="Arg23">The twenty third input to the function.</param>
		// <param name="Arg24">The twenty fourth input to the function.</param>
		// <param name="Arg25">The twenty fifth input to the function.</param>
		// <param name="Arg26">The twenty sixth input to the function.</param>
		// <param name="Arg27">The twenty seventh input to the function.</param>
		// <param name="Arg28">The twenty eighth input to the function.</param>
		// <param name="Arg29">The twenty ninth input to the function.</param>
		public object CallIndirect(object Function_name, object Arg1, object Arg2, object Arg3, object Arg4, object Arg5, object Arg6, object Arg7, object Arg8, object Arg9,
		object Arg10, object Arg11, object Arg12, object Arg13, object Arg14, object Arg15, object Arg16, object Arg17, object Arg18, object Arg19,
		object Arg20, object Arg21, object Arg22, object Arg23, object Arg24, object Arg25, object Arg26, object Arg27, object Arg28, object Arg29)
		{

			Hashtable CallIndirect_args = new Hashtable();
			CallIndirect_args.Add("Function", Function_name);
			CallIndirect_args.Add("Arg1", Arg1);
			CallIndirect_args.Add("Arg2", Arg2);
			CallIndirect_args.Add("Arg3", Arg3);
			CallIndirect_args.Add("Arg4", Arg4);
			CallIndirect_args.Add("Arg5", Arg5);
			CallIndirect_args.Add("Arg6", Arg6);
			CallIndirect_args.Add("Arg7", Arg7);
			CallIndirect_args.Add("Arg8", Arg8);
			CallIndirect_args.Add("Arg9", Arg9);
			CallIndirect_args.Add("Arg10", Arg10);
			CallIndirect_args.Add("Arg11", Arg11);
			CallIndirect_args.Add("Arg12", Arg12);
			CallIndirect_args.Add("Arg13", Arg13);
			CallIndirect_args.Add("Arg14", Arg14);
			CallIndirect_args.Add("Arg15", Arg15);
			CallIndirect_args.Add("Arg16", Arg16);
			CallIndirect_args.Add("Arg17", Arg17);
			CallIndirect_args.Add("Arg18", Arg18);
			CallIndirect_args.Add("Arg19", Arg19);
			CallIndirect_args.Add("Arg20", Arg20);
			CallIndirect_args.Add("Arg21", Arg21);
			CallIndirect_args.Add("Arg22", Arg22);
			CallIndirect_args.Add("Arg23", Arg23);
			CallIndirect_args.Add("Arg24", Arg24);
			CallIndirect_args.Add("Arg25", Arg25);
			CallIndirect_args.Add("Arg26", Arg26);
			CallIndirect_args.Add("Arg27", Arg27);
			CallIndirect_args.Add("Arg28", Arg28);
			CallIndirect_args.Add("Arg29", Arg29);
			return F3Formatter.f3_style_serialization("CallIndirect", CallIndirect_args);
		}

		// <summary>
		// Return current call usage and timing statistics.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object CallStatistics(object DummyArgument)
		{

			Hashtable CallStatistics_args = new Hashtable();
			CallStatistics_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("CallStatistics", CallStatistics_args);
		}

		// <summary>
		// Determine whether or not a given index can be referenced with a given reference specification.
		// </summary>
		// <param name="Index">Index to query.</param>
		// <param name="RefSpec">Reference specification.</param>
		public object CanReferenceIndex(object Index, object RefSpec)
		{

			Hashtable CanReferenceIndex_args = new Hashtable();
			CanReferenceIndex_args.Add("Index", Index);
			CanReferenceIndex_args.Add("RefSpec", RefSpec);
			return F3Formatter.f3_style_serialization("CanReferenceIndex", CanReferenceIndex_args);
		}

		// <summary>
		// Return a date in a canonical string form.
		// </summary>
		// <param name="InputDate">Date to be converted into text form.</param>
		public object CanonicalDateString(object InputDate)
		{

			Hashtable CanonicalDateString_args = new Hashtable();
			CanonicalDateString_args.Add("InputDate", InputDate);
			return F3Formatter.f3_style_serialization("CanonicalDateString", CanonicalDateString_args);
		}

		// <summary>
		// Return a month and year in a canonical string form.
		// </summary>
		// <param name="InputMonthYear">MonthYear to be converted into text form.</param>
		public object CanonicalMonthYearString(object InputMonthYear)
		{

			Hashtable CanonicalMonthYearString_args = new Hashtable();
			CanonicalMonthYearString_args.Add("InputMonthYear", InputMonthYear);
			return F3Formatter.f3_style_serialization("CanonicalMonthYearString", CanonicalMonthYearString_args);
		}

		// <summary>
		// Return a quarter and year in a canonical string form.
		// </summary>
		// <param name="InputQuarterYear">QuarterYear to be converted into text form.</param>
		public object CanonicalQuarterYearString(object InputQuarterYear)
		{

			Hashtable CanonicalQuarterYearString_args = new Hashtable();
			CanonicalQuarterYearString_args.Add("InputQuarterYear", InputQuarterYear);
			return F3Formatter.f3_style_serialization("CanonicalQuarterYearString", CanonicalQuarterYearString_args);
		}

		// <summary>
		// Create a new calculation method based on an existing one.
		// </summary>
		// <param name="MethodName">Name to use for new method instance.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <returns>Retuns the name of the constructed object of type CalculationStrategy.</returns>
		public object CloneCalculationMethod(object MethodName, object CalculationMethod)
		{

			Hashtable CloneCalculationMethod_args = new Hashtable();
			CloneCalculationMethod_args.Add("MethodName", MethodName);
			CloneCalculationMethod_args.Add("CalculationMethod", CalculationMethod);
			return F3Formatter.f3_style_serialization("CloneCalculationMethod", CloneCalculationMethod_args);
		}

		// <summary>
		// Form a single roll from a roll schedule.
		// </summary>
		// <param name="Schedule">Roll schedule to be collapsed.</param>
		public object CollapseRollSchedule(object Schedule)
		{

			Hashtable CollapseRollSchedule_args = new Hashtable();
			CollapseRollSchedule_args.Add("Schedule", Schedule);
			return F3Formatter.f3_style_serialization("CollapseRollSchedule", CollapseRollSchedule_args);
		}

		// <summary>
		// Form a fixings curve tag from a trade and collateral agreement.
		// </summary>
		// <param name="CollateralAgreement">Agreement under which the trade is collateralized.</param>
		// <param name="Trade">Trade whose collateral posting has been fixed.</param>
		public object CollateralFixingsCurveTag(object CollateralAgreement, object Trade)
		{

			Hashtable CollateralFixingsCurveTag_args = new Hashtable();
			CollateralFixingsCurveTag_args.Add("CollateralAgreement", CollateralAgreement);
			CollateralFixingsCurveTag_args.Add("Trade", Trade);
			return F3Formatter.f3_style_serialization("CollateralFixingsCurveTag", CollateralFixingsCurveTag_args);
		}

		// <summary>
		// Consolidate a number of market data sets.
		// </summary>
		// <param name="MarketDataSetName">Name to use for consolidated market data set.</param>
		// <param name="InputMarketDataSets">Individual market data sets.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CombineMarketDataSets(object MarketDataSetName, object InputMarketDataSets)
		{

			Hashtable CombineMarketDataSets_args = new Hashtable();
			CombineMarketDataSets_args.Add("MarketDataSetName", MarketDataSetName);
			CombineMarketDataSets_args.Add("InputMarketDataSets", InputMarketDataSets);
			return F3Formatter.f3_style_serialization("CombineMarketDataSets", CombineMarketDataSets_args);
		}

		// <summary>
		// Interpolate the data, filling in the missing entries..
		// </summary>
		// <param name="Maturities">Maturity descriptors that correspond to the quotes.</param>
		// <param name="Data">Array of quotes, where some may be marked as missing (not available).</param>
		// <param name="InterpolationMethod">Method to use for quote interpolation. Default value: Linear.</param>
		// <param name="MaturityConvention">Maturity calculator used to convert maturity descriptors to the dates. Default value: NoHolidays.</param>
		// <param name="BaseDate">Base date to be used when calculating maturity dates using MaturityConvention. Default value: default-constructed instance of type date.</param>
		// <param name="TimeCalculator">Time calculator that is used to convert number of days difference to time points. Default value: Default.</param>
		public object CompleteArrayByInterpolation(object Maturities, object Data, object InterpolationMethod, object MaturityConvention, object BaseDate, object TimeCalculator)
		{

			Hashtable CompleteArrayByInterpolation_args = new Hashtable();
			CompleteArrayByInterpolation_args.Add("Maturities", Maturities);
			CompleteArrayByInterpolation_args.Add("Data", Data);
			CompleteArrayByInterpolation_args.Add("InterpolationMethod", InterpolationMethod);
			CompleteArrayByInterpolation_args.Add("MaturityConvention", MaturityConvention);
			CompleteArrayByInterpolation_args.Add("BaseDate", BaseDate);
			CompleteArrayByInterpolation_args.Add("TimeCalculator", TimeCalculator);
			return F3Formatter.f3_style_serialization("CompleteArrayByInterpolation", CompleteArrayByInterpolation_args);
		}

		// <summary>
		// Create a date out of a day, month and year.
		// </summary>
		// <param name="Year">Year.</param>
		// <param name="Month">Month.</param>
		// <param name="Day">Day of month.</param>
		public object ComposeDate(object Year, object Month, object Day)
		{

			Hashtable ComposeDate_args = new Hashtable();
			ComposeDate_args.Add("Year", Year);
			ComposeDate_args.Add("Month", Month);
			ComposeDate_args.Add("Day", Day);
			return F3Formatter.f3_style_serialization("ComposeDate", ComposeDate_args);
		}

		// <summary>
		// Build a loss distribution for a pool of credits conditional on a common driving factor using a recursive algorithm.
		// </summary>
		// <param name="Notionals">A vector of notional amounts for each credit in the pool.</param>
		// <param name="LossGivenDefault">A vector of losses given default for each credit in the pool.</param>
		// <param name="SurvivalProbabilityFunctions">A vector of survival probability functions.</param>
		// <param name="TimePoints">A vector of time points at which to evaluate the loss distribution.</param>
		// <param name="Correlations">A vector of correlations between each credit in the pool and a common driving factor.</param>
		// <param name="LossQuantization">Size of each unit of loss.</param>
		// <param name="CommonFactor">Common underlying factor for all credits.</param>
		// <param name="DoRisk">Boolean switch to turn on calculation of risk.</param>
		// <param name="SupressZeros">Boolean switch to supress loss probabilities equal to zero.</param>
		public object ConditionalLossDistributionUsingRecursion(object Notionals, object LossGivenDefault, object SurvivalProbabilityFunctions, object TimePoints, object Correlations, object LossQuantization, object CommonFactor, object DoRisk, object SupressZeros)
		{

			Hashtable ConditionalLossDistributionUsingRecursion_args = new Hashtable();
			ConditionalLossDistributionUsingRecursion_args.Add("Notionals", Notionals);
			ConditionalLossDistributionUsingRecursion_args.Add("LossGivenDefault", LossGivenDefault);
			ConditionalLossDistributionUsingRecursion_args.Add("SurvivalProbabilityFunctions", SurvivalProbabilityFunctions);
			ConditionalLossDistributionUsingRecursion_args.Add("TimePoints", TimePoints);
			ConditionalLossDistributionUsingRecursion_args.Add("Correlations", Correlations);
			ConditionalLossDistributionUsingRecursion_args.Add("LossQuantization", LossQuantization);
			ConditionalLossDistributionUsingRecursion_args.Add("CommonFactor", CommonFactor);
			ConditionalLossDistributionUsingRecursion_args.Add("DoRisk", DoRisk);
			ConditionalLossDistributionUsingRecursion_args.Add("SupressZeros", SupressZeros);
			return F3Formatter.f3_style_serialization("ConditionalLossDistributionUsingRecursion", ConditionalLossDistributionUsingRecursion_args);
		}

		// <summary>
		// Consolidate multiple modeling requirements and summarize.
		// </summary>
		// <param name="Configuration">Modeling configuration. Default value: Default.</param>
		// <param name="ModelingRequirements">Modeling requirements of one or more valuation functions.</param>
		// <param name="Requests">Array of requests.</param>
		public object ConsolidateModelingRequirements(object Configuration, object ModelingRequirements, object Requests)
		{

			Hashtable ConsolidateModelingRequirements_args = new Hashtable();
			ConsolidateModelingRequirements_args.Add("Configuration", Configuration);
			ConsolidateModelingRequirements_args.Add("ModelingRequirements", ModelingRequirements);
			ConsolidateModelingRequirements_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("ConsolidateModelingRequirements", ConsolidateModelingRequirements_args);
		}

		// <summary>
		// Create the results matrix given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="NumberOfDatasets">Number of data sets.</param>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object ConstructLeastSquaresDataMatrixForMultipleDatasets(object NumberOfDatasets, object RegressionSumsVector)
		{

			Hashtable ConstructLeastSquaresDataMatrixForMultipleDatasets_args = new Hashtable();
			ConstructLeastSquaresDataMatrixForMultipleDatasets_args.Add("NumberOfDatasets", NumberOfDatasets);
			ConstructLeastSquaresDataMatrixForMultipleDatasets_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("ConstructLeastSquaresDataMatrixForMultipleDatasets", ConstructLeastSquaresDataMatrixForMultipleDatasets_args);
		}

		// <summary>
		// Create the results vector given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object ConstructLeastSquaresDataVector(object RegressionSumsVector)
		{

			Hashtable ConstructLeastSquaresDataVector_args = new Hashtable();
			ConstructLeastSquaresDataVector_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("ConstructLeastSquaresDataVector", ConstructLeastSquaresDataVector_args);
		}

		// <summary>
		// Create the matrix of basis functions given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object ConstructLeastSquaresMatrix(object RegressionSumsVector)
		{

			Hashtable ConstructLeastSquaresMatrix_args = new Hashtable();
			ConstructLeastSquaresMatrix_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("ConstructLeastSquaresMatrix", ConstructLeastSquaresMatrix_args);
		}

		// <summary>
		// Create the matrix of basis functions given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="NumberOfDatasets">Number of data sets.</param>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object ConstructLeastSquaresMatrixForMultipleDatasets(object NumberOfDatasets, object RegressionSumsVector)
		{

			Hashtable ConstructLeastSquaresMatrixForMultipleDatasets_args = new Hashtable();
			ConstructLeastSquaresMatrixForMultipleDatasets_args.Add("NumberOfDatasets", NumberOfDatasets);
			ConstructLeastSquaresMatrixForMultipleDatasets_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("ConstructLeastSquaresMatrixForMultipleDatasets", ConstructLeastSquaresMatrixForMultipleDatasets_args);
		}

		// <summary>
		// Create an object from its string representation.
		// </summary>
		// <param name="InputStrings">Input range.</param>
		public object ConvertFromStringRep(object InputStrings)
		{

			Hashtable ConvertFromStringRep_args = new Hashtable();
			ConvertFromStringRep_args.Add("InputStrings", InputStrings);
			return F3Formatter.f3_style_serialization("ConvertFromStringRep", ConvertFromStringRep_args);
		}

		// <summary>
		// Convert an object into a string representation.
		// </summary>
		// <param name="InputRange">Input range.</param>
		public object ConvertToStringRep(object InputRange)
		{

			Hashtable ConvertToStringRep_args = new Hashtable();
			ConvertToStringRep_args.Add("InputRange", InputRange);
			return F3Formatter.f3_style_serialization("ConvertToStringRep", ConvertToStringRep_args);
		}

		// <summary>
		// Form a curve tag for a futures convexity adjustment curve.
		// </summary>
		// <param name="FloatingIndex">The floating rate index with which the curve should be associated.</param>
		public object ConvexityAdjustmentCurveTag(object FloatingIndex)
		{

			Hashtable ConvexityAdjustmentCurveTag_args = new Hashtable();
			ConvexityAdjustmentCurveTag_args.Add("FloatingIndex", FloatingIndex);
			return F3Formatter.f3_style_serialization("ConvexityAdjustmentCurveTag", ConvexityAdjustmentCurveTag_args);
		}

		// <summary>
		// Return the full path of the directory containing the core library.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object CoreLibraryDirectory(object DummyArgument)
		{

			Hashtable CoreLibraryDirectory_args = new Hashtable();
			CoreLibraryDirectory_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("CoreLibraryDirectory", CoreLibraryDirectory_args);
		}

		// <summary>
		// Form a curve tag for a correlation with variance curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object CorrelationWithVarianceCurveTag(object Index)
		{

			Hashtable CorrelationWithVarianceCurveTag_args = new Hashtable();
			CorrelationWithVarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("CorrelationWithVarianceCurveTag", CorrelationWithVarianceCurveTag_args);
		}

		// <summary>
		// Create a one-dimensional function which is a composition of a                                                                       two-dimensional function with two one-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTwoDimFunction">Two-dimensional base function.</param>
		// <param name="FirstOneDimFunction">First one-dimensional function.</param>
		// <param name="SecondOneDimFunction">Second one-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dCompositionFunctionWith2dBase(object FunctionName, object BaseTwoDimFunction, object FirstOneDimFunction, object SecondOneDimFunction)
		{

			Hashtable Create1dCompositionFunctionWith2dBase_args = new Hashtable();
			Create1dCompositionFunctionWith2dBase_args.Add("FunctionName", FunctionName);
			Create1dCompositionFunctionWith2dBase_args.Add("BaseTwoDimFunction", BaseTwoDimFunction);
			Create1dCompositionFunctionWith2dBase_args.Add("FirstOneDimFunction", FirstOneDimFunction);
			Create1dCompositionFunctionWith2dBase_args.Add("SecondOneDimFunction", SecondOneDimFunction);
			return F3Formatter.f3_style_serialization("Create1dCompositionFunctionWith2dBase", Create1dCompositionFunctionWith2dBase_args);
		}

		// <summary>
		// Create a one-dimensional function which is a composition of a                                                                       three-dimensional function with three one-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseThreeDimFunction">Three-dimensional base function.</param>
		// <param name="FirstOneDimFunction">First one-dimensional function.</param>
		// <param name="SecondOneDimFunction">Second one-dimensional function.</param>
		// <param name="ThirdOneDimFunction">Third one-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dCompositionFunctionWith3dBase(object FunctionName, object BaseThreeDimFunction, object FirstOneDimFunction, object SecondOneDimFunction, object ThirdOneDimFunction)
		{

			Hashtable Create1dCompositionFunctionWith3dBase_args = new Hashtable();
			Create1dCompositionFunctionWith3dBase_args.Add("FunctionName", FunctionName);
			Create1dCompositionFunctionWith3dBase_args.Add("BaseThreeDimFunction", BaseThreeDimFunction);
			Create1dCompositionFunctionWith3dBase_args.Add("FirstOneDimFunction", FirstOneDimFunction);
			Create1dCompositionFunctionWith3dBase_args.Add("SecondOneDimFunction", SecondOneDimFunction);
			Create1dCompositionFunctionWith3dBase_args.Add("ThirdOneDimFunction", ThirdOneDimFunction);
			return F3Formatter.f3_style_serialization("Create1dCompositionFunctionWith3dBase", Create1dCompositionFunctionWith3dBase_args);
		}

		// <summary>
		// Create a one-dimensional function from a two-dimensional function by 'binding' the second variable to the first variable.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TwoDimFunction">Two-dimensional function to be constrained.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dFunctionFrom2dFunction(object FunctionName, object TwoDimFunction)
		{

			Hashtable Create1dFunctionFrom2dFunction_args = new Hashtable();
			Create1dFunctionFrom2dFunction_args.Add("FunctionName", FunctionName);
			Create1dFunctionFrom2dFunction_args.Add("TwoDimFunction", TwoDimFunction);
			return F3Formatter.f3_style_serialization("Create1dFunctionFrom2dFunction", Create1dFunctionFrom2dFunction_args);
		}

		// <summary>
		// Create a one-dimensional function from a three-dimensional function by constraining each argument to be the same.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ThreeDimFunction">Three-dimensional function to be constrained.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dFunctionFrom3dFunction(object FunctionName, object ThreeDimFunction)
		{

			Hashtable Create1dFunctionFrom3dFunction_args = new Hashtable();
			Create1dFunctionFrom3dFunction_args.Add("FunctionName", FunctionName);
			Create1dFunctionFrom3dFunction_args.Add("ThreeDimFunction", ThreeDimFunction);
			return F3Formatter.f3_style_serialization("Create1dFunctionFrom3dFunction", Create1dFunctionFrom3dFunction_args);
		}

		// <summary>
		// Create a one-dimensional function which takes two one-dimensional functions as input   and raises the first to the power of the second.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseFunction">Base function.</param>
		// <param name="ExponentFunction">Exponent function.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dPowerFunction(object FunctionName, object BaseFunction, object ExponentFunction)
		{

			Hashtable Create1dPowerFunction_args = new Hashtable();
			Create1dPowerFunction_args.Add("FunctionName", FunctionName);
			Create1dPowerFunction_args.Add("BaseFunction", BaseFunction);
			Create1dPowerFunction_args.Add("ExponentFunction", ExponentFunction);
			return F3Formatter.f3_style_serialization("Create1dPowerFunction", Create1dPowerFunction_args);
		}

		// <summary>
		// Create a function as the product of two others, evaluated at the same point.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="FirstFunction">One-dimensional function to form first part of product.</param>
		// <param name="SecondFunction">One-dimensional function to form second part of product.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dProductFunction(object FunctionName, object FirstFunction, object SecondFunction)
		{

			Hashtable Create1dProductFunction_args = new Hashtable();
			Create1dProductFunction_args.Add("FunctionName", FunctionName);
			Create1dProductFunction_args.Add("FirstFunction", FirstFunction);
			Create1dProductFunction_args.Add("SecondFunction", SecondFunction);
			return F3Formatter.f3_style_serialization("Create1dProductFunction", Create1dProductFunction_args);
		}

		// <summary>
		// Create a one-dimensional function as the ratio of two functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="NumeratorFunction">The numerator function.</param>
		// <param name="DenominatorFunction">The denominator function.</param>
		// <param name="StepSize">Step size for numerical derivative calculations. Default value: 1.0e-8.</param>
		// <param name="StepSizeParameterTag">Tag to use for the step size.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object Create1dRatioFunction(object FunctionName, object NumeratorFunction, object DenominatorFunction, object StepSize, object StepSizeParameterTag)
		{

			Hashtable Create1dRatioFunction_args = new Hashtable();
			Create1dRatioFunction_args.Add("FunctionName", FunctionName);
			Create1dRatioFunction_args.Add("NumeratorFunction", NumeratorFunction);
			Create1dRatioFunction_args.Add("DenominatorFunction", DenominatorFunction);
			Create1dRatioFunction_args.Add("StepSize", StepSize);
			Create1dRatioFunction_args.Add("StepSizeParameterTag", StepSizeParameterTag);
			return F3Formatter.f3_style_serialization("Create1dRatioFunction", Create1dRatioFunction_args);
		}

		// <summary>
		// Create a two-dimensional function that is the composition of a two-dimensional function with a one-dimensional base function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseOneDimFunction">One-dimensional base function.</param>
		// <param name="TwoDimFunction">Two-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dCompositionFunctionWith1dBase(object FunctionName, object BaseOneDimFunction, object TwoDimFunction)
		{

			Hashtable Create2dCompositionFunctionWith1dBase_args = new Hashtable();
			Create2dCompositionFunctionWith1dBase_args.Add("FunctionName", FunctionName);
			Create2dCompositionFunctionWith1dBase_args.Add("BaseOneDimFunction", BaseOneDimFunction);
			Create2dCompositionFunctionWith1dBase_args.Add("TwoDimFunction", TwoDimFunction);
			return F3Formatter.f3_style_serialization("Create2dCompositionFunctionWith1dBase", Create2dCompositionFunctionWith1dBase_args);
		}

		// <summary>
		// Create a two-dimensional function that is the composition of two one-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTwoDimFunction">Two-dimensional function to be composed.</param>
		// <param name="FirstOneDimFunction">First one-dimensional function.</param>
		// <param name="SecondOneDimFunction">Second one-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dCompositionFunctionWith1dFunctions(object FunctionName, object BaseTwoDimFunction, object FirstOneDimFunction, object SecondOneDimFunction)
		{

			Hashtable Create2dCompositionFunctionWith1dFunctions_args = new Hashtable();
			Create2dCompositionFunctionWith1dFunctions_args.Add("FunctionName", FunctionName);
			Create2dCompositionFunctionWith1dFunctions_args.Add("BaseTwoDimFunction", BaseTwoDimFunction);
			Create2dCompositionFunctionWith1dFunctions_args.Add("FirstOneDimFunction", FirstOneDimFunction);
			Create2dCompositionFunctionWith1dFunctions_args.Add("SecondOneDimFunction", SecondOneDimFunction);
			return F3Formatter.f3_style_serialization("Create2dCompositionFunctionWith1dFunctions", Create2dCompositionFunctionWith1dFunctions_args);
		}

		// <summary>
		// Create a two-dimensional function that is the composition of two two-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTwoDimFunction">Two-dimensional function to be composed.</param>
		// <param name="FirstTwoDimFunction">First two-dimensional function.</param>
		// <param name="SecondTwoDimFunction">Second two-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dCompositionFunctionWith2dFunctions(object FunctionName, object BaseTwoDimFunction, object FirstTwoDimFunction, object SecondTwoDimFunction)
		{

			Hashtable Create2dCompositionFunctionWith2dFunctions_args = new Hashtable();
			Create2dCompositionFunctionWith2dFunctions_args.Add("FunctionName", FunctionName);
			Create2dCompositionFunctionWith2dFunctions_args.Add("BaseTwoDimFunction", BaseTwoDimFunction);
			Create2dCompositionFunctionWith2dFunctions_args.Add("FirstTwoDimFunction", FirstTwoDimFunction);
			Create2dCompositionFunctionWith2dFunctions_args.Add("SecondTwoDimFunction", SecondTwoDimFunction);
			return F3Formatter.f3_style_serialization("Create2dCompositionFunctionWith2dFunctions", Create2dCompositionFunctionWith2dFunctions_args);
		}

		// <summary>
		// Create a two-dimensional function that is the composition of three two-dimensional functions with a             three-dimensional base function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseThreeDimFunction">Three-dimensional function to be composed.</param>
		// <param name="FirstTwoDimFunction">First two-dimensional function.</param>
		// <param name="SecondTwoDimFunction">Second two-dimensional function.</param>
		// <param name="ThirdTwoDimFunction">Third two-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dCompositionFunctionWith3dBase(object FunctionName, object BaseThreeDimFunction, object FirstTwoDimFunction, object SecondTwoDimFunction, object ThirdTwoDimFunction)
		{

			Hashtable Create2dCompositionFunctionWith3dBase_args = new Hashtable();
			Create2dCompositionFunctionWith3dBase_args.Add("FunctionName", FunctionName);
			Create2dCompositionFunctionWith3dBase_args.Add("BaseThreeDimFunction", BaseThreeDimFunction);
			Create2dCompositionFunctionWith3dBase_args.Add("FirstTwoDimFunction", FirstTwoDimFunction);
			Create2dCompositionFunctionWith3dBase_args.Add("SecondTwoDimFunction", SecondTwoDimFunction);
			Create2dCompositionFunctionWith3dBase_args.Add("ThirdTwoDimFunction", ThirdTwoDimFunction);
			return F3Formatter.f3_style_serialization("Create2dCompositionFunctionWith3dBase", Create2dCompositionFunctionWith3dBase_args);
		}

		// <summary>
		// Create an instrument type for a two-dimensional dated value market data set.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="MarketConventionX">Market conventions for maturities X.</param>
		// <param name="MarketConventionY">Market conventions for maturities Y.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object Create2dDatedValueInstrumentType(object InstrumentTypeName, object MarketConventionX, object MarketConventionY)
		{

			Hashtable Create2dDatedValueInstrumentType_args = new Hashtable();
			Create2dDatedValueInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			Create2dDatedValueInstrumentType_args.Add("MarketConventionX", MarketConventionX);
			Create2dDatedValueInstrumentType_args.Add("MarketConventionY", MarketConventionY);
			return F3Formatter.f3_style_serialization("Create2dDatedValueInstrumentType", Create2dDatedValueInstrumentType_args);
		}

		// <summary>
		// Create a two-dimensional dated value market data set.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="DateValueName">Name to use for the two-dimensional dated value market data.</param>
		// <param name="DateValueType">Type name for the two-dimensional dated value market data.</param>
		// <param name="MaturitiesX">Vector of maturity descriptors for the X-axis.</param>
		// <param name="MaturitiesY">Vector of maturity descriptors for the Y-axis.</param>
		// <param name="Values">Matrix of values.</param>
		// <param name="MarketConventionX">Market conventions for maturities X.</param>
		// <param name="MarketConventionY">Market conventions for maturities Y.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object Create2dDatedValueMarketData(object MarketDataSetName, object DateValueName, object DateValueType, object MaturitiesX, object MaturitiesY, object Values, object MarketConventionX, object MarketConventionY)
		{

			Hashtable Create2dDatedValueMarketData_args = new Hashtable();
			Create2dDatedValueMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			Create2dDatedValueMarketData_args.Add("DateValueName", DateValueName);
			Create2dDatedValueMarketData_args.Add("DateValueType", DateValueType);
			Create2dDatedValueMarketData_args.Add("MaturitiesX", MaturitiesX);
			Create2dDatedValueMarketData_args.Add("MaturitiesY", MaturitiesY);
			Create2dDatedValueMarketData_args.Add("Values", Values);
			Create2dDatedValueMarketData_args.Add("MarketConventionX", MarketConventionX);
			Create2dDatedValueMarketData_args.Add("MarketConventionY", MarketConventionY);
			return F3Formatter.f3_style_serialization("Create2dDatedValueMarketData", Create2dDatedValueMarketData_args);
		}

		// <summary>
		// Creates a two-dimensional interpolation function from a grid of (x,y) points.
		// </summary>
		// <param name="FunctionName">Name to use for the two-dimensional interpolation function.</param>
		// <param name="Xdata">The x-coordinates of the data.</param>
		// <param name="Ydata">The y-coordinates of the data.</param>
		// <param name="FunctionValues">The values of the function evaluated at each of the (x,y) points.</param>
		// <param name="XParameterTag">Tag to use for the X parameters.</param>
		// <param name="YParameterTag">Tag to use for the Y parameters.</param>
		// <param name="FunctionValueParameterTag">Tag to use for the function value parameters.</param>
		// <param name="TwoDimInterpolationMethod">A two-dimensional interpolation method.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dInterpolationFunctionFromGrid(object FunctionName, object Xdata, object Ydata, object FunctionValues, object XParameterTag, object YParameterTag, object FunctionValueParameterTag, object TwoDimInterpolationMethod)
		{

			Hashtable Create2dInterpolationFunctionFromGrid_args = new Hashtable();
			Create2dInterpolationFunctionFromGrid_args.Add("FunctionName", FunctionName);
			Create2dInterpolationFunctionFromGrid_args.Add("Xdata", Xdata);
			Create2dInterpolationFunctionFromGrid_args.Add("Ydata", Ydata);
			Create2dInterpolationFunctionFromGrid_args.Add("FunctionValues", FunctionValues);
			Create2dInterpolationFunctionFromGrid_args.Add("XParameterTag", XParameterTag);
			Create2dInterpolationFunctionFromGrid_args.Add("YParameterTag", YParameterTag);
			Create2dInterpolationFunctionFromGrid_args.Add("FunctionValueParameterTag", FunctionValueParameterTag);
			Create2dInterpolationFunctionFromGrid_args.Add("TwoDimInterpolationMethod", TwoDimInterpolationMethod);
			return F3Formatter.f3_style_serialization("Create2dInterpolationFunctionFromGrid", Create2dInterpolationFunctionFromGrid_args);
		}

		// <summary>
		// Create a smooth two-dimensional function that returns the maximum of its arguments.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SmoothingParameter">The value of the smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dMaxFunction(object FunctionName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable Create2dMaxFunction_args = new Hashtable();
			Create2dMaxFunction_args.Add("FunctionName", FunctionName);
			Create2dMaxFunction_args.Add("SmoothingParameter", SmoothingParameter);
			Create2dMaxFunction_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("Create2dMaxFunction", Create2dMaxFunction_args);
		}

		// <summary>
		// Create a smooth two-dimensional function that returns the minimum of its arguments.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SmoothingParameter">The value of the smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dMinFunction(object FunctionName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable Create2dMinFunction_args = new Hashtable();
			Create2dMinFunction_args.Add("FunctionName", FunctionName);
			Create2dMinFunction_args.Add("SmoothingParameter", SmoothingParameter);
			Create2dMinFunction_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("Create2dMinFunction", Create2dMinFunction_args);
		}

		// <summary>
		// Create a two-dimensional function which takes two two-dimensional functions as input                                                       and raises the first to the power of the second.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseFunction">Base function.</param>
		// <param name="ExponentFunction">Exponent function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dPowerFunction(object FunctionName, object BaseFunction, object ExponentFunction)
		{

			Hashtable Create2dPowerFunction_args = new Hashtable();
			Create2dPowerFunction_args.Add("FunctionName", FunctionName);
			Create2dPowerFunction_args.Add("BaseFunction", BaseFunction);
			Create2dPowerFunction_args.Add("ExponentFunction", ExponentFunction);
			return F3Formatter.f3_style_serialization("Create2dPowerFunction", Create2dPowerFunction_args);
		}

		// <summary>
		// Create a two-dimensional function as the product of two                                                                        two-dimensional functions, evaluated at the same point.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="FirstFunction">Two-dimensional function to form first part of product.</param>
		// <param name="SecondFunction">Two-dimensional function to form second part of product.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dProductFunctionFrom2dFunctions(object FunctionName, object FirstFunction, object SecondFunction)
		{

			Hashtable Create2dProductFunctionFrom2dFunctions_args = new Hashtable();
			Create2dProductFunctionFrom2dFunctions_args.Add("FunctionName", FunctionName);
			Create2dProductFunctionFrom2dFunctions_args.Add("FirstFunction", FirstFunction);
			Create2dProductFunctionFrom2dFunctions_args.Add("SecondFunction", SecondFunction);
			return F3Formatter.f3_style_serialization("Create2dProductFunctionFrom2dFunctions", Create2dProductFunctionFrom2dFunctions_args);
		}

		// <summary>
		// Create a two-dimensional function as the ratio of two two-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="NumeratorFunction">Numerator function.</param>
		// <param name="DenominatorFunction">Denominator function.</param>
		// <param name="StepSize">Step size for numerical derivative calculations. Default value: 1.0e-8.</param>
		// <param name="StepSizeParameterTag">Tag to use for the step size.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object Create2dRatioFunction(object FunctionName, object NumeratorFunction, object DenominatorFunction, object StepSize, object StepSizeParameterTag)
		{

			Hashtable Create2dRatioFunction_args = new Hashtable();
			Create2dRatioFunction_args.Add("FunctionName", FunctionName);
			Create2dRatioFunction_args.Add("NumeratorFunction", NumeratorFunction);
			Create2dRatioFunction_args.Add("DenominatorFunction", DenominatorFunction);
			Create2dRatioFunction_args.Add("StepSize", StepSize);
			Create2dRatioFunction_args.Add("StepSizeParameterTag", StepSizeParameterTag);
			return F3Formatter.f3_style_serialization("Create2dRatioFunction", Create2dRatioFunction_args);
		}

		// <summary>
		// Create a three-dimensional function that is the composition of a three-dimensional function with a one-dimensional base function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseOneDimFunction">One-dimensional base function.</param>
		// <param name="ThreeDimFunction">Three-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dCompositionFunctionWith1dBase(object FunctionName, object BaseOneDimFunction, object ThreeDimFunction)
		{

			Hashtable Create3dCompositionFunctionWith1dBase_args = new Hashtable();
			Create3dCompositionFunctionWith1dBase_args.Add("FunctionName", FunctionName);
			Create3dCompositionFunctionWith1dBase_args.Add("BaseOneDimFunction", BaseOneDimFunction);
			Create3dCompositionFunctionWith1dBase_args.Add("ThreeDimFunction", ThreeDimFunction);
			return F3Formatter.f3_style_serialization("Create3dCompositionFunctionWith1dBase", Create3dCompositionFunctionWith1dBase_args);
		}

		// <summary>
		// Create a three-dimensional function that is the composition of three one-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseThreeDimFunction">Three-dimensional function to be composed.</param>
		// <param name="FirstOneDimFunction">First one-dimensional function.</param>
		// <param name="SecondOneDimFunction">Second one-dimensional function.</param>
		// <param name="ThirdOneDimFunction">Third one-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dCompositionFunctionWith1dFunctions(object FunctionName, object BaseThreeDimFunction, object FirstOneDimFunction, object SecondOneDimFunction, object ThirdOneDimFunction)
		{

			Hashtable Create3dCompositionFunctionWith1dFunctions_args = new Hashtable();
			Create3dCompositionFunctionWith1dFunctions_args.Add("FunctionName", FunctionName);
			Create3dCompositionFunctionWith1dFunctions_args.Add("BaseThreeDimFunction", BaseThreeDimFunction);
			Create3dCompositionFunctionWith1dFunctions_args.Add("FirstOneDimFunction", FirstOneDimFunction);
			Create3dCompositionFunctionWith1dFunctions_args.Add("SecondOneDimFunction", SecondOneDimFunction);
			Create3dCompositionFunctionWith1dFunctions_args.Add("ThirdOneDimFunction", ThirdOneDimFunction);
			return F3Formatter.f3_style_serialization("Create3dCompositionFunctionWith1dFunctions", Create3dCompositionFunctionWith1dFunctions_args);
		}

		// <summary>
		// Create a three-dimensional function that is the composition of two three-dimensional functions with a             two-dimensional base function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTwoDimFunction">Two-dimensional base function.</param>
		// <param name="FirstThreeDimFunction">First three-dimensional function.</param>
		// <param name="SecondThreeDimFunction">Second three-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dCompositionFunctionWith2dBase(object FunctionName, object BaseTwoDimFunction, object FirstThreeDimFunction, object SecondThreeDimFunction)
		{

			Hashtable Create3dCompositionFunctionWith2dBase_args = new Hashtable();
			Create3dCompositionFunctionWith2dBase_args.Add("FunctionName", FunctionName);
			Create3dCompositionFunctionWith2dBase_args.Add("BaseTwoDimFunction", BaseTwoDimFunction);
			Create3dCompositionFunctionWith2dBase_args.Add("FirstThreeDimFunction", FirstThreeDimFunction);
			Create3dCompositionFunctionWith2dBase_args.Add("SecondThreeDimFunction", SecondThreeDimFunction);
			return F3Formatter.f3_style_serialization("Create3dCompositionFunctionWith2dBase", Create3dCompositionFunctionWith2dBase_args);
		}

		// <summary>
		// Create a three-dimensional function that is the composition of three three-dimensional functions with a             three-dimensional base function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseThreeDimFunction">Three-dimensional base function.</param>
		// <param name="FirstThreeDimFunction">First three-dimensional function.</param>
		// <param name="SecondThreeDimFunction">Second three-dimensional function.</param>
		// <param name="ThirdThreeDimFunction">Third three-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dCompositionFunctionWith3dBase(object FunctionName, object BaseThreeDimFunction, object FirstThreeDimFunction, object SecondThreeDimFunction, object ThirdThreeDimFunction)
		{

			Hashtable Create3dCompositionFunctionWith3dBase_args = new Hashtable();
			Create3dCompositionFunctionWith3dBase_args.Add("FunctionName", FunctionName);
			Create3dCompositionFunctionWith3dBase_args.Add("BaseThreeDimFunction", BaseThreeDimFunction);
			Create3dCompositionFunctionWith3dBase_args.Add("FirstThreeDimFunction", FirstThreeDimFunction);
			Create3dCompositionFunctionWith3dBase_args.Add("SecondThreeDimFunction", SecondThreeDimFunction);
			Create3dCompositionFunctionWith3dBase_args.Add("ThirdThreeDimFunction", ThirdThreeDimFunction);
			return F3Formatter.f3_style_serialization("Create3dCompositionFunctionWith3dBase", Create3dCompositionFunctionWith3dBase_args);
		}

		// <summary>
		// Create a convexity adjustment function based on an arbitrary 3d function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ThreeDimFunction">3d function to perform the convexity adjustment.</param>
		// <returns>Retuns the name of the constructed object of type ConvexityAdjustmentFunction.</returns>
		public object Create3dFunctionConvexityAdjustmentFunction(object FunctionName, object ThreeDimFunction)
		{

			Hashtable Create3dFunctionConvexityAdjustmentFunction_args = new Hashtable();
			Create3dFunctionConvexityAdjustmentFunction_args.Add("FunctionName", FunctionName);
			Create3dFunctionConvexityAdjustmentFunction_args.Add("ThreeDimFunction", ThreeDimFunction);
			return F3Formatter.f3_style_serialization("Create3dFunctionConvexityAdjustmentFunction", Create3dFunctionConvexityAdjustmentFunction_args);
		}

		// <summary>
		// Creates a three-dimensional interpolation function from a grid of (x,y,z) points.
		// </summary>
		// <param name="FunctionName">Name to use for the three-dimensional interpolation function.</param>
		// <param name="Xdata">The x-coordinates of the data.</param>
		// <param name="Ydata">The y-coordinates of the data.</param>
		// <param name="Zdata">The z-coordinates of the data.</param>
		// <param name="FunctionValues">The values of the function evaluated at each of the (x,y,z) points.</param>
		// <param name="XParameterTag">Tag to use for the X parameters.</param>
		// <param name="YParameterTag">Tag to use for the Y parameters.</param>
		// <param name="ZParameterTag">Tag to use for the Z parameters.</param>
		// <param name="FunctionValueParameterTags">Vector of tags to use for the function value parameters at different z values.</param>
		// <param name="ThreeDimInterpolationMethod">A three-dimensional interpolation method.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dInterpolationFunctionFromGrid(object FunctionName, object Xdata, object Ydata, object Zdata, object FunctionValues, object XParameterTag, object YParameterTag, object ZParameterTag, object FunctionValueParameterTags, object ThreeDimInterpolationMethod)
		{

			Hashtable Create3dInterpolationFunctionFromGrid_args = new Hashtable();
			Create3dInterpolationFunctionFromGrid_args.Add("FunctionName", FunctionName);
			Create3dInterpolationFunctionFromGrid_args.Add("Xdata", Xdata);
			Create3dInterpolationFunctionFromGrid_args.Add("Ydata", Ydata);
			Create3dInterpolationFunctionFromGrid_args.Add("Zdata", Zdata);
			Create3dInterpolationFunctionFromGrid_args.Add("FunctionValues", FunctionValues);
			Create3dInterpolationFunctionFromGrid_args.Add("XParameterTag", XParameterTag);
			Create3dInterpolationFunctionFromGrid_args.Add("YParameterTag", YParameterTag);
			Create3dInterpolationFunctionFromGrid_args.Add("ZParameterTag", ZParameterTag);
			Create3dInterpolationFunctionFromGrid_args.Add("FunctionValueParameterTags", FunctionValueParameterTags);
			Create3dInterpolationFunctionFromGrid_args.Add("ThreeDimInterpolationMethod", ThreeDimInterpolationMethod);
			return F3Formatter.f3_style_serialization("Create3dInterpolationFunctionFromGrid", Create3dInterpolationFunctionFromGrid_args);
		}

		// <summary>
		// Create a three-dimensional function as the product of a one-dimensional and a two-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="OneDimFunction">One-dimensional function to be multiplied.</param>
		// <param name="TwoDimFunction">Two-dimensional function to be multiplied.</param>
		// <param name="OneDimFunctionFirst">Flag indicating the order of arguments.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dProductFunctionFrom1dAnd2dFunctions(object FunctionName, object OneDimFunction, object TwoDimFunction, object OneDimFunctionFirst)
		{

			Hashtable Create3dProductFunctionFrom1dAnd2dFunctions_args = new Hashtable();
			Create3dProductFunctionFrom1dAnd2dFunctions_args.Add("FunctionName", FunctionName);
			Create3dProductFunctionFrom1dAnd2dFunctions_args.Add("OneDimFunction", OneDimFunction);
			Create3dProductFunctionFrom1dAnd2dFunctions_args.Add("TwoDimFunction", TwoDimFunction);
			Create3dProductFunctionFrom1dAnd2dFunctions_args.Add("OneDimFunctionFirst", OneDimFunctionFirst);
			return F3Formatter.f3_style_serialization("Create3dProductFunctionFrom1dAnd2dFunctions", Create3dProductFunctionFrom1dAnd2dFunctions_args);
		}

		// <summary>
		// Create a three-dimensional function as the product of a one-dimensional and a three-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="OneDimFunction">One-dimensional function to be multiplied.</param>
		// <param name="ThreeDimFunction">Three-dimensional function to be multiplied.</param>
		// <param name="OneDimFunctionArgumentIndex">Index indicating the one-dimensional function's argument.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dProductFunctionFrom1dAnd3dFunctions(object FunctionName, object OneDimFunction, object ThreeDimFunction, object OneDimFunctionArgumentIndex)
		{

			Hashtable Create3dProductFunctionFrom1dAnd3dFunctions_args = new Hashtable();
			Create3dProductFunctionFrom1dAnd3dFunctions_args.Add("FunctionName", FunctionName);
			Create3dProductFunctionFrom1dAnd3dFunctions_args.Add("OneDimFunction", OneDimFunction);
			Create3dProductFunctionFrom1dAnd3dFunctions_args.Add("ThreeDimFunction", ThreeDimFunction);
			Create3dProductFunctionFrom1dAnd3dFunctions_args.Add("OneDimFunctionArgumentIndex", OneDimFunctionArgumentIndex);
			return F3Formatter.f3_style_serialization("Create3dProductFunctionFrom1dAnd3dFunctions", Create3dProductFunctionFrom1dAnd3dFunctions_args);
		}

		// <summary>
		// Create a three-dimensional function as the product of a two-dimensional and a three-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TwoDimFunction">Two-dimensional function to be multiplied.</param>
		// <param name="ThreeDimFunction">Three-dimensional function to be multiplied.</param>
		// <param name="TwoDimFunctionArgumentIndices">Two indices indicating the two-dimensional function's arguments.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dProductFunctionFrom2dAnd3dFunctions(object FunctionName, object TwoDimFunction, object ThreeDimFunction, object TwoDimFunctionArgumentIndices)
		{

			Hashtable Create3dProductFunctionFrom2dAnd3dFunctions_args = new Hashtable();
			Create3dProductFunctionFrom2dAnd3dFunctions_args.Add("FunctionName", FunctionName);
			Create3dProductFunctionFrom2dAnd3dFunctions_args.Add("TwoDimFunction", TwoDimFunction);
			Create3dProductFunctionFrom2dAnd3dFunctions_args.Add("ThreeDimFunction", ThreeDimFunction);
			Create3dProductFunctionFrom2dAnd3dFunctions_args.Add("TwoDimFunctionArgumentIndices", TwoDimFunctionArgumentIndices);
			return F3Formatter.f3_style_serialization("Create3dProductFunctionFrom2dAnd3dFunctions", Create3dProductFunctionFrom2dAnd3dFunctions_args);
		}

		// <summary>
		// Create a three-dimensional function as the sum of a one-dimensional and a two-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="OneDimFunction">One-dimensional function to be added.</param>
		// <param name="TwoDimFunction">Two-dimensional function to be added.</param>
		// <param name="OneDimArgIndex">Index indicating order of arguments.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object Create3dSumFunctionFrom1dAnd2dFunctions(object FunctionName, object OneDimFunction, object TwoDimFunction, object OneDimArgIndex)
		{

			Hashtable Create3dSumFunctionFrom1dAnd2dFunctions_args = new Hashtable();
			Create3dSumFunctionFrom1dAnd2dFunctions_args.Add("FunctionName", FunctionName);
			Create3dSumFunctionFrom1dAnd2dFunctions_args.Add("OneDimFunction", OneDimFunction);
			Create3dSumFunctionFrom1dAnd2dFunctions_args.Add("TwoDimFunction", TwoDimFunction);
			Create3dSumFunctionFrom1dAnd2dFunctions_args.Add("OneDimArgIndex", OneDimArgIndex);
			return F3Formatter.f3_style_serialization("Create3dSumFunctionFrom1dAnd2dFunctions", Create3dSumFunctionFrom1dAnd2dFunctions_args);
		}

		// <summary>
		// Create a market data set containing a set of quotes for ATM straddle option strategies at different maturities.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of option expiries.</param>
		// <param name="ATMTypes">Vector of ATM convention types for straddle quotes.</param>
		// <param name="StraddleQuotes">Vector of the straddle quotes at the expiries.</param>
		// <param name="DataName">Name of market data.</param>
		// <param name="DataType">Type of market data.</param>
		// <param name="UnderlyingIndex">Index describing the option's underlying.</param>
		// <param name="DeltaConvention">Market convention for the delta-based option strike. Default value: ForwardRawDelta.</param>
		// <param name="QuoteDate">Date on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateATMStraddleMarketData(object MarketDataSetName, object Expiries, object ATMTypes, object StraddleQuotes, object DataName, object DataType, object UnderlyingIndex, object DeltaConvention, object QuoteDate)
		{

			Hashtable CreateATMStraddleMarketData_args = new Hashtable();
			CreateATMStraddleMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateATMStraddleMarketData_args.Add("Expiries", Expiries);
			CreateATMStraddleMarketData_args.Add("ATMTypes", ATMTypes);
			CreateATMStraddleMarketData_args.Add("StraddleQuotes", StraddleQuotes);
			CreateATMStraddleMarketData_args.Add("DataName", DataName);
			CreateATMStraddleMarketData_args.Add("DataType", DataType);
			CreateATMStraddleMarketData_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateATMStraddleMarketData_args.Add("DeltaConvention", DeltaConvention);
			CreateATMStraddleMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateATMStraddleMarketData", CreateATMStraddleMarketData_args);
		}

		// <summary>
		// Create an actual day count convention.
		// </summary>
		// <param name="DayCountName">Name to use for the day counting type.</param>
		// <param name="Denominator">The denominator to use when calculating actual day fraction.</param>
		// <returns>Retuns the name of the constructed object of type DayCountConvention.</returns>
		public object CreateActualDaycountConvention(object DayCountName, object Denominator)
		{

			Hashtable CreateActualDaycountConvention_args = new Hashtable();
			CreateActualDaycountConvention_args.Add("DayCountName", DayCountName);
			CreateActualDaycountConvention_args.Add("Denominator", Denominator);
			return F3Formatter.f3_style_serialization("CreateActualDaycountConvention", CreateActualDaycountConvention_args);
		}

		// <summary>
		// Create an adaptive integration method from a non-adaptive method.
		// </summary>
		// <param name="MethodName">Name to use for the method.</param>
		// <param name="Method">Non-adaptive integration method.</param>
		// <param name="Tolerance">Tolerance.</param>
		// <returns>Retuns the name of the constructed object of type IntegrationMethod.</returns>
		public object CreateAdaptiveIntegrationMethod(object MethodName, object Method, object Tolerance)
		{

			Hashtable CreateAdaptiveIntegrationMethod_args = new Hashtable();
			CreateAdaptiveIntegrationMethod_args.Add("MethodName", MethodName);
			CreateAdaptiveIntegrationMethod_args.Add("Method", Method);
			CreateAdaptiveIntegrationMethod_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreateAdaptiveIntegrationMethod", CreateAdaptiveIntegrationMethod_args);
		}

		// <summary>
		// Create a maturity calculator that adjusts an underlying calculation according to a holiday convention.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for maturity calculator.</param>
		// <param name="UnderlyingMaturityCalculator">Underlying maturity calculator.</param>
		// <param name="HolidayConventions">Holiday conventions for adjusting payment dates.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateAdjustingMaturityCalculator(object MaturityCalculatorName, object UnderlyingMaturityCalculator, object HolidayConventions)
		{

			Hashtable CreateAdjustingMaturityCalculator_args = new Hashtable();
			CreateAdjustingMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateAdjustingMaturityCalculator_args.Add("UnderlyingMaturityCalculator", UnderlyingMaturityCalculator);
			CreateAdjustingMaturityCalculator_args.Add("HolidayConventions", HolidayConventions);
			return F3Formatter.f3_style_serialization("CreateAdjustingMaturityCalculator", CreateAdjustingMaturityCalculator_args);
		}

		// <summary>
		// Create a backward evolution operator for performing an affine transformation.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="ScaleReal">Real part of the scaling coefficient.</param>
		// <param name="ScaleImag">Imaginary part of the scaling coefficient.</param>
		// <param name="ShiftReal">Real part of the shift coefficient.</param>
		// <param name="ShiftImag">Imaginary part of the shift coefficient.</param>
		// <param name="ScaleRealTag">Tag to use for the real part of the scaling coefficient.</param>
		// <param name="ScaleImagTag">Tag to use for the imaginary part of the scaling coefficient.</param>
		// <param name="ShiftRealTag">Tag to use for the real part of the shift coefficient.</param>
		// <param name="ShiftImagTag">Tag to use for the imaginary part of the shift coefficient.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateAffineTransformationOperator(object OperatorName, object ScaleReal, object ScaleImag, object ShiftReal, object ShiftImag, object ScaleRealTag, object ScaleImagTag, object ShiftRealTag, object ShiftImagTag)
		{

			Hashtable CreateAffineTransformationOperator_args = new Hashtable();
			CreateAffineTransformationOperator_args.Add("OperatorName", OperatorName);
			CreateAffineTransformationOperator_args.Add("ScaleReal", ScaleReal);
			CreateAffineTransformationOperator_args.Add("ScaleImag", ScaleImag);
			CreateAffineTransformationOperator_args.Add("ShiftReal", ShiftReal);
			CreateAffineTransformationOperator_args.Add("ShiftImag", ShiftImag);
			CreateAffineTransformationOperator_args.Add("ScaleRealTag", ScaleRealTag);
			CreateAffineTransformationOperator_args.Add("ScaleImagTag", ScaleImagTag);
			CreateAffineTransformationOperator_args.Add("ShiftRealTag", ShiftRealTag);
			CreateAffineTransformationOperator_args.Add("ShiftImagTag", ShiftImagTag);
			return F3Formatter.f3_style_serialization("CreateAffineTransformationOperator", CreateAffineTransformationOperator_args);
		}

		// <summary>
		// Create an affine yield modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="AMatrix">Matrix corresponding to the A function.</param>
		// <param name="AMatrixTag">Tag for the A Matrix.</param>
		// <param name="BMatrix">Matrix corresponding to the B function.</param>
		// <param name="BMatrixTag">Tag for the B Matrix.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateAffineYieldModifier(object ModifierName, object AMatrix, object AMatrixTag, object BMatrix, object BMatrixTag)
		{

			Hashtable CreateAffineYieldModifier_args = new Hashtable();
			CreateAffineYieldModifier_args.Add("ModifierName", ModifierName);
			CreateAffineYieldModifier_args.Add("AMatrix", AMatrix);
			CreateAffineYieldModifier_args.Add("AMatrixTag", AMatrixTag);
			CreateAffineYieldModifier_args.Add("BMatrix", BMatrix);
			CreateAffineYieldModifier_args.Add("BMatrixTag", BMatrixTag);
			return F3Formatter.f3_style_serialization("CreateAffineYieldModifier", CreateAffineYieldModifier_args);
		}

		// <summary>
		// Create an Altiplano payoff modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of  time points.</param>
		// <param name="EffectiveDatePrices">Vector of asset prices on effective date.</param>
		// <param name="Principal">Principal amount.</param>
		// <param name="Coupon">Coupon paid out if barrier not breached.</param>
		// <param name="Strike">Strike of call option if barrier breached.</param>
		// <param name="Barrier">Barrier on return.</param>
		// <param name="SmoothingForMinMax">Smoothing parameter for minimum and maximum operations.</param>
		// <param name="SmoothingForIsLess">Smoothing parameter for isless operation.</param>
		// <param name="EffectiveDatePricesTag">Tag to use for asset prices on effective date.</param>
		// <param name="PrincipalTag">Tag to use for principal amount.</param>
		// <param name="CouponTag">Tag to use for coupon.</param>
		// <param name="StrikeTag">Tag to use for strike.</param>
		// <param name="BarrierTag">Tag to use for barrier parameter.</param>
		// <param name="SmoothingForMinMaxTag">Tag to use for smoothing for min and max.</param>
		// <param name="SmoothingForIsLessTag">Tag to use for smoothing for isless.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateAltiplanoPayoffModifier(object ModifierName, object TimePoints, object EffectiveDatePrices, object Principal, object Coupon, object Strike, object Barrier, object SmoothingForMinMax, object SmoothingForIsLess, object EffectiveDatePricesTag,
		object PrincipalTag, object CouponTag, object StrikeTag, object BarrierTag, object SmoothingForMinMaxTag, object SmoothingForIsLessTag)
		{

			Hashtable CreateAltiplanoPayoffModifier_args = new Hashtable();
			CreateAltiplanoPayoffModifier_args.Add("ModifierName", ModifierName);
			CreateAltiplanoPayoffModifier_args.Add("TimePoints", TimePoints);
			CreateAltiplanoPayoffModifier_args.Add("EffectiveDatePrices", EffectiveDatePrices);
			CreateAltiplanoPayoffModifier_args.Add("Principal", Principal);
			CreateAltiplanoPayoffModifier_args.Add("Coupon", Coupon);
			CreateAltiplanoPayoffModifier_args.Add("Strike", Strike);
			CreateAltiplanoPayoffModifier_args.Add("Barrier", Barrier);
			CreateAltiplanoPayoffModifier_args.Add("SmoothingForMinMax", SmoothingForMinMax);
			CreateAltiplanoPayoffModifier_args.Add("SmoothingForIsLess", SmoothingForIsLess);
			CreateAltiplanoPayoffModifier_args.Add("EffectiveDatePricesTag", EffectiveDatePricesTag);
			CreateAltiplanoPayoffModifier_args.Add("PrincipalTag", PrincipalTag);
			CreateAltiplanoPayoffModifier_args.Add("CouponTag", CouponTag);
			CreateAltiplanoPayoffModifier_args.Add("StrikeTag", StrikeTag);
			CreateAltiplanoPayoffModifier_args.Add("BarrierTag", BarrierTag);
			CreateAltiplanoPayoffModifier_args.Add("SmoothingForMinMaxTag", SmoothingForMinMaxTag);
			CreateAltiplanoPayoffModifier_args.Add("SmoothingForIsLessTag", SmoothingForIsLessTag);
			return F3Formatter.f3_style_serialization("CreateAltiplanoPayoffModifier", CreateAltiplanoPayoffModifier_args);
		}

		// <summary>
		// Create a valuation specification for American option pricing via extrapolation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="SequenceValuationMethod">Valuation specification for each Bermudan option in the equivalent product sequence.</param>
		// <param name="SequencingStrategy">Strategy for forming the sequence of Bermudan options.</param>
		// <param name="UnderlyingIndex">Underlying index of the American option whose value is to be obtained via extrapolation.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateAmericanExtrapolationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object SequenceValuationMethod, object SequencingStrategy, object UnderlyingIndex)
		{

			Hashtable CreateAmericanExtrapolationValuationSpecification_args = new Hashtable();
			CreateAmericanExtrapolationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateAmericanExtrapolationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateAmericanExtrapolationValuationSpecification_args.Add("SequenceValuationMethod", SequenceValuationMethod);
			CreateAmericanExtrapolationValuationSpecification_args.Add("SequencingStrategy", SequencingStrategy);
			CreateAmericanExtrapolationValuationSpecification_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("CreateAmericanExtrapolationValuationSpecification", CreateAmericanExtrapolationValuationSpecification_args);
		}

		// <summary>
		// Define a American futures option contract type.
		// </summary>
		// <param name="ContractName">Name to use for the American futures option contract type.</param>
		// <param name="ContractType">Underlying futures contract type .</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the option expiry date .</param>
		// <returns>Retuns the name of the constructed object of type FuturesOptionContractType.</returns>
		public object CreateAmericanFuturesOptionContractType(object ContractName, object ContractType, object MaturityCalculator)
		{

			Hashtable CreateAmericanFuturesOptionContractType_args = new Hashtable();
			CreateAmericanFuturesOptionContractType_args.Add("ContractName", ContractName);
			CreateAmericanFuturesOptionContractType_args.Add("ContractType", ContractType);
			CreateAmericanFuturesOptionContractType_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateAmericanFuturesOptionContractType", CreateAmericanFuturesOptionContractType_args);
		}

		// <summary>
		// Create an American option on an underlying index.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Underlying">Underlying on which the option is written.</param>
		// <param name="Expiry">Time at which the option expires.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Strike">Strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <param name="Start">Start of the exercise period. Default value: default-constructed instance of type time_point.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateAmericanOption(object ProductName, object Underlying, object Expiry, object Notional, object Strike, object Payoff, object BuySell, object Start)
		{

			Hashtable CreateAmericanOption_args = new Hashtable();
			CreateAmericanOption_args.Add("ProductName", ProductName);
			CreateAmericanOption_args.Add("Underlying", Underlying);
			CreateAmericanOption_args.Add("Expiry", Expiry);
			CreateAmericanOption_args.Add("Notional", Notional);
			CreateAmericanOption_args.Add("Strike", Strike);
			CreateAmericanOption_args.Add("Payoff", Payoff);
			CreateAmericanOption_args.Add("BuySell", BuySell);
			CreateAmericanOption_args.Add("Start", Start);
			return F3Formatter.f3_style_serialization("CreateAmericanOption", CreateAmericanOption_args);
		}

		// <summary>
		// Create an amortizing bond that repays part of the principal along with the coupon payments.
		// </summary>
		// <param name="BondName">Name to use for the created bond.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="Notionals">The amortization schedule.</param>
		// <returns>Retuns the name of the constructed object of type Bond.</returns>
		public object CreateAmortizingBond(object BondName, object Bond, object Notionals)
		{

			Hashtable CreateAmortizingBond_args = new Hashtable();
			CreateAmortizingBond_args.Add("BondName", BondName);
			CreateAmortizingBond_args.Add("Bond", Bond);
			CreateAmortizingBond_args.Add("Notionals", Notionals);
			return F3Formatter.f3_style_serialization("CreateAmortizingBond", CreateAmortizingBond_args);
		}

		// <summary>
		// Create an arithmetic average rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for rate sampling.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateArithmeticAverageRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateArithmeticAverageRateIndex_args = new Hashtable();
			CreateArithmeticAverageRateIndex_args.Add("IndexName", IndexName);
			CreateArithmeticAverageRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateArithmeticAverageRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateArithmeticAverageRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateArithmeticAverageRateIndex", CreateArithmeticAverageRateIndex_args);
		}

		// <summary>
		// Creates a new article bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the article bibliography entry.</param>
		// <param name="Author">Author to use for the article bibliography entry.</param>
		// <param name="Year">Year to use for the article bibliography entry.</param>
		// <param name="Title">Title to use for the article bibliography entry.</param>
		// <param name="Journal">Journal to use for the article bibliography entry.</param>
		// <param name="Volume">Volume to use for the article bibliography entry.</param>
		// <param name="Pages">Pages to use for the article bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateArticleBibliographyEntry(object Name, object Author, object Year, object Title, object Journal, object Volume, object Pages)
		{

			Hashtable CreateArticleBibliographyEntry_args = new Hashtable();
			CreateArticleBibliographyEntry_args.Add("Name", Name);
			CreateArticleBibliographyEntry_args.Add("Author", Author);
			CreateArticleBibliographyEntry_args.Add("Year", Year);
			CreateArticleBibliographyEntry_args.Add("Title", Title);
			CreateArticleBibliographyEntry_args.Add("Journal", Journal);
			CreateArticleBibliographyEntry_args.Add("Volume", Volume);
			CreateArticleBibliographyEntry_args.Add("Pages", Pages);
			return F3Formatter.f3_style_serialization("CreateArticleBibliographyEntry", CreateArticleBibliographyEntry_args);
		}

		// <summary>
		// Create an index representing a cash-settled Asian option.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="ObservationScheduleGenerator">Specification of a sampling schedule for observing the underlying index.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateAsianOptionIndex(object IndexName, object UnderlyingIndex, object ObservationScheduleGenerator, object Strike, object Payoff)
		{

			Hashtable CreateAsianOptionIndex_args = new Hashtable();
			CreateAsianOptionIndex_args.Add("IndexName", IndexName);
			CreateAsianOptionIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateAsianOptionIndex_args.Add("ObservationScheduleGenerator", ObservationScheduleGenerator);
			CreateAsianOptionIndex_args.Add("Strike", Strike);
			CreateAsianOptionIndex_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateAsianOptionIndex", CreateAsianOptionIndex_args);
		}

		// <summary>
		// Create an Asian payoff modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="OptionStyle">Payoff specification.</param>
		// <param name="AveragingStyle">Type of averaging.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="CurrentAveragePrice">Current average price (only used if averaging has already started).</param>
		// <param name="Strike">Strike price.</param>
		// <param name="InterpolationBound">Distance from origin to use for interpolation of the positive value.</param>
		// <param name="StrikeTag">Tag to use for strike parameters.</param>
		// <param name="BoundParameterTag">Tag to use for interpolation bounds parameters.</param>
		// <param name="ScaleParameterTag">Tag to use for the internal scaling of +-1 for the call or put payoff.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateAsianPayoffModifier(object ModifierName, object OptionStyle, object AveragingStyle, object TimePoints, object CurrentAveragePrice, object Strike, object InterpolationBound, object StrikeTag, object BoundParameterTag, object ScaleParameterTag)
		{

			Hashtable CreateAsianPayoffModifier_args = new Hashtable();
			CreateAsianPayoffModifier_args.Add("ModifierName", ModifierName);
			CreateAsianPayoffModifier_args.Add("OptionStyle", OptionStyle);
			CreateAsianPayoffModifier_args.Add("AveragingStyle", AveragingStyle);
			CreateAsianPayoffModifier_args.Add("TimePoints", TimePoints);
			CreateAsianPayoffModifier_args.Add("CurrentAveragePrice", CurrentAveragePrice);
			CreateAsianPayoffModifier_args.Add("Strike", Strike);
			CreateAsianPayoffModifier_args.Add("InterpolationBound", InterpolationBound);
			CreateAsianPayoffModifier_args.Add("StrikeTag", StrikeTag);
			CreateAsianPayoffModifier_args.Add("BoundParameterTag", BoundParameterTag);
			CreateAsianPayoffModifier_args.Add("ScaleParameterTag", ScaleParameterTag);
			return F3Formatter.f3_style_serialization("CreateAsianPayoffModifier", CreateAsianPayoffModifier_args);
		}

		// <summary>
		// Create an asset-backed credit default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <param name="Premium">The premium paid on each roll of the premium leg.</param>
		// <param name="UpfrontFeeFraction">The fraction of the notional paid upfront.</param>
		// <param name="PayAccruedInterestUponDefault">Pay accrued interest upon default.</param>
		// <param name="MarketConvention">market conventions.</param>
		// <param name="WeightDefaultUnit">The weight of the default unit index. Default value: 1.0.</param>
		// <param name="WeightDefaultRecovery">The weight of the default recovery index. Default value: -1.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateAssetBackedCreditDefaultSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object CreditContract, object Premium, object UpfrontFeeFraction, object PayAccruedInterestUponDefault, object MarketConvention,
		object WeightDefaultUnit, object WeightDefaultRecovery, object PayRec)
		{

			Hashtable CreateAssetBackedCreditDefaultSwap_args = new Hashtable();
			CreateAssetBackedCreditDefaultSwap_args.Add("ProductName", ProductName);
			CreateAssetBackedCreditDefaultSwap_args.Add("StartDate", StartDate);
			CreateAssetBackedCreditDefaultSwap_args.Add("Maturity", Maturity);
			CreateAssetBackedCreditDefaultSwap_args.Add("Notional", Notional);
			CreateAssetBackedCreditDefaultSwap_args.Add("Currency", Currency);
			CreateAssetBackedCreditDefaultSwap_args.Add("CreditContract", CreditContract);
			CreateAssetBackedCreditDefaultSwap_args.Add("Premium", Premium);
			CreateAssetBackedCreditDefaultSwap_args.Add("UpfrontFeeFraction", UpfrontFeeFraction);
			CreateAssetBackedCreditDefaultSwap_args.Add("PayAccruedInterestUponDefault", PayAccruedInterestUponDefault);
			CreateAssetBackedCreditDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateAssetBackedCreditDefaultSwap_args.Add("WeightDefaultUnit", WeightDefaultUnit);
			CreateAssetBackedCreditDefaultSwap_args.Add("WeightDefaultRecovery", WeightDefaultRecovery);
			CreateAssetBackedCreditDefaultSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateAssetBackedCreditDefaultSwap", CreateAssetBackedCreditDefaultSwap_args);
		}

		// <summary>
		// Create a market data set for a single asset price.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="Price">Asset price quote.</param>
		// <param name="MaturityDescription">Maturity of the forward quote. Default of 0b is a spot quote.. Default value: 0b.</param>
		// <param name="EquityEntity">Equity entity.</param>
		// <param name="AssetPriceName">Name to use for the asset price market data.</param>
		// <param name="AssetPriceType">Type to use for the asset price market data.</param>
		// <param name="MarketConventions">Settlement market convention.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateAssetPriceMarketData(object MarketDataSetName, object Price, object MaturityDescription, object EquityEntity, object AssetPriceName, object AssetPriceType, object MarketConventions)
		{

			Hashtable CreateAssetPriceMarketData_args = new Hashtable();
			CreateAssetPriceMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateAssetPriceMarketData_args.Add("Price", Price);
			CreateAssetPriceMarketData_args.Add("MaturityDescription", MaturityDescription);
			CreateAssetPriceMarketData_args.Add("EquityEntity", EquityEntity);
			CreateAssetPriceMarketData_args.Add("AssetPriceName", AssetPriceName);
			CreateAssetPriceMarketData_args.Add("AssetPriceType", AssetPriceType);
			CreateAssetPriceMarketData_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateAssetPriceMarketData", CreateAssetPriceMarketData_args);
		}

		// <summary>
		// Create a valuation specification for numeric calculations of one or more asset prices.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Currency to use as the numeraire, or valuation, currency.</param>
		// <param name="NamedIndices">Named indices. Default value: default-constructed instance of type index_map.</param>
		// <param name="NamedStateVariableTemplates">Named state variable templates.</param>
		// <param name="Generator">Base generator to use in simulation computations.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="Iterations">Iteration control. Default value: 1023.</param>
		// <param name="SimulationPoints">Number of points to use in the discretization, in addition to the fixing points. Default value: 0.</param>
		// <param name="AuxiliaryIterations">Iteration control for auxiliary simulation. Default value: default-constructed instance of type computation_specification.</param>
		// <param name="NamedSimFuncTemplates">Named simulation function templates. Default value: default-constructed instance of type sim_function_template_map.</param>
		// <param name="CorrelationSpec">Method to use for correlation matrix decomposition. Default value: Cholesky.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateAssetSimulationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency, object NamedIndices, object NamedStateVariableTemplates, object Generator, object CalculationMethod, object Iterations, object SimulationPoints, object AuxiliaryIterations,
		object NamedSimFuncTemplates, object CorrelationSpec)
		{

			Hashtable CreateAssetSimulationValuationSpecification_args = new Hashtable();
			CreateAssetSimulationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateAssetSimulationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateAssetSimulationValuationSpecification_args.Add("Currency", Currency);
			CreateAssetSimulationValuationSpecification_args.Add("NamedIndices", NamedIndices);
			CreateAssetSimulationValuationSpecification_args.Add("NamedStateVariableTemplates", NamedStateVariableTemplates);
			CreateAssetSimulationValuationSpecification_args.Add("Generator", Generator);
			CreateAssetSimulationValuationSpecification_args.Add("CalculationMethod", CalculationMethod);
			CreateAssetSimulationValuationSpecification_args.Add("Iterations", Iterations);
			CreateAssetSimulationValuationSpecification_args.Add("SimulationPoints", SimulationPoints);
			CreateAssetSimulationValuationSpecification_args.Add("AuxiliaryIterations", AuxiliaryIterations);
			CreateAssetSimulationValuationSpecification_args.Add("NamedSimFuncTemplates", NamedSimFuncTemplates);
			CreateAssetSimulationValuationSpecification_args.Add("CorrelationSpec", CorrelationSpec);
			return F3Formatter.f3_style_serialization("CreateAssetSimulationValuationSpecification", CreateAssetSimulationValuationSpecification_args);
		}

		// <summary>
		// Create an asset swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Bond">The underlying bond.</param>
		// <param name="SettlementDetails">Bond settlement details that are used to select the relevant flows.</param>
		// <param name="ScalingIndex">Index scaling the cash flow payments. Default value: UnitConstant.</param>
		// <param name="Notional">The notional of the swap.</param>
		// <param name="FloatingRateIndex">The rate paid on the floating leg of the swap.</param>
		// <param name="FloatingLegMarketConvention">Schedule generator for the floating leg.</param>
		// <param name="Spread">The asset swap spread - the margin over the floating rate paid on each floating leg payment.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateAssetSwap(object ProductName, object Bond, object SettlementDetails, object ScalingIndex, object Notional, object FloatingRateIndex, object FloatingLegMarketConvention, object Spread, object PayRec)
		{

			Hashtable CreateAssetSwap_args = new Hashtable();
			CreateAssetSwap_args.Add("ProductName", ProductName);
			CreateAssetSwap_args.Add("Bond", Bond);
			CreateAssetSwap_args.Add("SettlementDetails", SettlementDetails);
			CreateAssetSwap_args.Add("ScalingIndex", ScalingIndex);
			CreateAssetSwap_args.Add("Notional", Notional);
			CreateAssetSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateAssetSwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateAssetSwap_args.Add("Spread", Spread);
			CreateAssetSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateAssetSwap", CreateAssetSwap_args);
		}

		// <summary>
		// Create an automatically sized histogram source.
		// </summary>
		// <param name="HistogramName">Name to use for the histogram source.</param>
		// <param name="NumBins">Number of bins. Default value: 50.</param>
		// <param name="WorkoutSize">Number of data points collected for autodetection.</param>
		// <returns>Retuns the name of the constructed object of type Histogram.</returns>
		public object CreateAutoSizedUniformBinsHistogram(object HistogramName, object NumBins, object WorkoutSize)
		{

			Hashtable CreateAutoSizedUniformBinsHistogram_args = new Hashtable();
			CreateAutoSizedUniformBinsHistogram_args.Add("HistogramName", HistogramName);
			CreateAutoSizedUniformBinsHistogram_args.Add("NumBins", NumBins);
			CreateAutoSizedUniformBinsHistogram_args.Add("WorkoutSize", WorkoutSize);
			return F3Formatter.f3_style_serialization("CreateAutoSizedUniformBinsHistogram", CreateAutoSizedUniformBinsHistogram_args);
		}

		// <summary>
		// Create a backward differentiation method.
		// </summary>
		// <param name="FunctionName">Name to use for the method.</param>
		// <param name="StepSize">Numerical differentiation step size.</param>
		// <param name="Tag">Tag to use for the step size.</param>
		// <returns>Retuns the name of the constructed object of type DifferentiationMethod.</returns>
		public object CreateBackwardDifferentiationMethod(object FunctionName, object StepSize, object Tag)
		{

			Hashtable CreateBackwardDifferentiationMethod_args = new Hashtable();
			CreateBackwardDifferentiationMethod_args.Add("FunctionName", FunctionName);
			CreateBackwardDifferentiationMethod_args.Add("StepSize", StepSize);
			CreateBackwardDifferentiationMethod_args.Add("Tag", Tag);
			return F3Formatter.f3_style_serialization("CreateBackwardDifferentiationMethod", CreateBackwardDifferentiationMethod_args);
		}

		// <summary>
		// Create a backward evolution tree element from an operator and a collection of underlying tree elements.
		// </summary>
		// <param name="ElementName">Name to use for the new tree element.</param>
		// <param name="operator">operator to apply to the underlying tree elements.</param>
		// <param name="UnderlyingElements">Underlying tree elements.</param>
		// <returns>Retuns the name of the constructed object of type TreeElementSource.</returns>
		public object CreateBackwardEvolutionTreeElement(object ElementName, object opr, object UnderlyingElements)
		{

			Hashtable CreateBackwardEvolutionTreeElement_args = new Hashtable();
			CreateBackwardEvolutionTreeElement_args.Add("ElementName", ElementName);
			CreateBackwardEvolutionTreeElement_args.Add("Operator", opr);
			CreateBackwardEvolutionTreeElement_args.Add("UnderlyingElements", UnderlyingElements);
			return F3Formatter.f3_style_serialization("CreateBackwardEvolutionTreeElement", CreateBackwardEvolutionTreeElement_args);
		}

		// <summary>
		// Create a Bank Bill.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the Bank Bill.</param>
		// <param name="Maturity">Maturity of the Bank Bill.</param>
		// <param name="Notional">Notional amount of the Bank Bill.</param>
		// <param name="Currency">Currency of the Bank Bill.</param>
		// <param name="BankBillRate">Fixing rate of the Bank Bill.</param>
		// <param name="MarketConvention">Market conventions of the Bank Bill.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the Bank Bill.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBankBill(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object BankBillRate, object MarketConvention, object PayRec)
		{

			Hashtable CreateBankBill_args = new Hashtable();
			CreateBankBill_args.Add("ProductName", ProductName);
			CreateBankBill_args.Add("StartDate", StartDate);
			CreateBankBill_args.Add("Maturity", Maturity);
			CreateBankBill_args.Add("Notional", Notional);
			CreateBankBill_args.Add("Currency", Currency);
			CreateBankBill_args.Add("BankBillRate", BankBillRate);
			CreateBankBill_args.Add("MarketConvention", MarketConvention);
			CreateBankBill_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateBankBill", CreateBankBill_args);
		}

		// <summary>
		// Define a contract type for a futures contract with a Bank Bill Swap index underlying.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">Face value of the underlying Bank Bill at maturity for one futures contract. Default value: 1000000.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="AccrualFraction">Accrual fraction of the underlying Bank Bill for calculating the futures price.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateBankBillFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object AccrualFraction, object UniqueID)
		{

			Hashtable CreateBankBillFuturesContractType_args = new Hashtable();
			CreateBankBillFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateBankBillFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateBankBillFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateBankBillFuturesContractType_args.Add("AccrualFraction", AccrualFraction);
			CreateBankBillFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateBankBillFuturesContractType", CreateBankBillFuturesContractType_args);
		}

		// <summary>
		// Create an instrument type for a Bank Bill rate.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="Currency">Currency of the Bank Bill rates.</param>
		// <param name="MarketConventions">Market conventions for the Bank Bill.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateBankBillInstrumentType(object InstrumentTypeName, object Currency, object MarketConventions)
		{

			Hashtable CreateBankBillInstrumentType_args = new Hashtable();
			CreateBankBillInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateBankBillInstrumentType_args.Add("Currency", Currency);
			CreateBankBillInstrumentType_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateBankBillInstrumentType", CreateBankBillInstrumentType_args);
		}

		// <summary>
		// Create a market convention that generates schedules for Bank Bills.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="PaymentHolidays">Holiday conventions for payment date.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="SettlementMaturityCalculator">Calculator for fixing settlement date given trade date.</param>
		// <param name="DayCountConvention">Day count convention for accrual factor.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateBankBillMarketConvention(object MarketConventionName, object PaymentHolidays, object MaturityCalculator, object SettlementMaturityDescriptor, object SettlementMaturityCalculator, object DayCountConvention)
		{

			Hashtable CreateBankBillMarketConvention_args = new Hashtable();
			CreateBankBillMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateBankBillMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateBankBillMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateBankBillMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateBankBillMarketConvention_args.Add("SettlementMaturityCalculator", SettlementMaturityCalculator);
			CreateBankBillMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateBankBillMarketConvention", CreateBankBillMarketConvention_args);
		}

		// <summary>
		// Create a market data set containing a set of Bank Bill rates.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="BankBillRates">Vector of Bank Bill rates.</param>
		// <param name="Currency">Currency of the Bank Bill rates.</param>
		// <param name="MarketDataName">Name of market data element. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of market data element. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="MarketConventions">Market conventions for the Bank Bill.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateBankBillMarketData(object MarketDataSetName, object Maturities, object BankBillRates, object Currency, object MarketDataName, object MarketDataType, object MarketConventions)
		{

			Hashtable CreateBankBillMarketData_args = new Hashtable();
			CreateBankBillMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateBankBillMarketData_args.Add("Maturities", Maturities);
			CreateBankBillMarketData_args.Add("BankBillRates", BankBillRates);
			CreateBankBillMarketData_args.Add("Currency", Currency);
			CreateBankBillMarketData_args.Add("MarketDataName", MarketDataName);
			CreateBankBillMarketData_args.Add("MarketDataType", MarketDataType);
			CreateBankBillMarketData_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateBankBillMarketData", CreateBankBillMarketData_args);
		}

		// <summary>
		// Create a market data set containing a set of base correlations.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="TrancheBoundaries">Attachment and detachment points for the tranches.</param>
		// <param name="BaseCorrelations">The base correlations.</param>
		// <param name="BaseCorrelationsName">Name of base correlation market data.</param>
		// <param name="BaseCorrelationsType">Type of base correlation market data.</param>
		// <param name="Currency">Currency of tranche trade.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditPortfolio">Credit portfolio.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateBaseCorrelationMarketData(object MarketDataSetName, object Maturities, object TrancheBoundaries, object BaseCorrelations, object BaseCorrelationsName, object BaseCorrelationsType, object Currency, object MarketConventions, object CreditPortfolio, object QuoteDate)
		{

			Hashtable CreateBaseCorrelationMarketData_args = new Hashtable();
			CreateBaseCorrelationMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateBaseCorrelationMarketData_args.Add("Maturities", Maturities);
			CreateBaseCorrelationMarketData_args.Add("TrancheBoundaries", TrancheBoundaries);
			CreateBaseCorrelationMarketData_args.Add("BaseCorrelations", BaseCorrelations);
			CreateBaseCorrelationMarketData_args.Add("BaseCorrelationsName", BaseCorrelationsName);
			CreateBaseCorrelationMarketData_args.Add("BaseCorrelationsType", BaseCorrelationsType);
			CreateBaseCorrelationMarketData_args.Add("Currency", Currency);
			CreateBaseCorrelationMarketData_args.Add("MarketConventions", MarketConventions);
			CreateBaseCorrelationMarketData_args.Add("CreditPortfolio", CreditPortfolio);
			CreateBaseCorrelationMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateBaseCorrelationMarketData", CreateBaseCorrelationMarketData_args);
		}

		// <summary>
		// Create a Bermudan option.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="PayoffIndex">Index or expression describing the option payoff.</param>
		// <param name="ExerciseTimePoints">List of exercise time points.</param>
		// <param name="SettlementConvention">Market convention for determining payoff settlement date from option exercise.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Currency">Currency of the option payoff.</param>
		// <param name="BuySell">Flag indicating buying or selling the option.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBermudanOption(object ProductName, object PayoffIndex, object ExerciseTimePoints, object SettlementConvention, object Notional, object Currency, object BuySell)
		{

			Hashtable CreateBermudanOption_args = new Hashtable();
			CreateBermudanOption_args.Add("ProductName", ProductName);
			CreateBermudanOption_args.Add("PayoffIndex", PayoffIndex);
			CreateBermudanOption_args.Add("ExerciseTimePoints", ExerciseTimePoints);
			CreateBermudanOption_args.Add("SettlementConvention", SettlementConvention);
			CreateBermudanOption_args.Add("Notional", Notional);
			CreateBermudanOption_args.Add("Currency", Currency);
			CreateBermudanOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateBermudanOption", CreateBermudanOption_args);
		}

		// <summary>
		// Create a physically settled Bermudan interest rate swaption.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="SwapStartDate">Start date of the underlying swap.</param>
		// <param name="SwapMaturity">Maturity of the underlying swap.</param>
		// <param name="ExerciseTimePoints">List of exercise time points.</param>
		// <param name="Notional">Notional structure of the underlying swap.</param>
		// <param name="Currency">Currency of the underlying swap.</param>
		// <param name="FixedCoupon">Fixed coupon paid on each roll of the fixed leg of the underlying swap.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment of the underlying swap. Default value: 0.0.</param>
		// <param name="FixedLegMarketConvention">Market conventions for the fixed leg of the underlying swap.</param>
		// <param name="FloatingLegMarketConvention">Market conventions for the floating leg of the underlying swap. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg of the underlying swap.</param>
		// <param name="BuySell">Flag indicating buying or selling the swaption.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBermudanSwaption(object ProductName, object SwapStartDate, object SwapMaturity, object ExerciseTimePoints, object Notional, object Currency, object FixedCoupon, object FloatingRateIndex, object Margin, object FixedLegMarketConvention,
		object FloatingLegMarketConvention, object PayRec, object BuySell)
		{

			Hashtable CreateBermudanSwaption_args = new Hashtable();
			CreateBermudanSwaption_args.Add("ProductName", ProductName);
			CreateBermudanSwaption_args.Add("SwapStartDate", SwapStartDate);
			CreateBermudanSwaption_args.Add("SwapMaturity", SwapMaturity);
			CreateBermudanSwaption_args.Add("ExerciseTimePoints", ExerciseTimePoints);
			CreateBermudanSwaption_args.Add("Notional", Notional);
			CreateBermudanSwaption_args.Add("Currency", Currency);
			CreateBermudanSwaption_args.Add("FixedCoupon", FixedCoupon);
			CreateBermudanSwaption_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateBermudanSwaption_args.Add("Margin", Margin);
			CreateBermudanSwaption_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateBermudanSwaption_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateBermudanSwaption_args.Add("PayRec", PayRec);
			CreateBermudanSwaption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateBermudanSwaption", CreateBermudanSwaption_args);
		}

		// <summary>
		// Create a bill forward rate agreement.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the forward rate agreement.</param>
		// <param name="Notional">The notional amount.</param>
		// <param name="ContractRate">The forward rate agreement contract rate.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBillForwardRateAgreement(object ProductName, object StartDate, object Notional, object ContractRate, object FloatingRateIndex, object PayRec)
		{

			Hashtable CreateBillForwardRateAgreement_args = new Hashtable();
			CreateBillForwardRateAgreement_args.Add("ProductName", ProductName);
			CreateBillForwardRateAgreement_args.Add("StartDate", StartDate);
			CreateBillForwardRateAgreement_args.Add("Notional", Notional);
			CreateBillForwardRateAgreement_args.Add("ContractRate", ContractRate);
			CreateBillForwardRateAgreement_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateBillForwardRateAgreement_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateBillForwardRateAgreement", CreateBillForwardRateAgreement_args);
		}

		// <summary>
		// Form a product that represents the choice of two underlying products.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="LeftProduct">The first, or left, product.</param>
		// <param name="RightProduct">The second, or right, product.</param>
		// <param name="ChoicePoint">Timepoint when the choice has to be made.</param>
		// <param name="ChooseBest">Flag to indicate if the holder of the choice makes the exercise decision. Default value: true.</param>
		// <param name="BuySell">Buy or sell the option.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBinaryChoiceProduct(object ProductName, object LeftProduct, object RightProduct, object ChoicePoint, object ChooseBest, object BuySell)
		{

			Hashtable CreateBinaryChoiceProduct_args = new Hashtable();
			CreateBinaryChoiceProduct_args.Add("ProductName", ProductName);
			CreateBinaryChoiceProduct_args.Add("LeftProduct", LeftProduct);
			CreateBinaryChoiceProduct_args.Add("RightProduct", RightProduct);
			CreateBinaryChoiceProduct_args.Add("ChoicePoint", ChoicePoint);
			CreateBinaryChoiceProduct_args.Add("ChooseBest", ChooseBest);
			CreateBinaryChoiceProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateBinaryChoiceProduct", CreateBinaryChoiceProduct_args);
		}

		// <summary>
		// Create an index whose value is equal to that of one of two indices, depending on the truth or falsity of another.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="ConditionalIndex">Index which specifies the condition.</param>
		// <param name="IndexIfTrue">Index when the condition is true.</param>
		// <param name="IndexIfFalse">Index when the condition is false.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateBinaryConditionalIndex(object IndexName, object ConditionalIndex, object IndexIfTrue, object IndexIfFalse)
		{

			Hashtable CreateBinaryConditionalIndex_args = new Hashtable();
			CreateBinaryConditionalIndex_args.Add("IndexName", IndexName);
			CreateBinaryConditionalIndex_args.Add("ConditionalIndex", ConditionalIndex);
			CreateBinaryConditionalIndex_args.Add("IndexIfTrue", IndexIfTrue);
			CreateBinaryConditionalIndex_args.Add("IndexIfFalse", IndexIfFalse);
			return F3Formatter.f3_style_serialization("CreateBinaryConditionalIndex", CreateBinaryConditionalIndex_args);
		}

		// <summary>
		// Form a product where a choice between two underlying products is made based on an observable condition.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="LeftProduct">The first, or left, product.</param>
		// <param name="RightProduct">The second, or right, product.</param>
		// <param name="Index">Index describing the observable trigger condition.</param>
		// <param name="RefSpec">Trigger point specification.</param>
		// <param name="BuySell">Buy or sell the option.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBinaryConditionalProduct(object ProductName, object LeftProduct, object RightProduct, object Index, object RefSpec, object BuySell)
		{

			Hashtable CreateBinaryConditionalProduct_args = new Hashtable();
			CreateBinaryConditionalProduct_args.Add("ProductName", ProductName);
			CreateBinaryConditionalProduct_args.Add("LeftProduct", LeftProduct);
			CreateBinaryConditionalProduct_args.Add("RightProduct", RightProduct);
			CreateBinaryConditionalProduct_args.Add("Index", Index);
			CreateBinaryConditionalProduct_args.Add("RefSpec", RefSpec);
			CreateBinaryConditionalProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateBinaryConditionalProduct", CreateBinaryConditionalProduct_args);
		}

		// <summary>
		// Create a sequencing strategy by recursively bisecting a list of dates to define the approximating products.
		// </summary>
		// <param name="StrategyName">Name to use for the created strategy.</param>
		// <param name="MaxNumberOfDivisions">Maximum number of times binary division is performed.</param>
		// <param name="DateModifier">Prescription for adjusting the bisecting dates.</param>
		// <param name="DayRoundingStrategy">Strategy determining whether to move forward or backward to the nearest day if a bisecting point lies between two days. Default value: true.</param>
		// <param name="InterpolationMethod">Method for extrapolating the product values in the equivalent product sequence. Default value: SimpleLinearRegression.</param>
		// <returns>Retuns the name of the constructed object of type ProductSequencingStrategy.</returns>
		public object CreateBinaryDivisionSequencingStrategy(object StrategyName, object MaxNumberOfDivisions, object DateModifier, object DayRoundingStrategy, object InterpolationMethod)
		{

			Hashtable CreateBinaryDivisionSequencingStrategy_args = new Hashtable();
			CreateBinaryDivisionSequencingStrategy_args.Add("StrategyName", StrategyName);
			CreateBinaryDivisionSequencingStrategy_args.Add("MaxNumberOfDivisions", MaxNumberOfDivisions);
			CreateBinaryDivisionSequencingStrategy_args.Add("DateModifier", DateModifier);
			CreateBinaryDivisionSequencingStrategy_args.Add("DayRoundingStrategy", DayRoundingStrategy);
			CreateBinaryDivisionSequencingStrategy_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("CreateBinaryDivisionSequencingStrategy", CreateBinaryDivisionSequencingStrategy_args);
		}

		// <summary>
		// Create the characteristic function for the Black model.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="VolatilityValue">The Black volatility.</param>
		// <param name="ExpiryTime">The expiry time.</param>
		// <param name="VolatilityTag">Tag to use for the Black volatility.</param>
		// <param name="ExpiryTag">Tag to use for the expiry time.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalComplexFunction.</returns>
		public object CreateBlackCharacteristicFunction(object FunctionName, object VolatilityValue, object ExpiryTime, object VolatilityTag, object ExpiryTag)
		{

			Hashtable CreateBlackCharacteristicFunction_args = new Hashtable();
			CreateBlackCharacteristicFunction_args.Add("FunctionName", FunctionName);
			CreateBlackCharacteristicFunction_args.Add("VolatilityValue", VolatilityValue);
			CreateBlackCharacteristicFunction_args.Add("ExpiryTime", ExpiryTime);
			CreateBlackCharacteristicFunction_args.Add("VolatilityTag", VolatilityTag);
			CreateBlackCharacteristicFunction_args.Add("ExpiryTag", ExpiryTag);
			return F3Formatter.f3_style_serialization("CreateBlackCharacteristicFunction", CreateBlackCharacteristicFunction_args);
		}

		// <summary>
		// Create a state variable template that models a stochastic process according to a Black model using Euler discretization.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="UseLogCoordinate">Whether or not to use the logarithm of the forward price in the simulation. Default value: true.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateBlackEulerDiscretizationStateVariableTemplate(object StateVariableTemplateName, object UseLogCoordinate, object UseBrownianBridge)
		{

			Hashtable CreateBlackEulerDiscretizationStateVariableTemplate_args = new Hashtable();
			CreateBlackEulerDiscretizationStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateBlackEulerDiscretizationStateVariableTemplate_args.Add("UseLogCoordinate", UseLogCoordinate);
			CreateBlackEulerDiscretizationStateVariableTemplate_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateBlackEulerDiscretizationStateVariableTemplate", CreateBlackEulerDiscretizationStateVariableTemplate_args);
		}

		// <summary>
		// Create a function that computes the Black-Scholes probability as a function of strike.
		// </summary>
		// <param name="FunctionName">Name to use for the Black-Scholes probability function.</param>
		// <param name="Forward">Forward of the underlying option.</param>
		// <param name="ForwardTag">Tag to use for the forward.</param>
		// <param name="Expiry">Expiry of the underlying option.</param>
		// <param name="ExpiryTag">Tag to use for the expiry.</param>
		// <param name="Volatility">Underlying volatility specification.</param>
		// <param name="Payoff">European option payoff specification.</param>
		// <param name="DoForwardProbability">Flag indicating delta or strike exposure.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateBlackProbabilityFunction(object FunctionName, object Forward, object ForwardTag, object Expiry, object ExpiryTag, object Volatility, object Payoff, object DoForwardProbability)
		{

			Hashtable CreateBlackProbabilityFunction_args = new Hashtable();
			CreateBlackProbabilityFunction_args.Add("FunctionName", FunctionName);
			CreateBlackProbabilityFunction_args.Add("Forward", Forward);
			CreateBlackProbabilityFunction_args.Add("ForwardTag", ForwardTag);
			CreateBlackProbabilityFunction_args.Add("Expiry", Expiry);
			CreateBlackProbabilityFunction_args.Add("ExpiryTag", ExpiryTag);
			CreateBlackProbabilityFunction_args.Add("Volatility", Volatility);
			CreateBlackProbabilityFunction_args.Add("Payoff", Payoff);
			CreateBlackProbabilityFunction_args.Add("DoForwardProbability", DoForwardProbability);
			return F3Formatter.f3_style_serialization("CreateBlackProbabilityFunction", CreateBlackProbabilityFunction_args);
		}

		// <summary>
		// Create a function that computes the price strike from delta as a function of Black volatility.
		// </summary>
		// <param name="FunctionName">Name to use for the Black-Scholes probability function.</param>
		// <param name="Forward">Forward of the underlying option.</param>
		// <param name="ForwardTag">Tag to use for the forward.</param>
		// <param name="Expiry">Expiry of the underlying option.</param>
		// <param name="ExpiryTag">Tag to use for the expiry.</param>
		// <param name="DiscountFactor">Discount factor.</param>
		// <param name="DiscountFactorTag">Tag to use for the discount factor.</param>
		// <param name="Delta">Delta of the underlying option.</param>
		// <param name="DeltaTag">Tag to use for the delta.</param>
		// <param name="DeltaConvention">Convention to use for the delta-to-strike conversion.</param>
		// <param name="Payoff">European option payoff specification.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateBlackStrikeFromVolatilityFunction(object FunctionName, object Forward, object ForwardTag, object Expiry, object ExpiryTag, object DiscountFactor, object DiscountFactorTag, object Delta, object DeltaTag, object DeltaConvention,
		object Payoff)
		{

			Hashtable CreateBlackStrikeFromVolatilityFunction_args = new Hashtable();
			CreateBlackStrikeFromVolatilityFunction_args.Add("FunctionName", FunctionName);
			CreateBlackStrikeFromVolatilityFunction_args.Add("Forward", Forward);
			CreateBlackStrikeFromVolatilityFunction_args.Add("ForwardTag", ForwardTag);
			CreateBlackStrikeFromVolatilityFunction_args.Add("Expiry", Expiry);
			CreateBlackStrikeFromVolatilityFunction_args.Add("ExpiryTag", ExpiryTag);
			CreateBlackStrikeFromVolatilityFunction_args.Add("DiscountFactor", DiscountFactor);
			CreateBlackStrikeFromVolatilityFunction_args.Add("DiscountFactorTag", DiscountFactorTag);
			CreateBlackStrikeFromVolatilityFunction_args.Add("Delta", Delta);
			CreateBlackStrikeFromVolatilityFunction_args.Add("DeltaTag", DeltaTag);
			CreateBlackStrikeFromVolatilityFunction_args.Add("DeltaConvention", DeltaConvention);
			CreateBlackStrikeFromVolatilityFunction_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateBlackStrikeFromVolatilityFunction", CreateBlackStrikeFromVolatilityFunction_args);
		}

		// <summary>
		// Create a three-dimensional function that returns the equivalent Black volatility.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="VolatilitySpecification">Underlying volatility specification.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object CreateBlackVolatilityFunction(object FunctionName, object VolatilitySpecification)
		{

			Hashtable CreateBlackVolatilityFunction_args = new Hashtable();
			CreateBlackVolatilityFunction_args.Add("FunctionName", FunctionName);
			CreateBlackVolatilityFunction_args.Add("VolatilitySpecification", VolatilitySpecification);
			return F3Formatter.f3_style_serialization("CreateBlackVolatilityFunction", CreateBlackVolatilityFunction_args);
		}

		// <summary>
		// Form a valuation specification from an underlying valuation specification and data for a numeric computation.
		// </summary>
		// <param name="ValuationMethod">Name to use for created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Generator">Base generator to use for computations.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="Iterations">Number of iterations. Default value: 1023.</param>
		// <param name="SimulationPoints">Number of points to use in any discretization process, in addition to the fixing points. Default value: 0.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateBoltOnNumericValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Generator, object CalculationMethod, object Iterations, object SimulationPoints)
		{

			Hashtable CreateBoltOnNumericValuationSpecification_args = new Hashtable();
			CreateBoltOnNumericValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateBoltOnNumericValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateBoltOnNumericValuationSpecification_args.Add("Generator", Generator);
			CreateBoltOnNumericValuationSpecification_args.Add("CalculationMethod", CalculationMethod);
			CreateBoltOnNumericValuationSpecification_args.Add("Iterations", Iterations);
			CreateBoltOnNumericValuationSpecification_args.Add("SimulationPoints", SimulationPoints);
			return F3Formatter.f3_style_serialization("CreateBoltOnNumericValuationSpecification", CreateBoltOnNumericValuationSpecification_args);
		}

		// <summary>
		// Form a valuation specification from an underlying valuation specification and a set of named indices.
		// </summary>
		// <param name="ValuationMethod">Name to use for created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="NamedIndices">Named indices.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateBoltOnResolvingValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object NamedIndices)
		{

			Hashtable CreateBoltOnResolvingValuationSpecification_args = new Hashtable();
			CreateBoltOnResolvingValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateBoltOnResolvingValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateBoltOnResolvingValuationSpecification_args.Add("NamedIndices", NamedIndices);
			return F3Formatter.f3_style_serialization("CreateBoltOnResolvingValuationSpecification", CreateBoltOnResolvingValuationSpecification_args);
		}

		// <summary>
		// Form a valuation specification that specifies a single valuation currency.
		// </summary>
		// <param name="ValuationMethod">Name to use for created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Currency to use as numeraire, or valuation, currency.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateBoltOnSingleCurrencyValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency)
		{

			Hashtable CreateBoltOnSingleCurrencyValuationSpecification_args = new Hashtable();
			CreateBoltOnSingleCurrencyValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateBoltOnSingleCurrencyValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateBoltOnSingleCurrencyValuationSpecification_args.Add("Currency", Currency);
			return F3Formatter.f3_style_serialization("CreateBoltOnSingleCurrencyValuationSpecification", CreateBoltOnSingleCurrencyValuationSpecification_args);
		}

		// <summary>
		// Form a valuation specification from an underlying valuation specification and a set of named state variable templates.
		// </summary>
		// <param name="ValuationMethod">Name to use for created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="NamedStateVariableTemplates">Named state variable templates.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateBoltOnStateVariableValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object NamedStateVariableTemplates)
		{

			Hashtable CreateBoltOnStateVariableValuationSpecification_args = new Hashtable();
			CreateBoltOnStateVariableValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateBoltOnStateVariableValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateBoltOnStateVariableValuationSpecification_args.Add("NamedStateVariableTemplates", NamedStateVariableTemplates);
			return F3Formatter.f3_style_serialization("CreateBoltOnStateVariableValuationSpecification", CreateBoltOnStateVariableValuationSpecification_args);
		}

		// <summary>
		// Create a bond object from any input that explicitly or implicitly defines one.
		// </summary>
		// <param name="BondName">Name to use for the created bond.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <returns>Retuns the name of the constructed object of type Bond.</returns>
		public object CreateBond(object BondName, object Bond)
		{

			Hashtable CreateBond_args = new Hashtable();
			CreateBond_args.Add("BondName", BondName);
			CreateBond_args.Add("Bond", Bond);
			return F3Formatter.f3_style_serialization("CreateBond", CreateBond_args);
		}

		// <summary>
		// Create an index for the clean price of a bond.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="Bond">Bond to create index for.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateBondCleanPriceIndex(object IndexName, object Bond)
		{

			Hashtable CreateBondCleanPriceIndex_args = new Hashtable();
			CreateBondCleanPriceIndex_args.Add("IndexName", IndexName);
			CreateBondCleanPriceIndex_args.Add("Bond", Bond);
			return F3Formatter.f3_style_serialization("CreateBondCleanPriceIndex", CreateBondCleanPriceIndex_args);
		}

		// <summary>
		// Create a product with all of the coupon payments in a bond.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="Bond">The bond product from which the coupon leg product will be extracted.</param>
		// <param name="SettlementDetails">Bond settlement details that are used to select the relevant flows.</param>
		// <param name="Notional">The notional amount of the bond.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the coupons.</param>
		// <param name="ScalingIndex">Index scaling the cash flow payments. Default value: UnitConstant.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondCouponEquivalentLeg(object ProductName, object Bond, object SettlementDetails, object Notional, object PayRec, object ScalingIndex)
		{

			Hashtable CreateBondCouponEquivalentLeg_args = new Hashtable();
			CreateBondCouponEquivalentLeg_args.Add("ProductName", ProductName);
			CreateBondCouponEquivalentLeg_args.Add("Bond", Bond);
			CreateBondCouponEquivalentLeg_args.Add("SettlementDetails", SettlementDetails);
			CreateBondCouponEquivalentLeg_args.Add("Notional", Notional);
			CreateBondCouponEquivalentLeg_args.Add("PayRec", PayRec);
			CreateBondCouponEquivalentLeg_args.Add("ScalingIndex", ScalingIndex);
			return F3Formatter.f3_style_serialization("CreateBondCouponEquivalentLeg", CreateBondCouponEquivalentLeg_args);
		}

		// <summary>
		// Create an index for the dirty price of a bond.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="Bond">Bond to create index for.</param>
		// <param name="OptionalCurveReferenceName">Optional name for the curve associated with the index.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateBondDirtyPriceIndex(object IndexName, object Bond, object OptionalCurveReferenceName)
		{

			Hashtable CreateBondDirtyPriceIndex_args = new Hashtable();
			CreateBondDirtyPriceIndex_args.Add("IndexName", IndexName);
			CreateBondDirtyPriceIndex_args.Add("Bond", Bond);
			CreateBondDirtyPriceIndex_args.Add("OptionalCurveReferenceName", OptionalCurveReferenceName);
			return F3Formatter.f3_style_serialization("CreateBondDirtyPriceIndex", CreateBondDirtyPriceIndex_args);
		}

		// <summary>
		// Create a product with all of the cash flows in a bond.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="Bond">The bond product from which the leg product will be extracted.</param>
		// <param name="SettlementDetails">Bond settlement details that are used to select the relevant flows.</param>
		// <param name="Notional">The notional amount of the bond.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the coupons.</param>
		// <param name="ScalingIndex">Index scaling the cash flow payments. Default value: UnitConstant.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondEquivalentLeg(object ProductName, object Bond, object SettlementDetails, object Notional, object PayRec, object ScalingIndex)
		{

			Hashtable CreateBondEquivalentLeg_args = new Hashtable();
			CreateBondEquivalentLeg_args.Add("ProductName", ProductName);
			CreateBondEquivalentLeg_args.Add("Bond", Bond);
			CreateBondEquivalentLeg_args.Add("SettlementDetails", SettlementDetails);
			CreateBondEquivalentLeg_args.Add("Notional", Notional);
			CreateBondEquivalentLeg_args.Add("PayRec", PayRec);
			CreateBondEquivalentLeg_args.Add("ScalingIndex", ScalingIndex);
			return F3Formatter.f3_style_serialization("CreateBondEquivalentLeg", CreateBondEquivalentLeg_args);
		}

		// <summary>
		// Create a market data set containing bond price or yield fixings.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="DateValueName">Name of fixing market data.</param>
		// <param name="DateValueType">Type of fixing market data.</param>
		// <param name="BondFixings">Bond fixing data to store within market data set.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateBondFixingsMarketData(object MarketDataSetName, object DateValueName, object DateValueType, object BondFixings)
		{

			Hashtable CreateBondFixingsMarketData_args = new Hashtable();
			CreateBondFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateBondFixingsMarketData_args.Add("DateValueName", DateValueName);
			CreateBondFixingsMarketData_args.Add("DateValueType", DateValueType);
			CreateBondFixingsMarketData_args.Add("BondFixings", BondFixings);
			return F3Formatter.f3_style_serialization("CreateBondFixingsMarketData", CreateBondFixingsMarketData_args);
		}

		// <summary>
		// Define a futures contract type for a futures contract whose underlying is a bond.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">The face value of the underlying bond at maturity in one futures contract.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateBondFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateBondFuturesContractType_args = new Hashtable();
			CreateBondFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateBondFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateBondFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateBondFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateBondFuturesContractType", CreateBondFuturesContractType_args);
		}

		// <summary>
		// Create a product with the notional payments in a bond.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="Bond">The bond product from which the notional repayment product will be extracted.</param>
		// <param name="SettlementDetails">Bond settlement details that are used to select the relevant flows.</param>
		// <param name="Notional">The notional amount of the bond.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the coupons.</param>
		// <param name="ScalingIndex">Index scaling the cash flow payments. Default value: UnitConstant.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondNotionalEquivalentProduct(object ProductName, object Bond, object SettlementDetails, object Notional, object PayRec, object ScalingIndex)
		{

			Hashtable CreateBondNotionalEquivalentProduct_args = new Hashtable();
			CreateBondNotionalEquivalentProduct_args.Add("ProductName", ProductName);
			CreateBondNotionalEquivalentProduct_args.Add("Bond", Bond);
			CreateBondNotionalEquivalentProduct_args.Add("SettlementDetails", SettlementDetails);
			CreateBondNotionalEquivalentProduct_args.Add("Notional", Notional);
			CreateBondNotionalEquivalentProduct_args.Add("PayRec", PayRec);
			CreateBondNotionalEquivalentProduct_args.Add("ScalingIndex", ScalingIndex);
			return F3Formatter.f3_style_serialization("CreateBondNotionalEquivalentProduct", CreateBondNotionalEquivalentProduct_args);
		}

		// <summary>
		// Create a market data set containing a quote for the price of a particular bond.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="Quote">Bond price or yield quote according to some convention.</param>
		// <param name="MarketDataName">Name of bond market data.</param>
		// <param name="MarketDataType">Type of bond market data.</param>
		// <param name="QuoteDate">The day on which the quote is provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateBondPriceMarketData(object MarketDataSetName, object Bond, object Quote, object MarketDataName, object MarketDataType, object QuoteDate)
		{

			Hashtable CreateBondPriceMarketData_args = new Hashtable();
			CreateBondPriceMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateBondPriceMarketData_args.Add("Bond", Bond);
			CreateBondPriceMarketData_args.Add("Quote", Quote);
			CreateBondPriceMarketData_args.Add("MarketDataName", MarketDataName);
			CreateBondPriceMarketData_args.Add("MarketDataType", MarketDataType);
			CreateBondPriceMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateBondPriceMarketData", CreateBondPriceMarketData_args);
		}

		// <summary>
		// Create a modifier which returns the bond prices and discount factors in the Affine Yield model in the forward measure.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateBondPricesInAffineYieldModelModifier(object ModifierName, object TimePoints, object ForwardMeasureIndex, object DiscountFunction)
		{

			Hashtable CreateBondPricesInAffineYieldModelModifier_args = new Hashtable();
			CreateBondPricesInAffineYieldModelModifier_args.Add("ModifierName", ModifierName);
			CreateBondPricesInAffineYieldModelModifier_args.Add("TimePoints", TimePoints);
			CreateBondPricesInAffineYieldModelModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateBondPricesInAffineYieldModelModifier_args.Add("DiscountFunction", DiscountFunction);
			return F3Formatter.f3_style_serialization("CreateBondPricesInAffineYieldModelModifier", CreateBondPricesInAffineYieldModelModifier_args);
		}

		// <summary>
		// Create a bond trade.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="SettlementDetails">Settlement details.</param>
		// <param name="Price">Bond price or yield according to some convention.</param>
		// <param name="Principal">The principal amount of the bond.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the bond.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondProduct(object ProductName, object Bond, object SettlementDetails, object Price, object Principal, object PayRec)
		{

			Hashtable CreateBondProduct_args = new Hashtable();
			CreateBondProduct_args.Add("ProductName", ProductName);
			CreateBondProduct_args.Add("Bond", Bond);
			CreateBondProduct_args.Add("SettlementDetails", SettlementDetails);
			CreateBondProduct_args.Add("Price", Price);
			CreateBondProduct_args.Add("Principal", Principal);
			CreateBondProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateBondProduct", CreateBondProduct_args);
		}

		// <summary>
		// Create a market data set containing quotes for the repurchase agreements of a particular bond.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="Maturities">Vector of maturity descriptors.</param>
		// <param name="RepoRates">Repurchase rates of the quoted agreements.</param>
		// <param name="Haircuts">Haircuts applied to the purchase prices.</param>
		// <param name="MarketDataName">Name of bond market data.</param>
		// <param name="MarketDataType">Type of bond market data.</param>
		// <param name="DayCountConvention">Day count convention used to calculate the repo accrual period. Default value: act/360.</param>
		// <param name="QuoteDate">The day on which the quote is provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateBondRepoMarketData(object MarketDataSetName, object Bond, object Maturities, object RepoRates, object Haircuts, object MarketDataName, object MarketDataType, object DayCountConvention, object QuoteDate)
		{

			Hashtable CreateBondRepoMarketData_args = new Hashtable();
			CreateBondRepoMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateBondRepoMarketData_args.Add("Bond", Bond);
			CreateBondRepoMarketData_args.Add("Maturities", Maturities);
			CreateBondRepoMarketData_args.Add("RepoRates", RepoRates);
			CreateBondRepoMarketData_args.Add("Haircuts", Haircuts);
			CreateBondRepoMarketData_args.Add("MarketDataName", MarketDataName);
			CreateBondRepoMarketData_args.Add("MarketDataType", MarketDataType);
			CreateBondRepoMarketData_args.Add("DayCountConvention", DayCountConvention);
			CreateBondRepoMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateBondRepoMarketData", CreateBondRepoMarketData_args);
		}

		// <summary>
		// Create a bond repurchase agreement.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="StartSettlementDetails">Settlement details for the start of the agreement.</param>
		// <param name="EndSettlementDetails">Settlement details for the end of the agreement.</param>
		// <param name="Price">Bond price or yield according to some convention.</param>
		// <param name="RepoRate">Repurchase rate of the agreement.</param>
		// <param name="Haircut">Haircut applied to the purchase price.</param>
		// <param name="Notional">The notional amount of the bond.</param>
		// <param name="PayRec">Flag indicating lending or borrowing of the bond.</param>
		// <param name="DayCountConvention">Day count convention used to calculate the repo accrual period. Default value: act/360.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondRepoProduct(object ProductName, object Bond, object StartSettlementDetails, object EndSettlementDetails, object Price, object RepoRate, object Haircut, object Notional, object PayRec, object DayCountConvention)
		{

			Hashtable CreateBondRepoProduct_args = new Hashtable();
			CreateBondRepoProduct_args.Add("ProductName", ProductName);
			CreateBondRepoProduct_args.Add("Bond", Bond);
			CreateBondRepoProduct_args.Add("StartSettlementDetails", StartSettlementDetails);
			CreateBondRepoProduct_args.Add("EndSettlementDetails", EndSettlementDetails);
			CreateBondRepoProduct_args.Add("Price", Price);
			CreateBondRepoProduct_args.Add("RepoRate", RepoRate);
			CreateBondRepoProduct_args.Add("Haircut", Haircut);
			CreateBondRepoProduct_args.Add("Notional", Notional);
			CreateBondRepoProduct_args.Add("PayRec", PayRec);
			CreateBondRepoProduct_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateBondRepoProduct", CreateBondRepoProduct_args);
		}

		// <summary>
		// Create a Bond Trade.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Bond">Bond or other fixed income security.</param>
		// <param name="SettlementDetails">Settlement details.</param>
		// <param name="Price">Bond price or yield according to some convention.</param>
		// <param name="Principal">The principal amount of the bond.</param>
		// <param name="BuySell">Flag indicating buying or selling of the bond.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateBondTrade(object ProductName, object Bond, object SettlementDetails, object Price, object Principal, object BuySell)
		{

			Hashtable CreateBondTrade_args = new Hashtable();
			CreateBondTrade_args.Add("ProductName", ProductName);
			CreateBondTrade_args.Add("Bond", Bond);
			CreateBondTrade_args.Add("SettlementDetails", SettlementDetails);
			CreateBondTrade_args.Add("Price", Price);
			CreateBondTrade_args.Add("Principal", Principal);
			CreateBondTrade_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateBondTrade", CreateBondTrade_args);
		}

		// <summary>
		// Create an index for the yield of a bond.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="Bond">Bond to create index for.</param>
		// <param name="YieldConvention">Yield convention.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateBondYieldIndex(object IndexName, object Bond, object YieldConvention)
		{

			Hashtable CreateBondYieldIndex_args = new Hashtable();
			CreateBondYieldIndex_args.Add("IndexName", IndexName);
			CreateBondYieldIndex_args.Add("Bond", Bond);
			CreateBondYieldIndex_args.Add("YieldConvention", YieldConvention);
			return F3Formatter.f3_style_serialization("CreateBondYieldIndex", CreateBondYieldIndex_args);
		}

		// <summary>
		// Creates a new book bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the book bibliography entry.</param>
		// <param name="Author">Author to use for the book bibliography entry.</param>
		// <param name="Year">Year to use for the book bibliography entry.</param>
		// <param name="Title">Title to use for the book bibliography entry.</param>
		// <param name="Publisher">Publisher to use for the book bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateBookBibliographyEntry(object Name, object Author, object Year, object Title, object Publisher)
		{

			Hashtable CreateBookBibliographyEntry_args = new Hashtable();
			CreateBookBibliographyEntry_args.Add("Name", Name);
			CreateBookBibliographyEntry_args.Add("Author", Author);
			CreateBookBibliographyEntry_args.Add("Year", Year);
			CreateBookBibliographyEntry_args.Add("Title", Title);
			CreateBookBibliographyEntry_args.Add("Publisher", Publisher);
			return F3Formatter.f3_style_serialization("CreateBookBibliographyEntry", CreateBookBibliographyEntry_args);
		}

		// <summary>
		// Create an index bound to a specific reference point.
		// </summary>
		// <param name="IndexName">Name to use for the bound index.</param>
		// <param name="UnderlyingIndex">Underlying index to bind to the reference point.</param>
		// <param name="ReferencePoint">Reference point.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateBoundIndex(object IndexName, object UnderlyingIndex, object ReferencePoint)
		{

			Hashtable CreateBoundIndex_args = new Hashtable();
			CreateBoundIndex_args.Add("IndexName", IndexName);
			CreateBoundIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateBoundIndex_args.Add("ReferencePoint", ReferencePoint);
			return F3Formatter.f3_style_serialization("CreateBoundIndex", CreateBoundIndex_args);
		}

		// <summary>
		// Create a modifier which generates increments of a Brownian bridge, with unit variance.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="OrderingIndices">Vector of indices to specify the order of construction. Default value: default-constructed instance of type brownian_bridge_index_vector.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateBrownianBridgeIncrementsWithUnitVarianceModifier(object ModifierName, object OrderingIndices)
		{

			Hashtable CreateBrownianBridgeIncrementsWithUnitVarianceModifier_args = new Hashtable();
			CreateBrownianBridgeIncrementsWithUnitVarianceModifier_args.Add("ModifierName", ModifierName);
			CreateBrownianBridgeIncrementsWithUnitVarianceModifier_args.Add("OrderingIndices", OrderingIndices);
			return F3Formatter.f3_style_serialization("CreateBrownianBridgeIncrementsWithUnitVarianceModifier", CreateBrownianBridgeIncrementsWithUnitVarianceModifier_args);
		}

		// <summary>
		// Create a Brownian bridge modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="OrderingIndices">Vector of indices to specify the order of construction. Default value: default-constructed instance of type brownian_bridge_index_vector.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateBrownianBridgeModifier(object ModifierName, object TimePoints, object OrderingIndices)
		{

			Hashtable CreateBrownianBridgeModifier_args = new Hashtable();
			CreateBrownianBridgeModifier_args.Add("ModifierName", ModifierName);
			CreateBrownianBridgeModifier_args.Add("TimePoints", TimePoints);
			CreateBrownianBridgeModifier_args.Add("OrderingIndices", OrderingIndices);
			return F3Formatter.f3_style_serialization("CreateBrownianBridgeModifier", CreateBrownianBridgeModifier_args);
		}

		// <summary>
		// Create a business day count convention.
		// </summary>
		// <param name="DayCountName">Name to use for the day counting type.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		// <param name="Denominator">The denominator to use when calculating business day fraction.</param>
		// <returns>Retuns the name of the constructed object of type DayCountConvention.</returns>
		public object CreateBusinessDaycountConvention(object DayCountName, object HolidayConventions, object Denominator)
		{

			Hashtable CreateBusinessDaycountConvention_args = new Hashtable();
			CreateBusinessDaycountConvention_args.Add("DayCountName", DayCountName);
			CreateBusinessDaycountConvention_args.Add("HolidayConventions", HolidayConventions);
			CreateBusinessDaycountConvention_args.Add("Denominator", Denominator);
			return F3Formatter.f3_style_serialization("CreateBusinessDaycountConvention", CreateBusinessDaycountConvention_args);
		}

		// <summary>
		// Create a market convention that generates schedules that roll on every business day.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="DayCountConvention">Day count convention for calculation of accrual factors.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateBusinessDaysMarketConvention(object MarketConventionName, object UnderlyingConventions, object DayCountConvention)
		{

			Hashtable CreateBusinessDaysMarketConvention_args = new Hashtable();
			CreateBusinessDaysMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateBusinessDaysMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateBusinessDaysMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateBusinessDaysMarketConvention", CreateBusinessDaysMarketConvention_args);
		}

		// <summary>
		// Create a market data set containing a set of quotes for the butterfly option strategies at different maturities and delta strikes.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of option expiries.</param>
		// <param name="Deltas">Vector of option delta strikes.</param>
		// <param name="StrategyQuotes">Vector of option strategy quotes.</param>
		// <param name="DataName">Name of market data.</param>
		// <param name="DataType">Type of market data.</param>
		// <param name="UnderlyingIndex">Index describing the option's underlying.</param>
		// <param name="DeltaConvention">Market convention for the delta-based option strike. Default value: ForwardRawDelta.</param>
		// <param name="StrangleType">Type of the strangle that composes the butterfly option strategy. Default value: Smile.</param>
		// <param name="QuoteDate">Date on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateButterflyMarketData(object MarketDataSetName, object Expiries, object Deltas, object StrategyQuotes, object DataName, object DataType, object UnderlyingIndex, object DeltaConvention, object StrangleType, object QuoteDate)
		{

			Hashtable CreateButterflyMarketData_args = new Hashtable();
			CreateButterflyMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateButterflyMarketData_args.Add("Expiries", Expiries);
			CreateButterflyMarketData_args.Add("Deltas", Deltas);
			CreateButterflyMarketData_args.Add("StrategyQuotes", StrategyQuotes);
			CreateButterflyMarketData_args.Add("DataName", DataName);
			CreateButterflyMarketData_args.Add("DataType", DataType);
			CreateButterflyMarketData_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateButterflyMarketData_args.Add("DeltaConvention", DeltaConvention);
			CreateButterflyMarketData_args.Add("StrangleType", StrangleType);
			CreateButterflyMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateButterflyMarketData", CreateButterflyMarketData_args);
		}

		// <summary>
		// Create a market convention to form CDS roll schedule.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="TradeDateHolidays">Holiday convention that defines trade dates.</param>
		// <param name="PaymentHolidays">Holiday convention for payment dates.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="SettlementMaturityCalculator">Calculator for fixing settlement date given trade date.</param>
		// <param name="RollLength">Length of roll period in months.</param>
		// <param name="DayCountConvention">Day count convention.</param>
		// <param name="RollDayModifier">Date modifier applied to all roll end dates, excluding the final roll..</param>
		// <param name="UseExtraDaysAccrualForLastRoll">Flag indicating whether the last roll has an extra day's accrual in it.</param>
		// <param name="StubType">Stub type. Default value: StubAtStart.</param>
		// <param name="MoveEndDateForwardByOneDay">Flag indicating whether the end date of the trade is moved forward by one day. Default value: false.</param>
		// <param name="ModifyStart">True if start date should be also be adjusted using the RollDayModifier modifier. Default value: false.</param>
		// <param name="EndDateModifier">Date modifier for the end date of the final roll. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateCDSMarketConvention(object MarketConventionName, object TradeDateHolidays, object PaymentHolidays, object MaturityCalculator, object SettlementMaturityDescriptor, object SettlementMaturityCalculator, object RollLength, object DayCountConvention, object RollDayModifier, object UseExtraDaysAccrualForLastRoll,
		object StubType, object MoveEndDateForwardByOneDay, object ModifyStart, object EndDateModifier)
		{

			Hashtable CreateCDSMarketConvention_args = new Hashtable();
			CreateCDSMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateCDSMarketConvention_args.Add("TradeDateHolidays", TradeDateHolidays);
			CreateCDSMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateCDSMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateCDSMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateCDSMarketConvention_args.Add("SettlementMaturityCalculator", SettlementMaturityCalculator);
			CreateCDSMarketConvention_args.Add("RollLength", RollLength);
			CreateCDSMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			CreateCDSMarketConvention_args.Add("RollDayModifier", RollDayModifier);
			CreateCDSMarketConvention_args.Add("UseExtraDaysAccrualForLastRoll", UseExtraDaysAccrualForLastRoll);
			CreateCDSMarketConvention_args.Add("StubType", StubType);
			CreateCDSMarketConvention_args.Add("MoveEndDateForwardByOneDay", MoveEndDateForwardByOneDay);
			CreateCDSMarketConvention_args.Add("ModifyStart", ModifyStart);
			CreateCDSMarketConvention_args.Add("EndDateModifier", EndDateModifier);
			return F3Formatter.f3_style_serialization("CreateCDSMarketConvention", CreateCDSMarketConvention_args);
		}

		// <summary>
		// Create a CEV modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Volatility function.</param>
		// <param name="ExponentFunction">CEV exponent function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateCEVModifier(object ModifierName, object TimePoints, object ForwardFunction, object VolatilityFunction, object ExponentFunction)
		{

			Hashtable CreateCEVModifier_args = new Hashtable();
			CreateCEVModifier_args.Add("ModifierName", ModifierName);
			CreateCEVModifier_args.Add("TimePoints", TimePoints);
			CreateCEVModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateCEVModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateCEVModifier_args.Add("ExponentFunction", ExponentFunction);
			return F3Formatter.f3_style_serialization("CreateCEVModifier", CreateCEVModifier_args);
		}

		// <summary>
		// Create a product whose value is equal to the credit value adjustment for the underlying product or portfolio of products.
		// </summary>
		// <param name="ProductName">Name to use for product.</param>
		// <param name="UnderlyingProduct">Product for which counterparty risk is being calculated.</param>
		// <param name="StartDate">Start date for which counterparty default is being considered.</param>
		// <param name="CreditIndex">Loss given default index for the counterparty.</param>
		// <param name="SamplingStrategy">Strategy for generation of sampling dates.</param>
		// <param name="CollateralizationRules">Rules governing the posting of collateral by the counterparty. Default value: default-constructed instance of type collateral_agreement.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCVAProduct(object ProductName, object UnderlyingProduct, object StartDate, object CreditIndex, object SamplingStrategy, object CollateralizationRules)
		{

			Hashtable CreateCVAProduct_args = new Hashtable();
			CreateCVAProduct_args.Add("ProductName", ProductName);
			CreateCVAProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateCVAProduct_args.Add("StartDate", StartDate);
			CreateCVAProduct_args.Add("CreditIndex", CreditIndex);
			CreateCVAProduct_args.Add("SamplingStrategy", SamplingStrategy);
			CreateCVAProduct_args.Add("CollateralizationRules", CollateralizationRules);
			return F3Formatter.f3_style_serialization("CreateCVAProduct", CreateCVAProduct_args);
		}

		// <summary>
		// Create products from the instruments used in a calibration strategy.
		// </summary>
		// <param name="BaseName">Base name to use for the constructed products.</param>
		// <param name="Model">Underlying model.</param>
		// <param name="InstrumentStrategy">Instrument strategy whose instruments will be used.</param>
		// <param name="Notional">Notional amount of the product. Default value: 1000000.</param>
		// <param name="PayRec">Pay/Receive or Buy/Sell specification. Default value: pay.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCalibrationProducts(object BaseName, object Model, object InstrumentStrategy, object Notional, object PayRec)
		{

			Hashtable CreateCalibrationProducts_args = new Hashtable();
			CreateCalibrationProducts_args.Add("BaseName", BaseName);
			CreateCalibrationProducts_args.Add("Model", Model);
			CreateCalibrationProducts_args.Add("InstrumentStrategy", InstrumentStrategy);
			CreateCalibrationProducts_args.Add("Notional", Notional);
			CreateCalibrationProducts_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateCalibrationProducts", CreateCalibrationProducts_args);
		}

		// <summary>
		// Create a callback function.
		// </summary>
		// <param name="CallbackName">Name to use for callback.</param>
		// <param name="Functions">Callback function.</param>
		// <returns>Retuns the name of the constructed object of type Callback.</returns>
		public object CreateCallback(object CallbackName, object Functions)
		{

			Hashtable CreateCallback_args = new Hashtable();
			CreateCallback_args.Add("CallbackName", CallbackName);
			CreateCallback_args.Add("Functions", Functions);
			return F3Formatter.f3_style_serialization("CreateCallback", CreateCallback_args);
		}

		// <summary>
		// Create a cancellable Interest Rate Swap.
		// </summary>
		// <param name="ProductName">Name to use for the product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="CancellationStartDate">Start date of the swap cancellation schedule. Default value: default-constructed instance of type date.</param>
		// <param name="CancellationEnd">End of the swap cancellation schedule. Default value: default-constructed instance of type maturity_descriptor.</param>
		// <param name="Notional">The notional structure of the fixed leg.</param>
		// <param name="Currency">Currency of the fixed amount.</param>
		// <param name="FixedCoupon">The fixed coupon paid on each roll of the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="FixedLegMC">Fixed leg market conventions.</param>
		// <param name="FloatingLegMC">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="CancellationMC">Market conventions for the swap cancellation schedule. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="CancellationPayoff">Index describing the cancellation fee/penalty payment. Default value: ZeroConstant.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <param name="ChooseBest">Flag to indicate if the holder of the swap makes the cancellation decision. Default value: True.</param>
		// <param name="BuySell">Flag indicating if the option to cancel the swap is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCancellableInterestRateSwap(object ProductName, object StartDate, object Maturity, object CancellationStartDate, object CancellationEnd, object Notional, object Currency, object FixedCoupon, object FloatingRateIndex, object Margin,
		object FixedLegMC, object FloatingLegMC, object CancellationMC, object CancellationPayoff, object PayRec, object ChooseBest, object BuySell)
		{

			Hashtable CreateCancellableInterestRateSwap_args = new Hashtable();
			CreateCancellableInterestRateSwap_args.Add("ProductName", ProductName);
			CreateCancellableInterestRateSwap_args.Add("StartDate", StartDate);
			CreateCancellableInterestRateSwap_args.Add("Maturity", Maturity);
			CreateCancellableInterestRateSwap_args.Add("CancellationStartDate", CancellationStartDate);
			CreateCancellableInterestRateSwap_args.Add("CancellationEnd", CancellationEnd);
			CreateCancellableInterestRateSwap_args.Add("Notional", Notional);
			CreateCancellableInterestRateSwap_args.Add("Currency", Currency);
			CreateCancellableInterestRateSwap_args.Add("FixedCoupon", FixedCoupon);
			CreateCancellableInterestRateSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateCancellableInterestRateSwap_args.Add("Margin", Margin);
			CreateCancellableInterestRateSwap_args.Add("FixedLegMC", FixedLegMC);
			CreateCancellableInterestRateSwap_args.Add("FloatingLegMC", FloatingLegMC);
			CreateCancellableInterestRateSwap_args.Add("CancellationMC", CancellationMC);
			CreateCancellableInterestRateSwap_args.Add("CancellationPayoff", CancellationPayoff);
			CreateCancellableInterestRateSwap_args.Add("PayRec", PayRec);
			CreateCancellableInterestRateSwap_args.Add("ChooseBest", ChooseBest);
			CreateCancellableInterestRateSwap_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateCancellableInterestRateSwap", CreateCancellableInterestRateSwap_args);
		}

		// <summary>
		// Create a cancellable product.
		// </summary>
		// <param name="ProductName">Name to use for the product.</param>
		// <param name="UnderlyingProduct">Underlying product.</param>
		// <param name="CancellationStartDate">Start date of the product cancellation schedule.</param>
		// <param name="CancellationEnd">End of the product cancellation schedule.</param>
		// <param name="CancellationMarketConvention">Market conventions for generating the product cancellation schedule.</param>
		// <param name="CancellationPayoff">Index or expression describing the cancellation fee/penalty amount. Default value: ZeroConstant.</param>
		// <param name="ChooseBest">Flag to indicate if the product holder makes the cancellation decision. Default value: True.</param>
		// <param name="BuySell">Flag indicating if the option to cancel the product is bought or sold by the product holder.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCancellableProduct(object ProductName, object UnderlyingProduct, object CancellationStartDate, object CancellationEnd, object CancellationMarketConvention, object CancellationPayoff, object ChooseBest, object BuySell)
		{

			Hashtable CreateCancellableProduct_args = new Hashtable();
			CreateCancellableProduct_args.Add("ProductName", ProductName);
			CreateCancellableProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateCancellableProduct_args.Add("CancellationStartDate", CancellationStartDate);
			CreateCancellableProduct_args.Add("CancellationEnd", CancellationEnd);
			CreateCancellableProduct_args.Add("CancellationMarketConvention", CancellationMarketConvention);
			CreateCancellableProduct_args.Add("CancellationPayoff", CancellationPayoff);
			CreateCancellableProduct_args.Add("ChooseBest", ChooseBest);
			CreateCancellableProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateCancellableProduct", CreateCancellableProduct_args);
		}

		// <summary>
		// Create a product that pays a single flow of one underlying index multiplied by another.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="ObservationTime">Observation time point for the underlying indices.</param>
		// <param name="FirstIndex">The first index of the two correlated processes.</param>
		// <param name="SecondIndex">The second index of the two correlated processes.</param>
		// <param name="Notional">The notional amount of the cash flow.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="CorrelationType">The terminal correlation type between the two indices.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flow.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCanonicalCorrelationProduct(object ProductName, object ObservationTime, object FirstIndex, object SecondIndex, object Notional, object Currency, object CorrelationType, object PayRec)
		{

			Hashtable CreateCanonicalCorrelationProduct_args = new Hashtable();
			CreateCanonicalCorrelationProduct_args.Add("ProductName", ProductName);
			CreateCanonicalCorrelationProduct_args.Add("ObservationTime", ObservationTime);
			CreateCanonicalCorrelationProduct_args.Add("FirstIndex", FirstIndex);
			CreateCanonicalCorrelationProduct_args.Add("SecondIndex", SecondIndex);
			CreateCanonicalCorrelationProduct_args.Add("Notional", Notional);
			CreateCanonicalCorrelationProduct_args.Add("Currency", Currency);
			CreateCanonicalCorrelationProduct_args.Add("CorrelationType", CorrelationType);
			CreateCanonicalCorrelationProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateCanonicalCorrelationProduct", CreateCanonicalCorrelationProduct_args);
		}

		// <summary>
		// Create an instrument type for a cap or a floor.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="CapFloorMarketConventions">Market conventions for the cap or floor.</param>
		// <param name="Payoff">Payoff for the option. Default value: straddle.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateCapFloorInstrumentType(object InstrumentTypeName, object FloatingIndex, object CapFloorMarketConventions, object Payoff)
		{

			Hashtable CreateCapFloorInstrumentType_args = new Hashtable();
			CreateCapFloorInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateCapFloorInstrumentType_args.Add("FloatingIndex", FloatingIndex);
			CreateCapFloorInstrumentType_args.Add("CapFloorMarketConventions", CapFloorMarketConventions);
			CreateCapFloorInstrumentType_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateCapFloorInstrumentType", CreateCapFloorInstrumentType_args);
		}

		// <summary>
		// Create an index representing a capped CDS rate.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of the credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="PayAccrued">Pay accrued interest upon default.</param>
		// <param name="Cap">The upper limit of the rate.</param>
		// <param name="PayOnlyIfSurvive">Flag Indicating whether the payment is conditional on survival of the reference entity.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <param name="Instrument">CDS market data instrument.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCappedDefaultSwapRateIndex(object IndexName, object CreditContract, object Currency, object PayAccrued, object Cap, object PayOnlyIfSurvive, object FixingReferencer, object Instrument)
		{

			Hashtable CreateCappedDefaultSwapRateIndex_args = new Hashtable();
			CreateCappedDefaultSwapRateIndex_args.Add("IndexName", IndexName);
			CreateCappedDefaultSwapRateIndex_args.Add("CreditContract", CreditContract);
			CreateCappedDefaultSwapRateIndex_args.Add("Currency", Currency);
			CreateCappedDefaultSwapRateIndex_args.Add("PayAccrued", PayAccrued);
			CreateCappedDefaultSwapRateIndex_args.Add("Cap", Cap);
			CreateCappedDefaultSwapRateIndex_args.Add("PayOnlyIfSurvive", PayOnlyIfSurvive);
			CreateCappedDefaultSwapRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateCappedDefaultSwapRateIndex_args.Add("Instrument", Instrument);
			return F3Formatter.f3_style_serialization("CreateCappedDefaultSwapRateIndex", CreateCappedDefaultSwapRateIndex_args);
		}

		// <summary>
		// Create an instrument type for a cash deposit rate.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="Currency">Currency of deposits.</param>
		// <param name="MarketConventions">Market conventions for deposit dates.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateCashDepoInstrumentType(object InstrumentTypeName, object Currency, object MarketConventions)
		{

			Hashtable CreateCashDepoInstrumentType_args = new Hashtable();
			CreateCashDepoInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateCashDepoInstrumentType_args.Add("Currency", Currency);
			CreateCashDepoInstrumentType_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCashDepoInstrumentType", CreateCashDepoInstrumentType_args);
		}

		// <summary>
		// Create a market convention that generates schedules for a single cash payment.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="PaymentHolidays">Holiday conventions for payment dates.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="SettlementMaturityCalculator">Calculator for fixing settlement date given trade date.</param>
		// <param name="DayCountConvention">Day count convention.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateCashDepoMarketConvention(object MarketConventionName, object PaymentHolidays, object MaturityCalculator, object SettlementMaturityDescriptor, object SettlementMaturityCalculator, object DayCountConvention)
		{

			Hashtable CreateCashDepoMarketConvention_args = new Hashtable();
			CreateCashDepoMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateCashDepoMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateCashDepoMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateCashDepoMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateCashDepoMarketConvention_args.Add("SettlementMaturityCalculator", SettlementMaturityCalculator);
			CreateCashDepoMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateCashDepoMarketConvention", CreateCashDepoMarketConvention_args);
		}

		// <summary>
		// Create a market data set containing a set of cash deposit rates.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="DepositRates">Vector of cash deposit rates.</param>
		// <param name="Currency">Currency of deposits.</param>
		// <param name="CashDepoName">Name of cash depo market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="CashDepoType">Type of cash depo market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="MarketConventions">Market conventions for deposit dates.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCashDepoMarketData(object MarketDataSetName, object Maturities, object DepositRates, object Currency, object CashDepoName, object CashDepoType, object MarketConventions)
		{

			Hashtable CreateCashDepoMarketData_args = new Hashtable();
			CreateCashDepoMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCashDepoMarketData_args.Add("Maturities", Maturities);
			CreateCashDepoMarketData_args.Add("DepositRates", DepositRates);
			CreateCashDepoMarketData_args.Add("Currency", Currency);
			CreateCashDepoMarketData_args.Add("CashDepoName", CashDepoName);
			CreateCashDepoMarketData_args.Add("CashDepoType", CashDepoType);
			CreateCashDepoMarketData_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCashDepoMarketData", CreateCashDepoMarketData_args);
		}

		// <summary>
		// Create a cash deposit.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the deposit.</param>
		// <param name="Maturity">Deposit maturity.</param>
		// <param name="Notional">Notional amount of the deposit.</param>
		// <param name="Currency">Currency of the deposit.</param>
		// <param name="FixedCoupon">Fixed coupon of the deposit.</param>
		// <param name="MarketConvention">Market conventions for the deposit dates.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the deposit interest.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCashDepoProduct(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object FixedCoupon, object MarketConvention, object PayRec)
		{

			Hashtable CreateCashDepoProduct_args = new Hashtable();
			CreateCashDepoProduct_args.Add("ProductName", ProductName);
			CreateCashDepoProduct_args.Add("StartDate", StartDate);
			CreateCashDepoProduct_args.Add("Maturity", Maturity);
			CreateCashDepoProduct_args.Add("Notional", Notional);
			CreateCashDepoProduct_args.Add("Currency", Currency);
			CreateCashDepoProduct_args.Add("FixedCoupon", FixedCoupon);
			CreateCashDepoProduct_args.Add("MarketConvention", MarketConvention);
			CreateCashDepoProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateCashDepoProduct", CreateCashDepoProduct_args);
		}

		// <summary>
		// Create a cash flow based bond that makes arbitrary coupon and principal payments on cash flow dates.
		// </summary>
		// <param name="BondName">Name to use for the created bond.</param>
		// <param name="BondType">Bond type.</param>
		// <param name="CouponSchedule">Schedule for paying coupon payments.</param>
		// <param name="CouponPayments">Amount of the coupon payments.</param>
		// <param name="PrincipalSchedule">Schedule for paying principal payments. Default value: default-constructed instance of type roll_schedule.</param>
		// <param name="PrincipalPayments">Amount of the principal payments. Default value: default-constructed instance of type vector.</param>
		// <param name="MaturityDateOverride">Maturity date of the bond. Default value: default-constructed instance of type date.</param>
		// <param name="Notional">Notional amount of the bond. Default value: 100.</param>
		// <returns>Retuns the name of the constructed object of type Bond.</returns>
		public object CreateCashflowBasedBond(object BondName, object BondType, object CouponSchedule, object CouponPayments, object PrincipalSchedule, object PrincipalPayments, object MaturityDateOverride, object Notional)
		{

			Hashtable CreateCashflowBasedBond_args = new Hashtable();
			CreateCashflowBasedBond_args.Add("BondName", BondName);
			CreateCashflowBasedBond_args.Add("BondType", BondType);
			CreateCashflowBasedBond_args.Add("CouponSchedule", CouponSchedule);
			CreateCashflowBasedBond_args.Add("CouponPayments", CouponPayments);
			CreateCashflowBasedBond_args.Add("PrincipalSchedule", PrincipalSchedule);
			CreateCashflowBasedBond_args.Add("PrincipalPayments", PrincipalPayments);
			CreateCashflowBasedBond_args.Add("MaturityDateOverride", MaturityDateOverride);
			CreateCashflowBasedBond_args.Add("Notional", Notional);
			return F3Formatter.f3_style_serialization("CreateCashflowBasedBond", CreateCashflowBasedBond_args);
		}

		// <summary>
		// Create a single currency cash flow based bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateCashflowBasedBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object UniqueID)
		{

			Hashtable CreateCashflowBasedBondType_args = new Hashtable();
			CreateCashflowBasedBondType_args.Add("BondTypeName", BondTypeName);
			CreateCashflowBasedBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateCashflowBasedBondType_args.Add("YieldConvention", YieldConvention);
			CreateCashflowBasedBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateCashflowBasedBondType_args.Add("Currency", Currency);
			CreateCashflowBasedBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateCashflowBasedBondType", CreateCashflowBasedBondType_args);
		}

		// <summary>
		// Create a valuation specification that specifies a point in time after which cash flows are included in valuation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="FirstCashflowMaturity">Maturity from the valuation date for flow inclusion.</param>
		// <param name="MaturityCalculator">Methodology for maturity calculation.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCashflowInclusionValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object FirstCashflowMaturity, object MaturityCalculator)
		{

			Hashtable CreateCashflowInclusionValuationSpecification_args = new Hashtable();
			CreateCashflowInclusionValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCashflowInclusionValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCashflowInclusionValuationSpecification_args.Add("FirstCashflowMaturity", FirstCashflowMaturity);
			CreateCashflowInclusionValuationSpecification_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateCashflowInclusionValuationSpecification", CreateCashflowInclusionValuationSpecification_args);
		}

		// <summary>
		// Create a centered differentiation method.
		// </summary>
		// <param name="FunctionName">Name to use for the method.</param>
		// <param name="StepSize">Numerical differentiation step size.</param>
		// <param name="Tag">Tag to use for the step size.</param>
		// <returns>Retuns the name of the constructed object of type DifferentiationMethod.</returns>
		public object CreateCentredDifferentiationMethod(object FunctionName, object StepSize, object Tag)
		{

			Hashtable CreateCentredDifferentiationMethod_args = new Hashtable();
			CreateCentredDifferentiationMethod_args.Add("FunctionName", FunctionName);
			CreateCentredDifferentiationMethod_args.Add("StepSize", StepSize);
			CreateCentredDifferentiationMethod_args.Add("Tag", Tag);
			return F3Formatter.f3_style_serialization("CreateCentredDifferentiationMethod", CreateCentredDifferentiationMethod_args);
		}

		// <summary>
		// Creates a new chapter.
		// </summary>
		// <param name="Name">Name to use for the chapter.</param>
		// <param name="Title">Title to use for the chapter.</param>
		// <param name="Summary">Summary to use for the chapter.</param>
		// <param name="Description">Title to use for the chapter.</param>
		// <param name="References">References to use for the chapter.</param>
		// <returns>Retuns the name of the constructed object of type Chapter.</returns>
		public object CreateChapter(object Name, object Title, object Summary, object Description, object References)
		{

			Hashtable CreateChapter_args = new Hashtable();
			CreateChapter_args.Add("Name", Name);
			CreateChapter_args.Add("Title", Title);
			CreateChapter_args.Add("Summary", Summary);
			CreateChapter_args.Add("Description", Description);
			CreateChapter_args.Add("References", References);
			return F3Formatter.f3_style_serialization("CreateChapter", CreateChapter_args);
		}

		// <summary>
		// Create a characteristic function from a set of real functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="CharFuncBuilder">Characteristic function builder.</param>
		// <param name="Parameters">Characteristic function parameters.</param>
		// <param name="ExpiryTime">Expiry time.</param>
		// <param name="ExpiryTimeTag">Tag to use for the expiry time.</param>
		// <param name="ForwardTime">Forward time. Default value: 0.0.</param>
		// <param name="ForwardTimeTag">Tag to use for the forward time. Default value: default-constructed instance of type parameter_tag.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalComplexFunction.</returns>
		public object CreateCharacteristicFunction(object FunctionName, object CharFuncBuilder, object Parameters, object ExpiryTime, object ExpiryTimeTag, object ForwardTime, object ForwardTimeTag)
		{

			Hashtable CreateCharacteristicFunction_args = new Hashtable();
			CreateCharacteristicFunction_args.Add("FunctionName", FunctionName);
			CreateCharacteristicFunction_args.Add("CharFuncBuilder", CharFuncBuilder);
			CreateCharacteristicFunction_args.Add("Parameters", Parameters);
			CreateCharacteristicFunction_args.Add("ExpiryTime", ExpiryTime);
			CreateCharacteristicFunction_args.Add("ExpiryTimeTag", ExpiryTimeTag);
			CreateCharacteristicFunction_args.Add("ForwardTime", ForwardTime);
			CreateCharacteristicFunction_args.Add("ForwardTimeTag", ForwardTimeTag);
			return F3Formatter.f3_style_serialization("CreateCharacteristicFunction", CreateCharacteristicFunction_args);
		}

		// <summary>
		// Create a modifier for a stochastic process given its characteristic function.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Simulation time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="CharFunc">Characteristic function builder for the stochastic process.</param>
		// <param name="Parameters">Characteristic function parameters.</param>
		// <param name="CDFDiscretization">Strategy for discretizing the abscissa of the cumulative distribution functions.</param>
		// <param name="FFTMaxNumberOfSteps">Maximum number of steps to use in the fast Fourier transform. Default value: 0.</param>
		// <param name="FFTScale">Scaling factor applied to the critical frequency in the fast Fourier transform. Default value: 1.0.</param>
		// <param name="FFTTolerance">Tolerance to use in the determination of the cutoff frequency in the fast Fourier transform. Default value: 0.0.</param>
		// <param name="Tolerance">Tolerance on the imaginary part of the cumulative distribution functions. Default value: 0.001.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateCharacteristicFunctionModifier(object ModifierName, object TimePoints, object ForwardFunction, object CharFunc, object Parameters, object CDFDiscretization, object FFTMaxNumberOfSteps, object FFTScale, object FFTTolerance, object Tolerance)
		{

			Hashtable CreateCharacteristicFunctionModifier_args = new Hashtable();
			CreateCharacteristicFunctionModifier_args.Add("ModifierName", ModifierName);
			CreateCharacteristicFunctionModifier_args.Add("TimePoints", TimePoints);
			CreateCharacteristicFunctionModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateCharacteristicFunctionModifier_args.Add("CharFunc", CharFunc);
			CreateCharacteristicFunctionModifier_args.Add("Parameters", Parameters);
			CreateCharacteristicFunctionModifier_args.Add("CDFDiscretization", CDFDiscretization);
			CreateCharacteristicFunctionModifier_args.Add("FFTMaxNumberOfSteps", FFTMaxNumberOfSteps);
			CreateCharacteristicFunctionModifier_args.Add("FFTScale", FFTScale);
			CreateCharacteristicFunctionModifier_args.Add("FFTTolerance", FFTTolerance);
			CreateCharacteristicFunctionModifier_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreateCharacteristicFunctionModifier", CreateCharacteristicFunctionModifier_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating a characteristic function.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="CharFuncBuilder">Characteristic function builder.</param>
		// <param name="RealFunctions">Real functions specifying the parameters of the characteristic function.</param>
		// <param name="Expiry">Expiry time.</param>
		// <param name="ExpiryParameterTag">Tag to use for the expiry time.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateCharacteristicFunctionOperator(object OperatorName, object CharFuncBuilder, object RealFunctions, object Expiry, object ExpiryParameterTag)
		{

			Hashtable CreateCharacteristicFunctionOperator_args = new Hashtable();
			CreateCharacteristicFunctionOperator_args.Add("OperatorName", OperatorName);
			CreateCharacteristicFunctionOperator_args.Add("CharFuncBuilder", CharFuncBuilder);
			CreateCharacteristicFunctionOperator_args.Add("RealFunctions", RealFunctions);
			CreateCharacteristicFunctionOperator_args.Add("Expiry", Expiry);
			CreateCharacteristicFunctionOperator_args.Add("ExpiryParameterTag", ExpiryParameterTag);
			return F3Formatter.f3_style_serialization("CreateCharacteristicFunctionOperator", CreateCharacteristicFunctionOperator_args);
		}

		// <summary>
		// Create a state variable template for a stochastic process given its characteristic function.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="CharFuncBuilder">Characteristic function builder for the stochastic process.</param>
		// <param name="CDFDiscretization">Strategy for discretizing the abscissa of the cumulative distribution functions.</param>
		// <param name="FFTMaxNumberOfSteps">Maximum number of steps to use in the fast Fourier transform. Default value: 0.</param>
		// <param name="FFTScale">Scaling factor applied to the critical frequency in the fast Fourier transform. Default value: 1.0.</param>
		// <param name="FFTTolerance">Tolerance to use in the determination of the cutoff frequency in the fast Fourier transform. Default value: 0.0.</param>
		// <param name="Tolerance">Tolerance on the imaginary part of the cumulative distribution functions. Default value: 0.001.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateCharacteristicFunctionStateVariableTemplate(object StateVariableTemplateName, object CharFuncBuilder, object CDFDiscretization, object FFTMaxNumberOfSteps, object FFTScale, object FFTTolerance, object Tolerance)
		{

			Hashtable CreateCharacteristicFunctionStateVariableTemplate_args = new Hashtable();
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("CharFuncBuilder", CharFuncBuilder);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("CDFDiscretization", CDFDiscretization);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("FFTMaxNumberOfSteps", FFTMaxNumberOfSteps);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("FFTScale", FFTScale);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("FFTTolerance", FFTTolerance);
			CreateCharacteristicFunctionStateVariableTemplate_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreateCharacteristicFunctionStateVariableTemplate", CreateCharacteristicFunctionStateVariableTemplate_args);
		}

		// <summary>
		// Specify the integral size and number of steps to use in the numerical evaluation of the characteristic integral.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="IntegralSize">Numerical integral size. Default value: 150.0.</param>
		// <param name="NumberOfSteps">Number of steps to use. Default value: 699.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCharacteristicIntegralValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object IntegralSize, object NumberOfSteps)
		{

			Hashtable CreateCharacteristicIntegralValuationSpecification_args = new Hashtable();
			CreateCharacteristicIntegralValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCharacteristicIntegralValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCharacteristicIntegralValuationSpecification_args.Add("IntegralSize", IntegralSize);
			CreateCharacteristicIntegralValuationSpecification_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateCharacteristicIntegralValuationSpecification", CreateCharacteristicIntegralValuationSpecification_args);
		}

		// <summary>
		// Specify the integral size and number of steps to use in the numerical evaluation of the characteristic integral.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="IntegralSize">The numerical integral size. Default value: 150.0.</param>
		// <param name="NumberOfSteps">The number of steps to use. Default value: 699.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateCharacteristicIntegralValuationSpecificationBuilder(object BuilderName, object IntegralSize, object NumberOfSteps)
		{

			Hashtable CreateCharacteristicIntegralValuationSpecificationBuilder_args = new Hashtable();
			CreateCharacteristicIntegralValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateCharacteristicIntegralValuationSpecificationBuilder_args.Add("IntegralSize", IntegralSize);
			CreateCharacteristicIntegralValuationSpecificationBuilder_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateCharacteristicIntegralValuationSpecificationBuilder", CreateCharacteristicIntegralValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a valuation specification that specifies a date and methodology for clean value calculation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="CleanValuationMaturity">The maturity of the clean valuation date, from the model base date. Default value: 0d.</param>
		// <param name="MaturityCalculator">Methodology for calculating the clean valuation date. Default value: NoHolidays.</param>
		// <param name="AccrualConvention">Optional methodology for calculating the accrual fraction. Default value: act/365f.</param>
		// <param name="OverrideProductAccrualConvention">If true, override the product accrual convention with the specified one. Default value: False.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCleanValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object CleanValuationMaturity, object MaturityCalculator, object AccrualConvention, object OverrideProductAccrualConvention)
		{

			Hashtable CreateCleanValuationSpecification_args = new Hashtable();
			CreateCleanValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCleanValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCleanValuationSpecification_args.Add("CleanValuationMaturity", CleanValuationMaturity);
			CreateCleanValuationSpecification_args.Add("MaturityCalculator", MaturityCalculator);
			CreateCleanValuationSpecification_args.Add("AccrualConvention", AccrualConvention);
			CreateCleanValuationSpecification_args.Add("OverrideProductAccrualConvention", OverrideProductAccrualConvention);
			return F3Formatter.f3_style_serialization("CreateCleanValuationSpecification", CreateCleanValuationSpecification_args);
		}

		// <summary>
		// Specify which stochastic process to use for closed-form pricing of payoffs based on a given asset value index.
		// </summary>
		// <param name="ValuationMethod">Name to use for created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="AssetIndex">Index representing the value of the underlying asset.</param>
		// <param name="VolatilityType">Type of stochastic process to be followed by the given asset.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateClosedFormAssetVolatilityValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object AssetIndex, object VolatilityType)
		{

			Hashtable CreateClosedFormAssetVolatilityValuationSpecification_args = new Hashtable();
			CreateClosedFormAssetVolatilityValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateClosedFormAssetVolatilityValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateClosedFormAssetVolatilityValuationSpecification_args.Add("AssetIndex", AssetIndex);
			CreateClosedFormAssetVolatilityValuationSpecification_args.Add("VolatilityType", VolatilityType);
			return F3Formatter.f3_style_serialization("CreateClosedFormAssetVolatilityValuationSpecification", CreateClosedFormAssetVolatilityValuationSpecification_args);
		}

		// <summary>
		// Specify which stochastic process to use for closed-form pricing of payoffs based on a given asset value index.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="AssetIndex">Index representing the value of the underlying asset.</param>
		// <param name="VolatilityType">Type of stochastic process to be followed by the given asset.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateClosedFormAssetVolatilityValuationSpecificationBuilder(object BuilderName, object AssetIndex, object VolatilityType)
		{

			Hashtable CreateClosedFormAssetVolatilityValuationSpecificationBuilder_args = new Hashtable();
			CreateClosedFormAssetVolatilityValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateClosedFormAssetVolatilityValuationSpecificationBuilder_args.Add("AssetIndex", AssetIndex);
			CreateClosedFormAssetVolatilityValuationSpecificationBuilder_args.Add("VolatilityType", VolatilityType);
			return F3Formatter.f3_style_serialization("CreateClosedFormAssetVolatilityValuationSpecificationBuilder", CreateClosedFormAssetVolatilityValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a closed-form valuation specification that compounds a forward rate implied from an underlying curve.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="RateIndices">Vector of indices representing the rates to be compounded.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCollapsedCompoundingRateValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object RateIndices)
		{

			Hashtable CreateCollapsedCompoundingRateValuationSpecification_args = new Hashtable();
			CreateCollapsedCompoundingRateValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCollapsedCompoundingRateValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCollapsedCompoundingRateValuationSpecification_args.Add("RateIndices", RateIndices);
			return F3Formatter.f3_style_serialization("CreateCollapsedCompoundingRateValuationSpecification", CreateCollapsedCompoundingRateValuationSpecification_args);
		}

		// <summary>
		// Extract a collateral agreement from a product.
		// </summary>
		// <param name="ObjectName">Name to use for the extracted object.</param>
		// <param name="UnderlyingAgreement">Underlying collateral agreement or product containing a collateral agreement.</param>
		// <returns>Retuns the name of the constructed object of type CollateralAgreement.</returns>
		public object CreateCollateralAgreement(object ObjectName, object UnderlyingAgreement)
		{

			Hashtable CreateCollateralAgreement_args = new Hashtable();
			CreateCollateralAgreement_args.Add("ObjectName", ObjectName);
			CreateCollateralAgreement_args.Add("UnderlyingAgreement", UnderlyingAgreement);
			return F3Formatter.f3_style_serialization("CreateCollateralAgreement", CreateCollateralAgreement_args);
		}

		// <summary>
		// Create an instrument type whose instrument products are collateralized under the given agreement.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Underlying">Underlying instrument type to be collateralized.</param>
		// <param name="CollateralAgreement">Agreement under which the quoted products are collateralized.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateCollateralizedInstrumentType(object MarketDataSetName, object Underlying, object CollateralAgreement)
		{

			Hashtable CreateCollateralizedInstrumentType_args = new Hashtable();
			CreateCollateralizedInstrumentType_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCollateralizedInstrumentType_args.Add("Underlying", Underlying);
			CreateCollateralizedInstrumentType_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateCollateralizedInstrumentType", CreateCollateralizedInstrumentType_args);
		}

		// <summary>
		// Create a market data set whose instrument products are collateralized under the given agreement.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Underlying">Underlying market data set to be collateralized.</param>
		// <param name="CollateralAgreement">Agreement under which the quoted products are collateralized.</param>
		// <param name="MarketDataTags">Tags specifying the market data elements to be collateralized. Default value: default-constructed instance of type marketdata_tags.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCollateralizedMarketData(object MarketDataSetName, object Underlying, object CollateralAgreement, object MarketDataTags)
		{

			Hashtable CreateCollateralizedMarketData_args = new Hashtable();
			CreateCollateralizedMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCollateralizedMarketData_args.Add("Underlying", Underlying);
			CreateCollateralizedMarketData_args.Add("CollateralAgreement", CollateralAgreement);
			CreateCollateralizedMarketData_args.Add("MarketDataTags", MarketDataTags);
			return F3Formatter.f3_style_serialization("CreateCollateralizedMarketData", CreateCollateralizedMarketData_args);
		}

		// <summary>
		// Create a product from an underlying product and a collateral agreement.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="UnderlyingProduct">Underlying product.</param>
		// <param name="CollateralAgreement">Collateralization rules to use for the new product.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCollateralizedProduct(object ProductName, object UnderlyingProduct, object CollateralAgreement)
		{

			Hashtable CreateCollateralizedProduct_args = new Hashtable();
			CreateCollateralizedProduct_args.Add("ProductName", ProductName);
			CreateCollateralizedProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateCollateralizedProduct_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateCollateralizedProduct", CreateCollateralizedProduct_args);
		}

		// <summary>
		// Defines a commodity entity.
		// </summary>
		// <param name="CommodityName">Name to use for the commodity.</param>
		// <param name="Category">Label to specify a commodity category.</param>
		// <param name="Unit">Trading unit of the commodity.</param>
		// <param name="Currency">Trading currency of the commodity.</param>
		// <param name="CommodityLabel">Label for further commodity-specific details.</param>
		// <returns>Retuns the name of the constructed object of type CommodityEntity.</returns>
		public object CreateCommodityEntity(object CommodityName, object Category, object Unit, object Currency, object CommodityLabel)
		{

			Hashtable CreateCommodityEntity_args = new Hashtable();
			CreateCommodityEntity_args.Add("CommodityName", CommodityName);
			CreateCommodityEntity_args.Add("Category", Category);
			CreateCommodityEntity_args.Add("Unit", Unit);
			CreateCommodityEntity_args.Add("Currency", Currency);
			CreateCommodityEntity_args.Add("CommodityLabel", CommodityLabel);
			return F3Formatter.f3_style_serialization("CreateCommodityEntity", CreateCommodityEntity_args);
		}

		// <summary>
		// Define a futures contract type for a futures contract whose underlying is a commodiity.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">The amount of the underlying commodity per contract.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateCommodityFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateCommodityFuturesContractType_args = new Hashtable();
			CreateCommodityFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateCommodityFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateCommodityFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateCommodityFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateCommodityFuturesContractType", CreateCommodityFuturesContractType_args);
		}

		// <summary>
		// Create a market data set containing a set of commodity futures positions.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="FuturesContractType">Type of futures contract.</param>
		// <param name="Maturities">Vector of maturity descriptors for spot date to forward start date.</param>
		// <param name="TradedPrices">Vector of prices for the futures trades.</param>
		// <param name="TagName">Name of futures market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="TagType">Type of futures market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="Underlying">Futures underlying.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCommodityFuturesMarketData(object MarketDataSetName, object FuturesContractType, object Maturities, object TradedPrices, object TagName, object TagType, object Underlying)
		{

			Hashtable CreateCommodityFuturesMarketData_args = new Hashtable();
			CreateCommodityFuturesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCommodityFuturesMarketData_args.Add("FuturesContractType", FuturesContractType);
			CreateCommodityFuturesMarketData_args.Add("Maturities", Maturities);
			CreateCommodityFuturesMarketData_args.Add("TradedPrices", TradedPrices);
			CreateCommodityFuturesMarketData_args.Add("TagName", TagName);
			CreateCommodityFuturesMarketData_args.Add("TagType", TagType);
			CreateCommodityFuturesMarketData_args.Add("Underlying", Underlying);
			return F3Formatter.f3_style_serialization("CreateCommodityFuturesMarketData", CreateCommodityFuturesMarketData_args);
		}

		// <summary>
		// Create an index representing the value of a commodity transaction.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CommodityEntity">Commodity entity describing the underlying commodity.</param>
		// <param name="MarketConventions">Market conventions for transaction settlement.</param>
		// <param name="IndexReferencer">Index referencer. Default value: default-constructed instance of type referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCommodityIndex(object IndexName, object CommodityEntity, object MarketConventions, object IndexReferencer)
		{

			Hashtable CreateCommodityIndex_args = new Hashtable();
			CreateCommodityIndex_args.Add("IndexName", IndexName);
			CreateCommodityIndex_args.Add("CommodityEntity", CommodityEntity);
			CreateCommodityIndex_args.Add("MarketConventions", MarketConventions);
			CreateCommodityIndex_args.Add("IndexReferencer", IndexReferencer);
			return F3Formatter.f3_style_serialization("CreateCommodityIndex", CreateCommodityIndex_args);
		}

		// <summary>
		// Create a commodity trade.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Commodity">The commodity being traded.</param>
		// <param name="SettlementDetails">Specification of when the trade is agreed and settled.</param>
		// <param name="CommodityPrice">The agreed price per trading unit of the commodity.</param>
		// <param name="CommodityAmount">The amount of the commodity in trading unit.</param>
		// <param name="BuySell">Flag indicating purchase or sale of the commodity.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCommodityProduct(object ProductName, object Commodity, object SettlementDetails, object CommodityPrice, object CommodityAmount, object BuySell)
		{

			Hashtable CreateCommodityProduct_args = new Hashtable();
			CreateCommodityProduct_args.Add("ProductName", ProductName);
			CreateCommodityProduct_args.Add("Commodity", Commodity);
			CreateCommodityProduct_args.Add("SettlementDetails", SettlementDetails);
			CreateCommodityProduct_args.Add("CommodityPrice", CommodityPrice);
			CreateCommodityProduct_args.Add("CommodityAmount", CommodityAmount);
			CreateCommodityProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateCommodityProduct", CreateCommodityProduct_args);
		}

		// <summary>
		// Create a market data set containing a set of cash settled swaptions with a common strike specification.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of swaption expiries.</param>
		// <param name="SwapLengths">Vector of underlying swap lengths.</param>
		// <param name="Strike">Strike of the swaptions.</param>
		// <param name="ImpliedVolatilities">Matrix of swaption implied volatilities.</param>
		// <param name="Currency">Currency of the swaptions. Default value: default-constructed instance of type currency.</param>
		// <param name="SwaptionName">Name of the swaption market data.</param>
		// <param name="SwaptionType">Type of the swaption market data.</param>
		// <param name="MarketConventionsForFixedLeg">Market conventions for the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="MarketConventionsForFloatingLeg">Market conventions for the floating leg.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCommonStrikeParYieldCashSettledSwaptionMarketData(object MarketDataSetName, object Expiries, object SwapLengths, object Strike, object ImpliedVolatilities, object Currency, object SwaptionName, object SwaptionType, object MarketConventionsForFixedLeg, object FloatingRateIndex,
		object MarketConventionsForFloatingLeg, object QuoteDate)
		{

			Hashtable CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args = new Hashtable();
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("Expiries", Expiries);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("SwapLengths", SwapLengths);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("Strike", Strike);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("ImpliedVolatilities", ImpliedVolatilities);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("Currency", Currency);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("SwaptionName", SwaptionName);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("SwaptionType", SwaptionType);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("MarketConventionsForFixedLeg", MarketConventionsForFixedLeg);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("MarketConventionsForFloatingLeg", MarketConventionsForFloatingLeg);
			CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateCommonStrikeParYieldCashSettledSwaptionMarketData", CreateCommonStrikeParYieldCashSettledSwaptionMarketData_args);
		}

		// <summary>
		// Create a market data set containing a set of interest rate caps or floors with a common strike specification.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="Volatilities">Vector of cap or floor volatilities.</param>
		// <param name="Strike">Strike of the caps or floors.</param>
		// <param name="CapFloorName">Name of cap or floor market data.</param>
		// <param name="CapFloorType">Type of cap or floor market data.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="Payoff">Payoff for the option. Default value: straddle.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <param name="ScheduleMarketConventions">Market conventions for the cap or floor. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCommonStrikeVanillaCapFloorMarketData(object MarketDataSetName, object Maturities, object Volatilities, object Strike, object CapFloorName, object CapFloorType, object FloatingIndex, object Payoff, object QuoteDate, object ScheduleMarketConventions)
		{

			Hashtable CreateCommonStrikeVanillaCapFloorMarketData_args = new Hashtable();
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("Maturities", Maturities);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("Volatilities", Volatilities);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("Strike", Strike);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("CapFloorName", CapFloorName);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("CapFloorType", CapFloorType);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("FloatingIndex", FloatingIndex);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("Payoff", Payoff);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("QuoteDate", QuoteDate);
			CreateCommonStrikeVanillaCapFloorMarketData_args.Add("ScheduleMarketConventions", ScheduleMarketConventions);
			return F3Formatter.f3_style_serialization("CreateCommonStrikeVanillaCapFloorMarketData", CreateCommonStrikeVanillaCapFloorMarketData_args);
		}

		// <summary>
		// Create a market data set containing a set of vanilla interest rate swaptions with a common strike specification.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of swaption expiries.</param>
		// <param name="SwapLengths">Vector of underlying swap lengths.</param>
		// <param name="Strike">Strike of the swaptions.</param>
		// <param name="ImpliedVolatilities">Matrix of swaption implied volatilities.</param>
		// <param name="Currency">Currency of the swaptions. Default value: default-constructed instance of type currency.</param>
		// <param name="SwaptionName">Name of the swaption market data.</param>
		// <param name="SwaptionType">Type of the swaption market data.</param>
		// <param name="MarketConventionsForFixedLeg">Market conventions for the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="MarketConventionsForFloatingLeg">Market conventions for the floating leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCommonStrikeVanillaSwaptionMarketData(object MarketDataSetName, object Expiries, object SwapLengths, object Strike, object ImpliedVolatilities, object Currency, object SwaptionName, object SwaptionType, object MarketConventionsForFixedLeg, object FloatingRateIndex,
		object MarketConventionsForFloatingLeg, object QuoteDate)
		{

			Hashtable CreateCommonStrikeVanillaSwaptionMarketData_args = new Hashtable();
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("Expiries", Expiries);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("SwapLengths", SwapLengths);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("Strike", Strike);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("ImpliedVolatilities", ImpliedVolatilities);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("Currency", Currency);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("SwaptionName", SwaptionName);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("SwaptionType", SwaptionType);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("MarketConventionsForFixedLeg", MarketConventionsForFixedLeg);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("MarketConventionsForFloatingLeg", MarketConventionsForFloatingLeg);
			CreateCommonStrikeVanillaSwaptionMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateCommonStrikeVanillaSwaptionMarketData", CreateCommonStrikeVanillaSwaptionMarketData_args);
		}

		// <summary>
		// Create a composite accumulator source.
		// </summary>
		// <param name="AccumulatorName">Name to use for the accumulator source.</param>
		// <param name="AccumulatorSources">Accumulator sources.</param>
		// <returns>Retuns the name of the constructed object of type AccumulatorSource.</returns>
		public object CreateCompositeAccumulator(object AccumulatorName, object AccumulatorSources)
		{

			Hashtable CreateCompositeAccumulator_args = new Hashtable();
			CreateCompositeAccumulator_args.Add("AccumulatorName", AccumulatorName);
			CreateCompositeAccumulator_args.Add("AccumulatorSources", AccumulatorSources);
			return F3Formatter.f3_style_serialization("CreateCompositeAccumulator", CreateCompositeAccumulator_args);
		}

		// <summary>
		// Create a date modifier from a list of date modifiers.
		// </summary>
		// <param name="DateModifierName">Name to use for the composite date modifier.</param>
		// <param name="DateModifierList">A list of date modifiers that will be applied in sequence.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateCompositeDateModifier(object DateModifierName, object DateModifierList)
		{

			Hashtable CreateCompositeDateModifier_args = new Hashtable();
			CreateCompositeDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateCompositeDateModifier_args.Add("DateModifierList", DateModifierList);
			return F3Formatter.f3_style_serialization("CreateCompositeDateModifier", CreateCompositeDateModifier_args);
		}

		// <summary>
		// Create a composite holiday convention.
		// </summary>
		// <param name="HolidayConventionName">Name to use for the composite holiday convention.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		// <returns>Retuns the name of the constructed object of type HolidayConvention.</returns>
		public object CreateCompositeHolidayConvention(object HolidayConventionName, object HolidayConventions)
		{

			Hashtable CreateCompositeHolidayConvention_args = new Hashtable();
			CreateCompositeHolidayConvention_args.Add("HolidayConventionName", HolidayConventionName);
			CreateCompositeHolidayConvention_args.Add("HolidayConventions", HolidayConventions);
			return F3Formatter.f3_style_serialization("CreateCompositeHolidayConvention", CreateCompositeHolidayConvention_args);
		}

		// <summary>
		// Form a modeling configuration from one or more underlying configurations.
		// </summary>
		// <param name="ConfigurationName">Name to use for modeling configuration.</param>
		// <param name="UnderlyingConfigurations">One or more modeling configurations.</param>
		// <returns>Retuns the name of the constructed object of type ModelingConfiguration.</returns>
		public object CreateCompositeModelingConfiguration(object ConfigurationName, object UnderlyingConfigurations)
		{

			Hashtable CreateCompositeModelingConfiguration_args = new Hashtable();
			CreateCompositeModelingConfiguration_args.Add("ConfigurationName", ConfigurationName);
			CreateCompositeModelingConfiguration_args.Add("UnderlyingConfigurations", UnderlyingConfigurations);
			return F3Formatter.f3_style_serialization("CreateCompositeModelingConfiguration", CreateCompositeModelingConfiguration_args);
		}

		// <summary>
		// Create a scenario which is the composition of other scenarios.
		// </summary>
		// <param name="ScenarioName">Name to use for the scenario.</param>
		// <param name="ScenarioCollection">Scenario collection.</param>
		// <returns>Retuns the name of the constructed object of type Scenario.</returns>
		public object CreateCompositeScenario(object ScenarioName, object ScenarioCollection)
		{

			Hashtable CreateCompositeScenario_args = new Hashtable();
			CreateCompositeScenario_args.Add("ScenarioName", ScenarioName);
			CreateCompositeScenario_args.Add("ScenarioCollection", ScenarioCollection);
			return F3Formatter.f3_style_serialization("CreateCompositeScenario", CreateCompositeScenario_args);
		}

		// <summary>
		// Create a scenario generator as a container of one or more underlying scenario generators.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="Constituents">List of scenario generators.</param>
		// <returns>Retuns the name of the constructed object of type ScenarioGenerator.</returns>
		public object CreateCompositeScenarioGenerator(object GeneratorName, object Constituents)
		{

			Hashtable CreateCompositeScenarioGenerator_args = new Hashtable();
			CreateCompositeScenarioGenerator_args.Add("GeneratorName", GeneratorName);
			CreateCompositeScenarioGenerator_args.Add("Constituents", Constituents);
			return F3Formatter.f3_style_serialization("CreateCompositeScenarioGenerator", CreateCompositeScenarioGenerator_args);
		}

		// <summary>
		// Create a valuation specification builder that aggregates a collection of others.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="CalculationStrategies">Calculation strategies to aggregate.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateCompositeValuationSpecificationBuilder(object BuilderName, object CalculationStrategies)
		{

			Hashtable CreateCompositeValuationSpecificationBuilder_args = new Hashtable();
			CreateCompositeValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateCompositeValuationSpecificationBuilder_args.Add("CalculationStrategies", CalculationStrategies);
			return F3Formatter.f3_style_serialization("CreateCompositeValuationSpecificationBuilder", CreateCompositeValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a function as the composition of two others.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="FirstFunction">One-dimensional function that is applied to the result of the second function.</param>
		// <param name="SecondFunction">One-dimensional function that is applied to the argument.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateCompositionFunction(object FunctionName, object FirstFunction, object SecondFunction)
		{

			Hashtable CreateCompositionFunction_args = new Hashtable();
			CreateCompositionFunction_args.Add("FunctionName", FunctionName);
			CreateCompositionFunction_args.Add("FirstFunction", FirstFunction);
			CreateCompositionFunction_args.Add("SecondFunction", SecondFunction);
			return F3Formatter.f3_style_serialization("CreateCompositionFunction", CreateCompositionFunction_args);
		}

		// <summary>
		// Create an arithmetic average rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for rate sampling.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCompoundingAverageRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateCompoundingAverageRateIndex_args = new Hashtable();
			CreateCompoundingAverageRateIndex_args.Add("IndexName", IndexName);
			CreateCompoundingAverageRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateCompoundingAverageRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateCompoundingAverageRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCompoundingAverageRateIndex", CreateCompoundingAverageRateIndex_args);
		}

		// <summary>
		// Create a geometric average rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for rate sampling.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCompoundingGeometricAverageRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateCompoundingGeometricAverageRateIndex_args = new Hashtable();
			CreateCompoundingGeometricAverageRateIndex_args.Add("IndexName", IndexName);
			CreateCompoundingGeometricAverageRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateCompoundingGeometricAverageRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateCompoundingGeometricAverageRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCompoundingGeometricAverageRateIndex", CreateCompoundingGeometricAverageRateIndex_args);
		}

		// <summary>
		// Create a compounding interest rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for the compounded rate.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCompoundingRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateCompoundingRateIndex_args = new Hashtable();
			CreateCompoundingRateIndex_args.Add("IndexName", IndexName);
			CreateCompoundingRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateCompoundingRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateCompoundingRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCompoundingRateIndex", CreateCompoundingRateIndex_args);
		}

		// <summary>
		// Create an index as the compounded value of an underlying index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for the compounded rate.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCompoundingRateValueIndex(object IndexName, object UnderlyingIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateCompoundingRateValueIndex_args = new Hashtable();
			CreateCompoundingRateValueIndex_args.Add("IndexName", IndexName);
			CreateCompoundingRateValueIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateCompoundingRateValueIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateCompoundingRateValueIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateCompoundingRateValueIndex", CreateCompoundingRateValueIndex_args);
		}

		// <summary>
		// Create an index referencer by concatenating the actions of two referencers.
		// </summary>
		// <param name="ReferencerName">Name to use for referencer.</param>
		// <param name="MainReferencer">Main index referencer.</param>
		// <param name="UnderlyingReferencer">Underlying index referencer.</param>
		// <param name="RollBuilder">Builder to use to form roll from underlying reference point.</param>
		// <returns>Retuns the name of the constructed object of type IndexReferencer.</returns>
		public object CreateConcatenatedIndexReferencer(object ReferencerName, object MainReferencer, object UnderlyingReferencer, object RollBuilder)
		{

			Hashtable CreateConcatenatedIndexReferencer_args = new Hashtable();
			CreateConcatenatedIndexReferencer_args.Add("ReferencerName", ReferencerName);
			CreateConcatenatedIndexReferencer_args.Add("MainReferencer", MainReferencer);
			CreateConcatenatedIndexReferencer_args.Add("UnderlyingReferencer", UnderlyingReferencer);
			CreateConcatenatedIndexReferencer_args.Add("RollBuilder", RollBuilder);
			return F3Formatter.f3_style_serialization("CreateConcatenatedIndexReferencer", CreateConcatenatedIndexReferencer_args);
		}

		// <summary>
		// Create an instrument strategy from a collection of instrument strategies.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="InstrumentStrategies">Underlying instrument strategies.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateConcatenatedInstrumentStrategy(object StrategyName, object InstrumentStrategies)
		{

			Hashtable CreateConcatenatedInstrumentStrategy_args = new Hashtable();
			CreateConcatenatedInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateConcatenatedInstrumentStrategy_args.Add("InstrumentStrategies", InstrumentStrategies);
			return F3Formatter.f3_style_serialization("CreateConcatenatedInstrumentStrategy", CreateConcatenatedInstrumentStrategy_args);
		}

		// <summary>
		// Create a two-dimensional constant function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Parameter">The constant value.</param>
		// <param name="ParameterTag">Tag to use for the parameter.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateConstant2dFunction(object FunctionName, object Parameter, object ParameterTag)
		{

			Hashtable CreateConstant2dFunction_args = new Hashtable();
			CreateConstant2dFunction_args.Add("FunctionName", FunctionName);
			CreateConstant2dFunction_args.Add("Parameter", Parameter);
			CreateConstant2dFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateConstant2dFunction", CreateConstant2dFunction_args);
		}

		// <summary>
		// Create a constant function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Parameter">The constant value.</param>
		// <param name="ParameterTag">Tag to use for the parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateConstantFunction(object FunctionName, object Parameter, object ParameterTag)
		{

			Hashtable CreateConstantFunction_args = new Hashtable();
			CreateConstantFunction_args.Add("FunctionName", FunctionName);
			CreateConstantFunction_args.Add("Parameter", Parameter);
			CreateConstantFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateConstantFunction", CreateConstantFunction_args);
		}

		// <summary>
		// Create a constant-maturity swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure of the swap.</param>
		// <param name="FixedCoupon">The fixed coupon paid on each roll of the fixed leg.</param>
		// <param name="FixedLegMarketConvention">Schedule generator for the fixed leg.</param>
		// <param name="SwapRateIndex">Index describing the swap rate to be paid on the floating leg.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateConstantMaturitySwap(object ProductName, object StartDate, object Maturity, object Notional, object FixedCoupon, object FixedLegMarketConvention, object SwapRateIndex, object Margin, object FloatingLegMarketConvention, object PayRec)
		{

			Hashtable CreateConstantMaturitySwap_args = new Hashtable();
			CreateConstantMaturitySwap_args.Add("ProductName", ProductName);
			CreateConstantMaturitySwap_args.Add("StartDate", StartDate);
			CreateConstantMaturitySwap_args.Add("Maturity", Maturity);
			CreateConstantMaturitySwap_args.Add("Notional", Notional);
			CreateConstantMaturitySwap_args.Add("FixedCoupon", FixedCoupon);
			CreateConstantMaturitySwap_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateConstantMaturitySwap_args.Add("SwapRateIndex", SwapRateIndex);
			CreateConstantMaturitySwap_args.Add("Margin", Margin);
			CreateConstantMaturitySwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateConstantMaturitySwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateConstantMaturitySwap", CreateConstantMaturitySwap_args);
		}

		// <summary>
		// Create a continuously compounded function from a rate with term structure.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTimePoint">Base time point.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="Rates">Vector of rates.</param>
		// <param name="TimeCalculator">Time calculator to use.</param>
		// <param name="RatesTag">Tag to use for the rates.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateContinuousCompoundingFunction(object FunctionName, object BaseTimePoint, object TimePoints, object Rates, object TimeCalculator, object RatesTag)
		{

			Hashtable CreateContinuousCompoundingFunction_args = new Hashtable();
			CreateContinuousCompoundingFunction_args.Add("FunctionName", FunctionName);
			CreateContinuousCompoundingFunction_args.Add("BaseTimePoint", BaseTimePoint);
			CreateContinuousCompoundingFunction_args.Add("TimePoints", TimePoints);
			CreateContinuousCompoundingFunction_args.Add("Rates", Rates);
			CreateContinuousCompoundingFunction_args.Add("TimeCalculator", TimeCalculator);
			CreateContinuousCompoundingFunction_args.Add("RatesTag", RatesTag);
			return F3Formatter.f3_style_serialization("CreateContinuousCompoundingFunction", CreateContinuousCompoundingFunction_args);
		}

		// <summary>
		// Create a modifier whose outputs are correlated based on the input values.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Correlations">Vector of values for the correlation between each variate.</param>
		// <param name="CorrelationParameterTag">Tag to use for the correlation parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateCorrelatedPathModifier(object ModifierName, object Correlations, object CorrelationParameterTag)
		{

			Hashtable CreateCorrelatedPathModifier_args = new Hashtable();
			CreateCorrelatedPathModifier_args.Add("ModifierName", ModifierName);
			CreateCorrelatedPathModifier_args.Add("Correlations", Correlations);
			CreateCorrelatedPathModifier_args.Add("CorrelationParameterTag", CorrelationParameterTag);
			return F3Formatter.f3_style_serialization("CreateCorrelatedPathModifier", CreateCorrelatedPathModifier_args);
		}

		// <summary>
		// Create an instrument strategy for a correlation pair.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="MarketDataTag">Tag for the correlation market data.</param>
		// <param name="IndexPair">Pair of indices to be correlated.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateCorrelationPairInstrumentStrategy(object StrategyName, object MarketDataTag, object IndexPair)
		{

			Hashtable CreateCorrelationPairInstrumentStrategy_args = new Hashtable();
			CreateCorrelationPairInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateCorrelationPairInstrumentStrategy_args.Add("MarketDataTag", MarketDataTag);
			CreateCorrelationPairInstrumentStrategy_args.Add("IndexPair", IndexPair);
			return F3Formatter.f3_style_serialization("CreateCorrelationPairInstrumentStrategy", CreateCorrelationPairInstrumentStrategy_args);
		}

		// <summary>
		// Create a market data set from a collection of correlation pairs.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="NamePairs">Vector of correlated name pairs.</param>
		// <param name="Correlations">Vector of pairwise correlations.</param>
		// <param name="CorrelationName">Name to use for the pairwise correlation market data.</param>
		// <param name="CorrelationType">Type name for the pairwise correlation market data.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCorrelationPairMarketData(object MarketDataSetName, object NamePairs, object Correlations, object CorrelationName, object CorrelationType)
		{

			Hashtable CreateCorrelationPairMarketData_args = new Hashtable();
			CreateCorrelationPairMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCorrelationPairMarketData_args.Add("NamePairs", NamePairs);
			CreateCorrelationPairMarketData_args.Add("Correlations", Correlations);
			CreateCorrelationPairMarketData_args.Add("CorrelationName", CorrelationName);
			CreateCorrelationPairMarketData_args.Add("CorrelationType", CorrelationType);
			return F3Formatter.f3_style_serialization("CreateCorrelationPairMarketData", CreateCorrelationPairMarketData_args);
		}

		// <summary>
		// Create a product whose value is the expected loss from a product, or portfolio of products, due to counterparty default.
		// </summary>
		// <param name="ProductName">Name to use for product.</param>
		// <param name="UnderlyingProduct">Product for which counterparty risk is being calculated.</param>
		// <param name="StartDate">Start of period for which counterparty default is being considered.</param>
		// <param name="EndDate">End of period for which counterparty default is being considered.</param>
		// <param name="CreditIndex">Loss given default index for the counterparty.</param>
		// <param name="PositiveExposure">Flag indicating whether the positive part of the exposure is calculated. Default value: true.</param>
		// <param name="CollateralizationRules">Rules governing the posting of collateral by the counterparty. Default value: default-constructed instance of type collateral_agreement.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCounterpartyExposureProduct(object ProductName, object UnderlyingProduct, object StartDate, object EndDate, object CreditIndex, object PositiveExposure, object CollateralizationRules)
		{

			Hashtable CreateCounterpartyExposureProduct_args = new Hashtable();
			CreateCounterpartyExposureProduct_args.Add("ProductName", ProductName);
			CreateCounterpartyExposureProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateCounterpartyExposureProduct_args.Add("StartDate", StartDate);
			CreateCounterpartyExposureProduct_args.Add("EndDate", EndDate);
			CreateCounterpartyExposureProduct_args.Add("CreditIndex", CreditIndex);
			CreateCounterpartyExposureProduct_args.Add("PositiveExposure", PositiveExposure);
			CreateCounterpartyExposureProduct_args.Add("CollateralizationRules", CollateralizationRules);
			return F3Formatter.f3_style_serialization("CreateCounterpartyExposureProduct", CreateCounterpartyExposureProduct_args);
		}

		// <summary>
		// Define a unique credit entity.
		// </summary>
		// <param name="CreditEntityName">Name to use for credit entity.</param>
		// <param name="Entity">Name of entity.</param>
		// <param name="AgreementType">Type of credit agreement of entity, as an optional property. Default value: default-constructed instance of type credit_agreement.</param>
		// <returns>Retuns the name of the constructed object of type CreditEntity.</returns>
		public object CreateCreditEntity(object CreditEntityName, object Entity, object AgreementType)
		{

			Hashtable CreateCreditEntity_args = new Hashtable();
			CreateCreditEntity_args.Add("CreditEntityName", CreditEntityName);
			CreateCreditEntity_args.Add("Entity", Entity);
			CreateCreditEntity_args.Add("AgreementType", AgreementType);
			return F3Formatter.f3_style_serialization("CreateCreditEntity", CreateCreditEntity_args);
		}

		// <summary>
		// Create a valuation specification that selects credit index basis adjusted curves.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCreditIndexBasisAdjustedValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod)
		{

			Hashtable CreateCreditIndexBasisAdjustedValuationSpecification_args = new Hashtable();
			CreateCreditIndexBasisAdjustedValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCreditIndexBasisAdjustedValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			return F3Formatter.f3_style_serialization("CreateCreditIndexBasisAdjustedValuationSpecification", CreateCreditIndexBasisAdjustedValuationSpecification_args);
		}

		// <summary>
		// Create an index that represents accrual on default for a credit index portfolio.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCreditIndexPortfolioAccrualIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateCreditIndexPortfolioAccrualIndex_args = new Hashtable();
			CreateCreditIndexPortfolioAccrualIndex_args.Add("IndexName", IndexName);
			CreateCreditIndexPortfolioAccrualIndex_args.Add("CreditContract", CreditContract);
			CreateCreditIndexPortfolioAccrualIndex_args.Add("Currency", Currency);
			CreateCreditIndexPortfolioAccrualIndex_args.Add("MarketConventions", MarketConventions);
			CreateCreditIndexPortfolioAccrualIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioAccrualIndex", CreateCreditIndexPortfolioAccrualIndex_args);
		}

		// <summary>
		// Define a contract for a credit index based on a pool (or portfolio) of underlying credit entities.
		// </summary>
		// <param name="Name">Name to use for the new contract.</param>
		// <param name="Constituents">The underlying portfolio on which the contract is written.</param>
		// <param name="ContractRate">The premium coupon rate for the index.</param>
		// <param name="AssociatedMaturityDate">Maturity date associated with the contract rate.</param>
		// <param name="WriteDownNotionalOnDefault">Switch for whether the pool notional is written down after defaults. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateCreditIndexPortfolioContract(object Name, object Constituents, object ContractRate, object AssociatedMaturityDate, object WriteDownNotionalOnDefault)
		{

			Hashtable CreateCreditIndexPortfolioContract_args = new Hashtable();
			CreateCreditIndexPortfolioContract_args.Add("Name", Name);
			CreateCreditIndexPortfolioContract_args.Add("Constituents", Constituents);
			CreateCreditIndexPortfolioContract_args.Add("ContractRate", ContractRate);
			CreateCreditIndexPortfolioContract_args.Add("AssociatedMaturityDate", AssociatedMaturityDate);
			CreateCreditIndexPortfolioContract_args.Add("WriteDownNotionalOnDefault", WriteDownNotionalOnDefault);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioContract", CreateCreditIndexPortfolioContract_args);
		}

		// <summary>
		// Create an index that represents recovery from default in a credit index portfolio.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCreditIndexPortfolioDefaultRecoveryIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateCreditIndexPortfolioDefaultRecoveryIndex_args = new Hashtable();
			CreateCreditIndexPortfolioDefaultRecoveryIndex_args.Add("IndexName", IndexName);
			CreateCreditIndexPortfolioDefaultRecoveryIndex_args.Add("CreditContract", CreditContract);
			CreateCreditIndexPortfolioDefaultRecoveryIndex_args.Add("Currency", Currency);
			CreateCreditIndexPortfolioDefaultRecoveryIndex_args.Add("MarketConventions", MarketConventions);
			CreateCreditIndexPortfolioDefaultRecoveryIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioDefaultRecoveryIndex", CreateCreditIndexPortfolioDefaultRecoveryIndex_args);
		}

		// <summary>
		// Create a credit default swap on an index portfolio.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit index portfolio contract.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="PayAccruedInterestUponDefault">Pay accrued interest upon default.</param>
		// <param name="MarketConvention">Market conventions for the premium leg.</param>
		// <param name="DefaultUnityWeight">The weight of the default unity index. Default value: 1.0.</param>
		// <param name="DefaultRecoveryWeight">The weight of the default recovery index. Default value: -1.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <param name="OffsettingMarketConvention">Market conventions for the offsetting leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCreditIndexPortfolioDefaultSwap(object ProductName, object StartDate, object Notional, object Currency, object CreditContract, object UpfrontFee, object PayAccruedInterestUponDefault, object MarketConvention, object DefaultUnityWeight, object DefaultRecoveryWeight,
		object PayRec, object OffsettingMarketConvention)
		{

			Hashtable CreateCreditIndexPortfolioDefaultSwap_args = new Hashtable();
			CreateCreditIndexPortfolioDefaultSwap_args.Add("ProductName", ProductName);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("StartDate", StartDate);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("Notional", Notional);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("Currency", Currency);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("CreditContract", CreditContract);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("PayAccruedInterestUponDefault", PayAccruedInterestUponDefault);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("DefaultUnityWeight", DefaultUnityWeight);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("DefaultRecoveryWeight", DefaultRecoveryWeight);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("PayRec", PayRec);
			CreateCreditIndexPortfolioDefaultSwap_args.Add("OffsettingMarketConvention", OffsettingMarketConvention);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioDefaultSwap", CreateCreditIndexPortfolioDefaultSwap_args);
		}

		// <summary>
		// Create an index that represents default with no recovery in a credit index portfolio.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCreditIndexPortfolioDefaultUnityIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateCreditIndexPortfolioDefaultUnityIndex_args = new Hashtable();
			CreateCreditIndexPortfolioDefaultUnityIndex_args.Add("IndexName", IndexName);
			CreateCreditIndexPortfolioDefaultUnityIndex_args.Add("CreditContract", CreditContract);
			CreateCreditIndexPortfolioDefaultUnityIndex_args.Add("Currency", Currency);
			CreateCreditIndexPortfolioDefaultUnityIndex_args.Add("MarketConventions", MarketConventions);
			CreateCreditIndexPortfolioDefaultUnityIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioDefaultUnityIndex", CreateCreditIndexPortfolioDefaultUnityIndex_args);
		}

		// <summary>
		// Create an index that represents the survival of a credit index portfolio.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateCreditIndexPortfolioSurvivalIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateCreditIndexPortfolioSurvivalIndex_args = new Hashtable();
			CreateCreditIndexPortfolioSurvivalIndex_args.Add("IndexName", IndexName);
			CreateCreditIndexPortfolioSurvivalIndex_args.Add("CreditContract", CreditContract);
			CreateCreditIndexPortfolioSurvivalIndex_args.Add("Currency", Currency);
			CreateCreditIndexPortfolioSurvivalIndex_args.Add("MarketConventions", MarketConventions);
			CreateCreditIndexPortfolioSurvivalIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioSurvivalIndex", CreateCreditIndexPortfolioSurvivalIndex_args);
		}

		// <summary>
		// Create a valuation specification that controls valuation of credit index portfolio trades.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="AsComposite">Flag to indicate whether or not the valuation should be based on the composite survival curve.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCreditIndexPortfolioValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object AsComposite)
		{

			Hashtable CreateCreditIndexPortfolioValuationSpecification_args = new Hashtable();
			CreateCreditIndexPortfolioValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCreditIndexPortfolioValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCreditIndexPortfolioValuationSpecification_args.Add("AsComposite", AsComposite);
			return F3Formatter.f3_style_serialization("CreateCreditIndexPortfolioValuationSpecification", CreateCreditIndexPortfolioValuationSpecification_args);
		}

		// <summary>
		// Define a credit portfolio of weighted entities.
		// </summary>
		// <param name="Name">Name to use for the credit portfolio.</param>
		// <param name="CreditEntities">Vector of credit entities.</param>
		// <param name="Weights">Vector of weights.</param>
		// <param name="UniqueDisplayName">Human-friendly name to identify the portfolio. Default value: default-constructed instance of type credit_portfolio_id.</param>
		// <returns>Retuns the name of the constructed object of type CreditPortfolio.</returns>
		public object CreateCreditPortfolio(object Name, object CreditEntities, object Weights, object UniqueDisplayName)
		{

			Hashtable CreateCreditPortfolio_args = new Hashtable();
			CreateCreditPortfolio_args.Add("Name", Name);
			CreateCreditPortfolio_args.Add("CreditEntities", CreditEntities);
			CreateCreditPortfolio_args.Add("Weights", Weights);
			CreateCreditPortfolio_args.Add("UniqueDisplayName", UniqueDisplayName);
			return F3Formatter.f3_style_serialization("CreateCreditPortfolio", CreateCreditPortfolio_args);
		}

		// <summary>
		// Define a credit contract from a portfolio of underlying credit entities.
		// </summary>
		// <param name="Name">Name to use for the new contract.</param>
		// <param name="Constituents">The underlying portfolio.</param>
		// <param name="WriteDownNotionalOnDefault">Switch for whether the pool notional is written down after defaults. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateCreditPortfolioContract(object Name, object Constituents, object WriteDownNotionalOnDefault)
		{

			Hashtable CreateCreditPortfolioContract_args = new Hashtable();
			CreateCreditPortfolioContract_args.Add("Name", Name);
			CreateCreditPortfolioContract_args.Add("Constituents", Constituents);
			CreateCreditPortfolioContract_args.Add("WriteDownNotionalOnDefault", WriteDownNotionalOnDefault);
			return F3Formatter.f3_style_serialization("CreateCreditPortfolioContract", CreateCreditPortfolioContract_args);
		}

		// <summary>
		// Create a valuation specification that provides a step-in date.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="StepInMaturity">The step-in maturity.</param>
		// <param name="MaturityCalculator">Methodology for calculating the step-in date.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateCreditStepInValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object StepInMaturity, object MaturityCalculator)
		{

			Hashtable CreateCreditStepInValuationSpecification_args = new Hashtable();
			CreateCreditStepInValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateCreditStepInValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateCreditStepInValuationSpecification_args.Add("StepInMaturity", StepInMaturity);
			CreateCreditStepInValuationSpecification_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateCreditStepInValuationSpecification", CreateCreditStepInValuationSpecification_args);
		}

		// <summary>
		// Create a cross-currency swap, with coupon and (optionally) notional flows.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional of the asset currency leg.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies in the swap.</param>
		// <param name="AssetRateIndex">Index describing the rate (fixed or floating) paid by the asset currency leg.</param>
		// <param name="AssetMargin">Margin over the rate paid by the asset currency leg. Default value: 0.0.</param>
		// <param name="MarketConvention">Schedule generator for the numeraire currency leg.</param>
		// <param name="NumeraireRateIndex">Index describing the rate (fixed or floating) paid by the numeraire currency leg.</param>
		// <param name="NumeraireMargin">Margin over the rate paid by the numeraire currency leg. Default value: 0.0.</param>
		// <param name="ContractFXRate">Optional fixed value of one unit of notional in the numeraire currency. Default value: -1.0.</param>
		// <param name="CouponsOnly">Flag to indicate whether notional flows are to be included in the swap.</param>
		// <param name="PayRec">Flag indicating payment or receipt of coupons in the asset currency.</param>
		// <param name="AssetCurrencyLegMarketConventions">Schedule generator for the asset currency leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateCrossCurrencySwap(object ProductName, object StartDate, object Maturity, object Notional, object FXRateIndex, object AssetRateIndex, object AssetMargin, object MarketConvention, object NumeraireRateIndex, object NumeraireMargin,
		object ContractFXRate, object CouponsOnly, object PayRec, object AssetCurrencyLegMarketConventions)
		{

			Hashtable CreateCrossCurrencySwap_args = new Hashtable();
			CreateCrossCurrencySwap_args.Add("ProductName", ProductName);
			CreateCrossCurrencySwap_args.Add("StartDate", StartDate);
			CreateCrossCurrencySwap_args.Add("Maturity", Maturity);
			CreateCrossCurrencySwap_args.Add("Notional", Notional);
			CreateCrossCurrencySwap_args.Add("FXRateIndex", FXRateIndex);
			CreateCrossCurrencySwap_args.Add("AssetRateIndex", AssetRateIndex);
			CreateCrossCurrencySwap_args.Add("AssetMargin", AssetMargin);
			CreateCrossCurrencySwap_args.Add("MarketConvention", MarketConvention);
			CreateCrossCurrencySwap_args.Add("NumeraireRateIndex", NumeraireRateIndex);
			CreateCrossCurrencySwap_args.Add("NumeraireMargin", NumeraireMargin);
			CreateCrossCurrencySwap_args.Add("ContractFXRate", ContractFXRate);
			CreateCrossCurrencySwap_args.Add("CouponsOnly", CouponsOnly);
			CreateCrossCurrencySwap_args.Add("PayRec", PayRec);
			CreateCrossCurrencySwap_args.Add("AssetCurrencyLegMarketConventions", AssetCurrencyLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateCrossCurrencySwap", CreateCrossCurrencySwap_args);
		}

		// <summary>
		// Create an instrument type for a cross-currency swap.
		// </summary>
		// <param name="InstrumentTypeName">Name of instrument type.</param>
		// <param name="FXRateIndex">Index containing the relevant currency pair.</param>
		// <param name="MarginLegRateIndex">Index representing the rate paid on the margin leg.</param>
		// <param name="OffsettingLegRateIndex">Index representing the rate paid on the offsetting leg.</param>
		// <param name="MarketConventions">Schedule generator for the swap.</param>
		// <param name="NotionalAdjustment">Policy for notional adjustment. Default value: None.</param>
		// <param name="OffsettingLegMarketConventions">Schedule generator for the offsetting leg of the swap. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateCrossCurrencySwapInstrumentType(object InstrumentTypeName, object FXRateIndex, object MarginLegRateIndex, object OffsettingLegRateIndex, object MarketConventions, object NotionalAdjustment, object OffsettingLegMarketConventions)
		{

			Hashtable CreateCrossCurrencySwapInstrumentType_args = new Hashtable();
			CreateCrossCurrencySwapInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateCrossCurrencySwapInstrumentType_args.Add("FXRateIndex", FXRateIndex);
			CreateCrossCurrencySwapInstrumentType_args.Add("MarginLegRateIndex", MarginLegRateIndex);
			CreateCrossCurrencySwapInstrumentType_args.Add("OffsettingLegRateIndex", OffsettingLegRateIndex);
			CreateCrossCurrencySwapInstrumentType_args.Add("MarketConventions", MarketConventions);
			CreateCrossCurrencySwapInstrumentType_args.Add("NotionalAdjustment", NotionalAdjustment);
			CreateCrossCurrencySwapInstrumentType_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateCrossCurrencySwapInstrumentType", CreateCrossCurrencySwapInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of cross-currency swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="QuotedMargins">Vector of margins over the margin leg rate index.</param>
		// <param name="FXRateIndex">Index containing the relevant currency pair.</param>
		// <param name="MarginLegRateIndex">Index representing the rate paid on the margin leg.</param>
		// <param name="OffsettingLegRateIndex">Index representing the rate paid on the offsetting leg.</param>
		// <param name="MarketConventions">Schedule generator for the margin leg of the swap.</param>
		// <param name="NotionalAdjustment">Policy for notional adjustment. Default value: None.</param>
		// <param name="QuotesName">Name of the cross-currency swap market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="QuotesType">Type of the cross-currency swap market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <param name="OffsettingLegMarketConventions">Schedule generator for the offsetting leg of the swap. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateCrossCurrencySwapMarketData(object MarketDataSetName, object Maturities, object QuotedMargins, object FXRateIndex, object MarginLegRateIndex, object OffsettingLegRateIndex, object MarketConventions, object NotionalAdjustment, object QuotesName, object QuotesType,
		object QuoteDate, object OffsettingLegMarketConventions)
		{

			Hashtable CreateCrossCurrencySwapMarketData_args = new Hashtable();
			CreateCrossCurrencySwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateCrossCurrencySwapMarketData_args.Add("Maturities", Maturities);
			CreateCrossCurrencySwapMarketData_args.Add("QuotedMargins", QuotedMargins);
			CreateCrossCurrencySwapMarketData_args.Add("FXRateIndex", FXRateIndex);
			CreateCrossCurrencySwapMarketData_args.Add("MarginLegRateIndex", MarginLegRateIndex);
			CreateCrossCurrencySwapMarketData_args.Add("OffsettingLegRateIndex", OffsettingLegRateIndex);
			CreateCrossCurrencySwapMarketData_args.Add("MarketConventions", MarketConventions);
			CreateCrossCurrencySwapMarketData_args.Add("NotionalAdjustment", NotionalAdjustment);
			CreateCrossCurrencySwapMarketData_args.Add("QuotesName", QuotesName);
			CreateCrossCurrencySwapMarketData_args.Add("QuotesType", QuotesType);
			CreateCrossCurrencySwapMarketData_args.Add("QuoteDate", QuoteDate);
			CreateCrossCurrencySwapMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateCrossCurrencySwapMarketData", CreateCrossCurrencySwapMarketData_args);
		}

		// <summary>
		// Create a cumulative chi-square distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="KValue">Number of degrees of freedom.</param>
		// <param name="KParameterTag">Tag to use for the k value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateCumulativeChiSquareFunction(object FunctionName, object KValue, object KParameterTag)
		{

			Hashtable CreateCumulativeChiSquareFunction_args = new Hashtable();
			CreateCumulativeChiSquareFunction_args.Add("FunctionName", FunctionName);
			CreateCumulativeChiSquareFunction_args.Add("KValue", KValue);
			CreateCumulativeChiSquareFunction_args.Add("KParameterTag", KParameterTag);
			return F3Formatter.f3_style_serialization("CreateCumulativeChiSquareFunction", CreateCumulativeChiSquareFunction_args);
		}

		// <summary>
		// Create the corresponding cumulative distribution function for a characteristic function using discrete fast Fourier transform.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="CharFunc">The characteristic function.</param>
		// <param name="LowerLimit">Lower limit of the abscissa for the cumulative distribution function.</param>
		// <param name="UpperLimit">Upper limit of the abscissa for the cumulative distribution function.</param>
		// <param name="NumberOfPoints">Number of points of the abscissa for the cumulative distribution function.</param>
		// <param name="InterpolationMethod">Interpolation method to use for the cumulative distribution function. Default value: Linear.</param>
		// <param name="FFTMaxNumberOfSteps">Maximum number of steps to use in the fast Fourier transform. Default value: 0.</param>
		// <param name="FFTScale">Scaling factor applied to the critical frequency in the fast Fourier transform. Default value: 1.0.</param>
		// <param name="FFTTolerance">Tolerance to use in the determination of the cutoff frequency in the fast Fourier transform. Default value: 0.0.</param>
		// <param name="Tolerance">Tolerance on the imaginary part of the cumulative distribution function. Default value: 0.001.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateCumulativeDistributionFunctionFromCharacteristicFunction(object FunctionName, object CharFunc, object LowerLimit, object UpperLimit, object NumberOfPoints, object InterpolationMethod, object FFTMaxNumberOfSteps, object FFTScale, object FFTTolerance, object Tolerance)
		{

			Hashtable CreateCumulativeDistributionFunctionFromCharacteristicFunction_args = new Hashtable();
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("FunctionName", FunctionName);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("CharFunc", CharFunc);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("LowerLimit", LowerLimit);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("UpperLimit", UpperLimit);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("NumberOfPoints", NumberOfPoints);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("InterpolationMethod", InterpolationMethod);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("FFTMaxNumberOfSteps", FFTMaxNumberOfSteps);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("FFTScale", FFTScale);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("FFTTolerance", FFTTolerance);
			CreateCumulativeDistributionFunctionFromCharacteristicFunction_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreateCumulativeDistributionFunctionFromCharacteristicFunction", CreateCumulativeDistributionFunctionFromCharacteristicFunction_args);
		}

		// <summary>
		// Create a cumulative non-central chi-square distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="KValue">Number of degrees of freedom.</param>
		// <param name="NuValue">Non-centrality parameter.</param>
		// <param name="KParameterTag">Tag to use for the k value.</param>
		// <param name="NuParameterTag">Tag to use for the nu value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateCumulativeNonCentralChiSquareFunction(object FunctionName, object KValue, object NuValue, object KParameterTag, object NuParameterTag)
		{

			Hashtable CreateCumulativeNonCentralChiSquareFunction_args = new Hashtable();
			CreateCumulativeNonCentralChiSquareFunction_args.Add("FunctionName", FunctionName);
			CreateCumulativeNonCentralChiSquareFunction_args.Add("KValue", KValue);
			CreateCumulativeNonCentralChiSquareFunction_args.Add("NuValue", NuValue);
			CreateCumulativeNonCentralChiSquareFunction_args.Add("KParameterTag", KParameterTag);
			CreateCumulativeNonCentralChiSquareFunction_args.Add("NuParameterTag", NuParameterTag);
			return F3Formatter.f3_style_serialization("CreateCumulativeNonCentralChiSquareFunction", CreateCumulativeNonCentralChiSquareFunction_args);
		}

		// <summary>
		// Create a cumulative normal distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="MuValue">Value of mean.</param>
		// <param name="SigmaValue">Value of standard deviation.</param>
		// <param name="MuParameterTag">Tag to use for the mu value.</param>
		// <param name="SigmaParameterTag">Tag to use for the sigma value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateCumulativeNormalFunction(object FunctionName, object MuValue, object SigmaValue, object MuParameterTag, object SigmaParameterTag)
		{

			Hashtable CreateCumulativeNormalFunction_args = new Hashtable();
			CreateCumulativeNormalFunction_args.Add("FunctionName", FunctionName);
			CreateCumulativeNormalFunction_args.Add("MuValue", MuValue);
			CreateCumulativeNormalFunction_args.Add("SigmaValue", SigmaValue);
			CreateCumulativeNormalFunction_args.Add("MuParameterTag", MuParameterTag);
			CreateCumulativeNormalFunction_args.Add("SigmaParameterTag", SigmaParameterTag);
			return F3Formatter.f3_style_serialization("CreateCumulativeNormalFunction", CreateCumulativeNormalFunction_args);
		}

		// <summary>
		// Create a valuation specification builder for curve tag replacement.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="SourceCurveTag">Curve tag to be replaced.</param>
		// <param name="ReplacementCurveTag">New curve tag to use.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateCurveTagReplacementValuationSpecificationBuilder(object BuilderName, object SourceCurveTag, object ReplacementCurveTag)
		{

			Hashtable CreateCurveTagReplacementValuationSpecificationBuilder_args = new Hashtable();
			CreateCurveTagReplacementValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateCurveTagReplacementValuationSpecificationBuilder_args.Add("SourceCurveTag", SourceCurveTag);
			CreateCurveTagReplacementValuationSpecificationBuilder_args.Add("ReplacementCurveTag", ReplacementCurveTag);
			return F3Formatter.f3_style_serialization("CreateCurveTagReplacementValuationSpecificationBuilder", CreateCurveTagReplacementValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a product whose value is equal to the debt value adjustment for the underlying product or portfolio of products.
		// </summary>
		// <param name="ProductName">Name to use for product.</param>
		// <param name="UnderlyingProduct">Product for which counterparty risk is being calculated.</param>
		// <param name="StartDate">Start date for which counterparty default is being considered.</param>
		// <param name="CreditIndex">Loss given default index for the counterparty.</param>
		// <param name="SamplingStrategy">Strategy for generation of sampling dates.</param>
		// <param name="CollateralizationRules">Rules governing the posting of collateral by the counterparty. Default value: default-constructed instance of type collateral_agreement.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateDVAProduct(object ProductName, object UnderlyingProduct, object StartDate, object CreditIndex, object SamplingStrategy, object CollateralizationRules)
		{

			Hashtable CreateDVAProduct_args = new Hashtable();
			CreateDVAProduct_args.Add("ProductName", ProductName);
			CreateDVAProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateDVAProduct_args.Add("StartDate", StartDate);
			CreateDVAProduct_args.Add("CreditIndex", CreditIndex);
			CreateDVAProduct_args.Add("SamplingStrategy", SamplingStrategy);
			CreateDVAProduct_args.Add("CollateralizationRules", CollateralizationRules);
			return F3Formatter.f3_style_serialization("CreateDVAProduct", CreateDVAProduct_args);
		}

		// <summary>
		// Create a connection to a Data Synapse Grid.
		// </summary>
		// <param name="ConnectionName">Name to use for connection.</param>
		// <param name="SoapURL">The F3 SOAP service URL.</param>
		// <param name="UserName">The username for this connection.</param>
		// <param name="Password">The password for this connection.</param>
		// <returns>Retuns the name of the constructed object of type RemoteExecutorSource.</returns>
		public object CreateDataSynapseGridConnection(object ConnectionName, object SoapURL, object UserName, object Password)
		{

			Hashtable CreateDataSynapseGridConnection_args = new Hashtable();
			CreateDataSynapseGridConnection_args.Add("ConnectionName", ConnectionName);
			CreateDataSynapseGridConnection_args.Add("SoapURL", SoapURL);
			CreateDataSynapseGridConnection_args.Add("UserName", UserName);
			CreateDataSynapseGridConnection_args.Add("Password", Password);
			return F3Formatter.f3_style_serialization("CreateDataSynapseGridConnection", CreateDataSynapseGridConnection_args);
		}

		// <summary>
		// Create a date-level-value market data set.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="DateValueName">Name to use for the date-value-loss data.</param>
		// <param name="DateValueType">Type name for the date-value-loss market data.</param>
		// <param name="Maturities">Vector of maturity descriptors.</param>
		// <param name="Levels">Vector of levels.</param>
		// <param name="Quotes">Matrix of quotes.</param>
		// <param name="MarketConventions">Market conventions for maturities.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateDateLevelValueMarketData(object MarketDataSetName, object DateValueName, object DateValueType, object Maturities, object Levels, object Quotes, object MarketConventions)
		{

			Hashtable CreateDateLevelValueMarketData_args = new Hashtable();
			CreateDateLevelValueMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateDateLevelValueMarketData_args.Add("DateValueName", DateValueName);
			CreateDateLevelValueMarketData_args.Add("DateValueType", DateValueType);
			CreateDateLevelValueMarketData_args.Add("Maturities", Maturities);
			CreateDateLevelValueMarketData_args.Add("Levels", Levels);
			CreateDateLevelValueMarketData_args.Add("Quotes", Quotes);
			CreateDateLevelValueMarketData_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateDateLevelValueMarketData", CreateDateLevelValueMarketData_args);
		}

		// <summary>
		// Create an index referencer from an underlying referencer and a date modifer.
		// </summary>
		// <param name="ReferencerName">Name to use for referencer.</param>
		// <param name="UnderlyingReferencer">Underlying index referencer.</param>
		// <param name="DateModifier">Date modifier to apply to underlying reference point.</param>
		// <returns>Retuns the name of the constructed object of type IndexReferencer.</returns>
		public object CreateDateModifierIndexReferencer(object ReferencerName, object UnderlyingReferencer, object DateModifier)
		{

			Hashtable CreateDateModifierIndexReferencer_args = new Hashtable();
			CreateDateModifierIndexReferencer_args.Add("ReferencerName", ReferencerName);
			CreateDateModifierIndexReferencer_args.Add("UnderlyingReferencer", UnderlyingReferencer);
			CreateDateModifierIndexReferencer_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("CreateDateModifierIndexReferencer", CreateDateModifierIndexReferencer_args);
		}

		// <summary>
		// Create a bond settlement convention.
		// </summary>
		// <param name="ConventionName">Name to use for the created settlement convention.</param>
		// <param name="SettlementModifier">Date modifier to determine the settlement date.</param>
		// <param name="EntitlementModifier">Date modifier to determine the coupon entitlement date. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type SettlementConvention.</returns>
		public object CreateDateModifierSettlementConvention(object ConventionName, object SettlementModifier, object EntitlementModifier)
		{

			Hashtable CreateDateModifierSettlementConvention_args = new Hashtable();
			CreateDateModifierSettlementConvention_args.Add("ConventionName", ConventionName);
			CreateDateModifierSettlementConvention_args.Add("SettlementModifier", SettlementModifier);
			CreateDateModifierSettlementConvention_args.Add("EntitlementModifier", EntitlementModifier);
			return F3Formatter.f3_style_serialization("CreateDateModifierSettlementConvention", CreateDateModifierSettlementConvention_args);
		}

		// <summary>
		// Form a product as a subset of the flows and conditions of an underlying product.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="UnderlyingProduct">The underlying product.</param>
		// <param name="StartDate">First date for inclusion in the formed product. Default value: default-constructed instance of type date.</param>
		// <param name="DayAfterEndDate">First date after the last date for inclusion in the formed product. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateDateRestrictedProduct(object ProductName, object UnderlyingProduct, object StartDate, object DayAfterEndDate)
		{

			Hashtable CreateDateRestrictedProduct_args = new Hashtable();
			CreateDateRestrictedProduct_args.Add("ProductName", ProductName);
			CreateDateRestrictedProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateDateRestrictedProduct_args.Add("StartDate", StartDate);
			CreateDateRestrictedProduct_args.Add("DayAfterEndDate", DayAfterEndDate);
			return F3Formatter.f3_style_serialization("CreateDateRestrictedProduct", CreateDateRestrictedProduct_args);
		}

		// <summary>
		// Create a date-value pair market data set.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="DateValueName">Name to use for date-value pairs.</param>
		// <param name="DateValueType">Type name for the date-value pairs market data.</param>
		// <param name="Maturities">Vector of maturity descriptors.</param>
		// <param name="Values">Vector of values.</param>
		// <param name="MarketConventions">Market conventions for maturities.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateDateValueMarketData(object MarketDataSetName, object DateValueName, object DateValueType, object Maturities, object Values, object MarketConventions)
		{

			Hashtable CreateDateValueMarketData_args = new Hashtable();
			CreateDateValueMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateDateValueMarketData_args.Add("DateValueName", DateValueName);
			CreateDateValueMarketData_args.Add("DateValueType", DateValueType);
			CreateDateValueMarketData_args.Add("Maturities", Maturities);
			CreateDateValueMarketData_args.Add("Values", Values);
			CreateDateValueMarketData_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateDateValueMarketData", CreateDateValueMarketData_args);
		}

		// <summary>
		// Create a time calculator.
		// </summary>
		// <param name="TimeCalculatorName">Name to use for the time calculator.</param>
		// <param name="DayCountType">Day Count convention to use.</param>
		// <returns>Retuns the name of the constructed object of type TimeCalculator.</returns>
		public object CreateDaysTimeCalculator(object TimeCalculatorName, object DayCountType)
		{

			Hashtable CreateDaysTimeCalculator_args = new Hashtable();
			CreateDaysTimeCalculator_args.Add("TimeCalculatorName", TimeCalculatorName);
			CreateDaysTimeCalculator_args.Add("DayCountType", DayCountType);
			return F3Formatter.f3_style_serialization("CreateDaysTimeCalculator", CreateDaysTimeCalculator_args);
		}

		// <summary>
		// Create a callback function that just pauses for a period of time.
		// </summary>
		// <param name="CallbackName">Name to use for callback.</param>
		// <param name="Delay">Delay in seconds.</param>
		// <returns>Retuns the name of the constructed object of type Callback.</returns>
		public object CreateDelayCallback(object CallbackName, object Delay)
		{

			Hashtable CreateDelayCallback_args = new Hashtable();
			CreateDelayCallback_args.Add("CallbackName", CallbackName);
			CreateDelayCallback_args.Add("Delay", Delay);
			return F3Formatter.f3_style_serialization("CreateDelayCallback", CreateDelayCallback_args);
		}

		// <summary>
		// Create a holiday convention from the difference of two other holiday conventions.
		// </summary>
		// <param name="HolidayConventionName">Name to use for the new holiday convention.</param>
		// <param name="FirstHolidayConventions">First set of underlying holiday conventions to use.</param>
		// <param name="SecondHolidayConventions">Second set of underlying holiday conventions to use.</param>
		// <returns>Retuns the name of the constructed object of type HolidayConvention.</returns>
		public object CreateDifferenceHolidayConvention(object HolidayConventionName, object FirstHolidayConventions, object SecondHolidayConventions)
		{

			Hashtable CreateDifferenceHolidayConvention_args = new Hashtable();
			CreateDifferenceHolidayConvention_args.Add("HolidayConventionName", HolidayConventionName);
			CreateDifferenceHolidayConvention_args.Add("FirstHolidayConventions", FirstHolidayConventions);
			CreateDifferenceHolidayConvention_args.Add("SecondHolidayConventions", SecondHolidayConventions);
			return F3Formatter.f3_style_serialization("CreateDifferenceHolidayConvention", CreateDifferenceHolidayConvention_args);
		}

		// <summary>
		// Create a function that is the derivative of a two-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Differand">Two-dimensional function to be differentiated.</param>
		// <param name="DiffMethod">Differentiation method to use.</param>
		// <param name="WithRespectToSecondArgument">Boolean flag set to true when differentiating       with respect to the second argument.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateDifferentiated2dFunction(object FunctionName, object Differand, object DiffMethod, object WithRespectToSecondArgument)
		{

			Hashtable CreateDifferentiated2dFunction_args = new Hashtable();
			CreateDifferentiated2dFunction_args.Add("FunctionName", FunctionName);
			CreateDifferentiated2dFunction_args.Add("Differand", Differand);
			CreateDifferentiated2dFunction_args.Add("DiffMethod", DiffMethod);
			CreateDifferentiated2dFunction_args.Add("WithRespectToSecondArgument", WithRespectToSecondArgument);
			return F3Formatter.f3_style_serialization("CreateDifferentiated2dFunction", CreateDifferentiated2dFunction_args);
		}

		// <summary>
		// Create a function that returns the numerical derivative of another.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Differand">One-dimensional function to be differentiated.</param>
		// <param name="Method">The strategy to employ for evaluation of the derivative.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateDifferentiatedFunction(object FunctionName, object Differand, object Method)
		{

			Hashtable CreateDifferentiatedFunction_args = new Hashtable();
			CreateDifferentiatedFunction_args.Add("FunctionName", FunctionName);
			CreateDifferentiatedFunction_args.Add("Differand", Differand);
			CreateDifferentiatedFunction_args.Add("Method", Method);
			return F3Formatter.f3_style_serialization("CreateDifferentiatedFunction", CreateDifferentiatedFunction_args);
		}

		// <summary>
		// Create a generator that chooses one from a pair, based on dimensionality.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="FirstGenerator">First candidate generator.</param>
		// <param name="SecondGenerator">Second candidate generator.</param>
		// <param name="DimensionLimit">Dimensionality limit.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreateDimensionalityBasedSwitchingGenerator(object GeneratorName, object FirstGenerator, object SecondGenerator, object DimensionLimit)
		{

			Hashtable CreateDimensionalityBasedSwitchingGenerator_args = new Hashtable();
			CreateDimensionalityBasedSwitchingGenerator_args.Add("GeneratorName", GeneratorName);
			CreateDimensionalityBasedSwitchingGenerator_args.Add("FirstGenerator", FirstGenerator);
			CreateDimensionalityBasedSwitchingGenerator_args.Add("SecondGenerator", SecondGenerator);
			CreateDimensionalityBasedSwitchingGenerator_args.Add("DimensionLimit", DimensionLimit);
			return F3Formatter.f3_style_serialization("CreateDimensionalityBasedSwitchingGenerator", CreateDimensionalityBasedSwitchingGenerator_args);
		}

		// <summary>
		// Create a market data set from a collection of user supplied correlation matrices or factor loadings for use in hybrid simulations.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="TimePoints">Time points associated with the correlation matrices or factor loadings.</param>
		// <param name="CorrelationMatrices">Correlation matrices or factor loadings.</param>
		// <param name="NamedStateVariableTemplates">Indices and the corresponding mathematical models for which the correlation matrices or factor loadings are applied.</param>
		// <param name="CorrelationName">Name to use for the correlation market data.</param>
		// <param name="CorrelationType">Type name for the correlation market data.</param>
		// <param name="CorrelationSpecification">Method specifying how the input matrices are used to generate correlated random numbers. Default value: Cholesky.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateDirectHybridModelingCorrelationMatricesMarketData(object MarketDataSetName, object TimePoints, object CorrelationMatrices, object NamedStateVariableTemplates, object CorrelationName, object CorrelationType, object CorrelationSpecification)
		{

			Hashtable CreateDirectHybridModelingCorrelationMatricesMarketData_args = new Hashtable();
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("TimePoints", TimePoints);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("CorrelationMatrices", CorrelationMatrices);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("NamedStateVariableTemplates", NamedStateVariableTemplates);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("CorrelationName", CorrelationName);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("CorrelationType", CorrelationType);
			CreateDirectHybridModelingCorrelationMatricesMarketData_args.Add("CorrelationSpecification", CorrelationSpecification);
			return F3Formatter.f3_style_serialization("CreateDirectHybridModelingCorrelationMatricesMarketData", CreateDirectHybridModelingCorrelationMatricesMarketData_args);
		}

		// <summary>
		// Create a yield convention which calculates the discount margin for a bond.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="UnderlyingIndex">The index against which the discount margin is computed.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateDiscountMarginYieldConvention(object YieldConventionName, object UnderlyingIndex)
		{

			Hashtable CreateDiscountMarginYieldConvention_args = new Hashtable();
			CreateDiscountMarginYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateDiscountMarginYieldConvention_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("CreateDiscountMarginYieldConvention", CreateDiscountMarginYieldConvention_args);
		}

		// <summary>
		// Create a strategy that can be used to distribute N tasks.
		// </summary>
		// <param name="StrategyName">The name to use for this strategy.</param>
		// <param name="ExecutorName">The executor for this strategy.</param>
		// <param name="MaxNumberOfTasks">Maximum number of simultaneous tasks.</param>
		// <returns>Retuns the name of the constructed object of type CalculationStrategy.</returns>
		public object CreateDistributedCalculationStrategy(object StrategyName, object ExecutorName, object MaxNumberOfTasks)
		{

			Hashtable CreateDistributedCalculationStrategy_args = new Hashtable();
			CreateDistributedCalculationStrategy_args.Add("StrategyName", StrategyName);
			CreateDistributedCalculationStrategy_args.Add("ExecutorName", ExecutorName);
			CreateDistributedCalculationStrategy_args.Add("MaxNumberOfTasks", MaxNumberOfTasks);
			return F3Formatter.f3_style_serialization("CreateDistributedCalculationStrategy", CreateDistributedCalculationStrategy_args);
		}

		// <summary>
		// Create a double barrier European option on an underlying index.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Underlying">Underlying on which the option is written.</param>
		// <param name="Start">Start time point of the barrier observation period of the underlying.</param>
		// <param name="Expiry">Expiry of the option and end time point of the barrier observation period.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="LowerBarrier">Lower barrier level.</param>
		// <param name="UpperBarrier">Upper barrier level.</param>
		// <param name="InOrOut">Knock-in or knock-out.</param>
		// <param name="BarrierObservation">Specification for when the underlying is to be observed.</param>
		// <param name="Strike">Strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateDoubleBarrierEuropeanOption(object ProductName, object Underlying, object Start, object Expiry, object Notional, object LowerBarrier, object UpperBarrier, object InOrOut, object BarrierObservation, object Strike,
		object Payoff, object BuySell)
		{

			Hashtable CreateDoubleBarrierEuropeanOption_args = new Hashtable();
			CreateDoubleBarrierEuropeanOption_args.Add("ProductName", ProductName);
			CreateDoubleBarrierEuropeanOption_args.Add("Underlying", Underlying);
			CreateDoubleBarrierEuropeanOption_args.Add("Start", Start);
			CreateDoubleBarrierEuropeanOption_args.Add("Expiry", Expiry);
			CreateDoubleBarrierEuropeanOption_args.Add("Notional", Notional);
			CreateDoubleBarrierEuropeanOption_args.Add("LowerBarrier", LowerBarrier);
			CreateDoubleBarrierEuropeanOption_args.Add("UpperBarrier", UpperBarrier);
			CreateDoubleBarrierEuropeanOption_args.Add("InOrOut", InOrOut);
			CreateDoubleBarrierEuropeanOption_args.Add("BarrierObservation", BarrierObservation);
			CreateDoubleBarrierEuropeanOption_args.Add("Strike", Strike);
			CreateDoubleBarrierEuropeanOption_args.Add("Payoff", Payoff);
			CreateDoubleBarrierEuropeanOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateDoubleBarrierEuropeanOption", CreateDoubleBarrierEuropeanOption_args);
		}

		// <summary>
		// Form an index which indicates whether a double barrier is breached.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="LowerBarrier">Lower barrier level.</param>
		// <param name="UpperBarrier">Upper barrier level.</param>
		// <param name="InOrOut">Knock-in or knock-out.</param>
		// <param name="ObservationSpec">Specification for when the underlying is to be observed.</param>
		// <param name="Referencer">Rule for defining the observation period. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateDoubleBarrierIndex(object IndexName, object UnderlyingIndex, object LowerBarrier, object UpperBarrier, object InOrOut, object ObservationSpec, object Referencer)
		{

			Hashtable CreateDoubleBarrierIndex_args = new Hashtable();
			CreateDoubleBarrierIndex_args.Add("IndexName", IndexName);
			CreateDoubleBarrierIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateDoubleBarrierIndex_args.Add("LowerBarrier", LowerBarrier);
			CreateDoubleBarrierIndex_args.Add("UpperBarrier", UpperBarrier);
			CreateDoubleBarrierIndex_args.Add("InOrOut", InOrOut);
			CreateDoubleBarrierIndex_args.Add("ObservationSpec", ObservationSpec);
			CreateDoubleBarrierIndex_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateDoubleBarrierIndex", CreateDoubleBarrierIndex_args);
		}

		// <summary>
		// Create a backward evolution operator for performing a single backward induction step in the Fourier space for double knock-out options.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="Strike">Strike price.</param>
		// <param name="UpperBarrier">Upper barrier level.</param>
		// <param name="LowerBarrier">Lower barrier level.</param>
		// <param name="StrikeParameterTag">Tag to use for the strike price.</param>
		// <param name="UpperBarrierParameterTag">Tag to use for the upper barrier level.</param>
		// <param name="LowerBarrierParameterTag">Tag to use for the lower barrier level.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator(object OperatorName, object Strike, object UpperBarrier, object LowerBarrier, object StrikeParameterTag, object UpperBarrierParameterTag, object LowerBarrierParameterTag)
		{

			Hashtable CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args = new Hashtable();
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("OperatorName", OperatorName);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("Strike", Strike);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("UpperBarrier", UpperBarrier);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("LowerBarrier", LowerBarrier);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("StrikeParameterTag", StrikeParameterTag);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("UpperBarrierParameterTag", UpperBarrierParameterTag);
			CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("LowerBarrierParameterTag", LowerBarrierParameterTag);
			return F3Formatter.f3_style_serialization("CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator", CreateDoubleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args);
		}

		// <summary>
		// Create a simulation function template for the simulaton of a double barrier.
		// </summary>
		// <param name="SimulationFunctionTemplate">Name to use for the simulation function template.</param>
		// <param name="MarketConvention">Market convention used in the simulation of a derived index.</param>
		// <param name="DateListBuilder">Rule for determining observation dates from a roll schedule.</param>
		// <returns>Retuns the name of the constructed object of type SimulationFunctions.</returns>
		public object CreateDoubleBarrierSimulationFunctionTemplate(object SimulationFunctionTemplate, object MarketConvention, object DateListBuilder)
		{

			Hashtable CreateDoubleBarrierSimulationFunctionTemplate_args = new Hashtable();
			CreateDoubleBarrierSimulationFunctionTemplate_args.Add("SimulationFunctionTemplate", SimulationFunctionTemplate);
			CreateDoubleBarrierSimulationFunctionTemplate_args.Add("MarketConvention", MarketConvention);
			CreateDoubleBarrierSimulationFunctionTemplate_args.Add("DateListBuilder", DateListBuilder);
			return F3Formatter.f3_style_serialization("CreateDoubleBarrierSimulationFunctionTemplate", CreateDoubleBarrierSimulationFunctionTemplate_args);
		}

		// <summary>
		// Create a modifier whose outputs are two correlated asset paths.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="BlackVolatilityFunctionA">Black volatility function for first asset.</param>
		// <param name="BlackVolatilityFunctionB">Black volatility function for second asset.</param>
		// <param name="InterAssetCorrelationFunction">Inter-asset correlation between the assets.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateDualImpliedBlackCorrelatedPathModifier(object ModifierName, object TimePoints, object BlackVolatilityFunctionA, object BlackVolatilityFunctionB, object InterAssetCorrelationFunction)
		{

			Hashtable CreateDualImpliedBlackCorrelatedPathModifier_args = new Hashtable();
			CreateDualImpliedBlackCorrelatedPathModifier_args.Add("ModifierName", ModifierName);
			CreateDualImpliedBlackCorrelatedPathModifier_args.Add("TimePoints", TimePoints);
			CreateDualImpliedBlackCorrelatedPathModifier_args.Add("BlackVolatilityFunctionA", BlackVolatilityFunctionA);
			CreateDualImpliedBlackCorrelatedPathModifier_args.Add("BlackVolatilityFunctionB", BlackVolatilityFunctionB);
			CreateDualImpliedBlackCorrelatedPathModifier_args.Add("InterAssetCorrelationFunction", InterAssetCorrelationFunction);
			return F3Formatter.f3_style_serialization("CreateDualImpliedBlackCorrelatedPathModifier", CreateDualImpliedBlackCorrelatedPathModifier_args);
		}

		// <summary>
		// Create a modifier whose outputs are two asset paths, correlated based on the input values.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Correlations">Vector of values for the correlation between the paths.</param>
		// <param name="CorrelationParameterTag">Tag to use for the correlation parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateDualPathCorrelatedModifier(object ModifierName, object Correlations, object CorrelationParameterTag)
		{

			Hashtable CreateDualPathCorrelatedModifier_args = new Hashtable();
			CreateDualPathCorrelatedModifier_args.Add("ModifierName", ModifierName);
			CreateDualPathCorrelatedModifier_args.Add("Correlations", Correlations);
			CreateDualPathCorrelatedModifier_args.Add("CorrelationParameterTag", CorrelationParameterTag);
			return F3Formatter.f3_style_serialization("CreateDualPathCorrelatedModifier", CreateDualPathCorrelatedModifier_args);
		}

		// <summary>
		// Create a state variables template that models a price-like process with stochastic funding modeled by a rate-like process.
		// </summary>
		// <param name="DualStateVariablesTemplateName">Name to use for the dual state variables template.</param>
		// <param name="PriceLikeTemplate">Price-like template.</param>
		// <param name="RateLikeTemplate">Rate-like template for stochastic funding.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateDualStateVariablesTemplate(object DualStateVariablesTemplateName, object PriceLikeTemplate, object RateLikeTemplate)
		{

			Hashtable CreateDualStateVariablesTemplate_args = new Hashtable();
			CreateDualStateVariablesTemplate_args.Add("DualStateVariablesTemplateName", DualStateVariablesTemplateName);
			CreateDualStateVariablesTemplate_args.Add("PriceLikeTemplate", PriceLikeTemplate);
			CreateDualStateVariablesTemplate_args.Add("RateLikeTemplate", RateLikeTemplate);
			return F3Formatter.f3_style_serialization("CreateDualStateVariablesTemplate", CreateDualStateVariablesTemplate_args);
		}

		// <summary>
		// Create a two-dimensional Dupire local volatility surface.
		// </summary>
		// <param name="Function">Name to use for the function.</param>
		// <param name="Volatility">Volatility specification for the option.</param>
		// <param name="Forward">Forward value of the underlying asset.</param>
		// <param name="TimeDifferentiationMethod">Differentiation method for the time derivative. Default value: <s>2.74e-3</s><s>2.74e-3</s><s>FALSE</s>.</param>
		// <param name="PriceDifferentiationMethod">Differentiation method for the price derivative. Default value: <s>1e-4</s><s>1e-4</s><s>TRUE</s>.</param>
		// <param name="SmoothingStrategy">Smoothing strategy specifying the value of local volatility when its square is negative. Default value: <s>-1e+8</s><s>0</s>.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateDupireLocalVolatilityFunction(object Function_name, object Volatility, object Forward, object TimeDifferentiationMethod, object PriceDifferentiationMethod, object SmoothingStrategy)
		{

			Hashtable CreateDupireLocalVolatilityFunction_args = new Hashtable();
			CreateDupireLocalVolatilityFunction_args.Add("Function", Function_name);
			CreateDupireLocalVolatilityFunction_args.Add("Volatility", Volatility);
			CreateDupireLocalVolatilityFunction_args.Add("Forward", Forward);
			CreateDupireLocalVolatilityFunction_args.Add("TimeDifferentiationMethod", TimeDifferentiationMethod);
			CreateDupireLocalVolatilityFunction_args.Add("PriceDifferentiationMethod", PriceDifferentiationMethod);
			CreateDupireLocalVolatilityFunction_args.Add("SmoothingStrategy", SmoothingStrategy);
			return F3Formatter.f3_style_serialization("CreateDupireLocalVolatilityFunction", CreateDupireLocalVolatilityFunction_args);
		}

		// <summary>
		// Create a model from another model, which differs only by a ValuationDate.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="NewValuationDate">New Valuation Date.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object CreateDuplicateModelWithNewValuationDate(object ModelName, object BaseModel, object NewValuationDate)
		{

			Hashtable CreateDuplicateModelWithNewValuationDate_args = new Hashtable();
			CreateDuplicateModelWithNewValuationDate_args.Add("ModelName", ModelName);
			CreateDuplicateModelWithNewValuationDate_args.Add("BaseModel", BaseModel);
			CreateDuplicateModelWithNewValuationDate_args.Add("NewValuationDate", NewValuationDate);
			return F3Formatter.f3_style_serialization("CreateDuplicateModelWithNewValuationDate", CreateDuplicateModelWithNewValuationDate_args);
		}

		// <summary>
		// Create an object by copying an existing object.
		// </summary>
		// <param name="NewObjectName">Name of newly created object.</param>
		// <param name="SourceObjectType">Repository to which the source object belongs.</param>
		// <param name="SourceObjectName">Name of source object.</param>
		// <returns>Retuns the name of the constructed object of type <Dynamic>.</returns>
		public object CreateDuplicateObject(object NewObjectName, object SourceObjectType, object SourceObjectName)
		{

			Hashtable CreateDuplicateObject_args = new Hashtable();
			CreateDuplicateObject_args.Add("NewObjectName", NewObjectName);
			CreateDuplicateObject_args.Add("SourceObjectType", SourceObjectType);
			CreateDuplicateObject_args.Add("SourceObjectName", SourceObjectName);
			return F3Formatter.f3_style_serialization("CreateDuplicateObject", CreateDuplicateObject_args);
		}

		// <summary>
		// Create a function object as a set of function calls.
		// </summary>
		// <param name="FunctionName">Name of function.</param>
		// <param name="Parameters">Array of argument descriptions.</param>
		// <param name="FunctionCalls">Array of function calls.</param>
		// <param name="Callback">Callback function to invoke on registration. Default value: NullCallback.</param>
		// <param name="Description">Function description. Default value: Dynamically created function.</param>
		// <param name="DetailedDescription">Function detailed description. Default value: Dynamically created function.</param>
		// <param name="ResultType">Type of value returned by the function.</param>
		// <param name="IsDeprecated">Whether or not function is deprecated. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type Function.</returns>
		public object CreateDynamicFunction(object FunctionName, object Parameters, object FunctionCalls, object Callback, object Description, object DetailedDescription, object ResultType, object IsDeprecated)
		{

			Hashtable CreateDynamicFunction_args = new Hashtable();
			CreateDynamicFunction_args.Add("FunctionName", FunctionName);
			CreateDynamicFunction_args.Add("Parameters", Parameters);
			CreateDynamicFunction_args.Add("FunctionCalls", FunctionCalls);
			CreateDynamicFunction_args.Add("Callback", Callback);
			CreateDynamicFunction_args.Add("Description", Description);
			CreateDynamicFunction_args.Add("DetailedDescription", DetailedDescription);
			CreateDynamicFunction_args.Add("ResultType", ResultType);
			CreateDynamicFunction_args.Add("IsDeprecated", IsDeprecated);
			return F3Formatter.f3_style_serialization("CreateDynamicFunction", CreateDynamicFunction_args);
		}

		// <summary>
		// Create a function object defined by Python code driving the Framework's public API.
		// </summary>
		// <param name="FunctionName">Name of function.</param>
		// <param name="PythonCode">Python code specifying the interface and implementation of the function.</param>
		// <param name="Callback">Callback function to invoke on registration. Default value: NullCallback.</param>
		// <param name="Provenance">Information describing the origin of this function. Default value: default-constructed instance of type named_objects.</param>
		// <returns>Retuns the name of the constructed object of type Function.</returns>
		public object CreateDynamicPythonFunction(object FunctionName, object PythonCode, object Callback, object Provenance)
		{

			Hashtable CreateDynamicPythonFunction_args = new Hashtable();
			CreateDynamicPythonFunction_args.Add("FunctionName", FunctionName);
			CreateDynamicPythonFunction_args.Add("PythonCode", PythonCode);
			CreateDynamicPythonFunction_args.Add("Callback", Callback);
			CreateDynamicPythonFunction_args.Add("Provenance", Provenance);
			return F3Formatter.f3_style_serialization("CreateDynamicPythonFunction", CreateDynamicPythonFunction_args);
		}

		// <summary>
		// Create a date modifier that finds the earliest trade date for a start date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="MarketConventions">Market conventions for trade-start date relationship.</param>
		// <param name="AllowInvalidTradeDate">Allow an invalid trade date to be returned. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateEarliestTradeDateModifier(object DateModifierName, object MarketConventions, object AllowInvalidTradeDate)
		{

			Hashtable CreateEarliestTradeDateModifier_args = new Hashtable();
			CreateEarliestTradeDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateEarliestTradeDateModifier_args.Add("MarketConventions", MarketConventions);
			CreateEarliestTradeDateModifier_args.Add("AllowInvalidTradeDate", AllowInvalidTradeDate);
			return F3Formatter.f3_style_serialization("CreateEarliestTradeDateModifier", CreateEarliestTradeDateModifier_args);
		}

		// <summary>
		// Create an instrument strategy that forms all the instruments in an element.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="MarketDataTag">Tag identifying the market data element to use.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateElementInstrumentStrategy(object StrategyName, object MarketDataTag)
		{

			Hashtable CreateElementInstrumentStrategy_args = new Hashtable();
			CreateElementInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateElementInstrumentStrategy_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("CreateElementInstrumentStrategy", CreateElementInstrumentStrategy_args);
		}

		// <summary>
		// Create an instrument strategy collection from all the instruments in a collection of market data tags.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="MarketDataTags">Tags identifying the market data elements to use.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateElementInstrumentStrategyCollection(object StrategyName, object MarketDataTags)
		{

			Hashtable CreateElementInstrumentStrategyCollection_args = new Hashtable();
			CreateElementInstrumentStrategyCollection_args.Add("StrategyName", StrategyName);
			CreateElementInstrumentStrategyCollection_args.Add("MarketDataTags", MarketDataTags);
			return F3Formatter.f3_style_serialization("CreateElementInstrumentStrategyCollection", CreateElementInstrumentStrategyCollection_args);
		}

		// <summary>
		// Creates a modifier which returns the multiplication of the elements among the sets of state variables.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="NumberOfSets">Number of distinct sets.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateElementwiseProductModifier(object ModifierName, object NumberOfSets)
		{

			Hashtable CreateElementwiseProductModifier_args = new Hashtable();
			CreateElementwiseProductModifier_args.Add("ModifierName", ModifierName);
			CreateElementwiseProductModifier_args.Add("NumberOfSets", NumberOfSets);
			return F3Formatter.f3_style_serialization("CreateElementwiseProductModifier", CreateElementwiseProductModifier_args);
		}

		// <summary>
		// Create an empty model.
		// </summary>
		// <param name="ModelName">Name to use for the model.</param>
		// <param name="BaseDate">Base date of the model. Default value: default-constructed instance of type date.</param>
		// <param name="ValuationMethod">Valuation methodology that shall be used when valuing products in calibration calculations. Default value: Default.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object CreateEmptyModel(object ModelName, object BaseDate, object ValuationMethod)
		{

			Hashtable CreateEmptyModel_args = new Hashtable();
			CreateEmptyModel_args.Add("ModelName", ModelName);
			CreateEmptyModel_args.Add("BaseDate", BaseDate);
			CreateEmptyModel_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("CreateEmptyModel", CreateEmptyModel_args);
		}

		// <summary>
		// Create a maturity calculator handling end-of-year descriptors.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for maturity calculator.</param>
		// <param name="HolidayConventions">Holiday conventions.</param>
		// <param name="UnderlyingMaturityCalculator">Underlying maturity calculator.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateEndOfYearMaturityCalculator(object MaturityCalculatorName, object HolidayConventions, object UnderlyingMaturityCalculator)
		{

			Hashtable CreateEndOfYearMaturityCalculator_args = new Hashtable();
			CreateEndOfYearMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateEndOfYearMaturityCalculator_args.Add("HolidayConventions", HolidayConventions);
			CreateEndOfYearMaturityCalculator_args.Add("UnderlyingMaturityCalculator", UnderlyingMaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateEndOfYearMaturityCalculator", CreateEndOfYearMaturityCalculator_args);
		}

		// <summary>
		// Define a unique entity.
		// </summary>
		// <param name="Entity">Name of the created repository object.</param>
		// <param name="LegalName">Legal name of entity.</param>
		// <returns>Retuns the name of the constructed object of type Entity.</returns>
		public object CreateEntity(object Entity, object LegalName)
		{

			Hashtable CreateEntity_args = new Hashtable();
			CreateEntity_args.Add("Entity", Entity);
			CreateEntity_args.Add("LegalName", LegalName);
			return F3Formatter.f3_style_serialization("CreateEntity", CreateEntity_args);
		}

		// <summary>
		// Create an index representing the value of an equity transaction.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="EquityEntity">Equity entity describing the underlying asset.</param>
		// <param name="MarketConventions">Market conventions for transaction settlement.</param>
		// <param name="IndexReferencer">Index referencer. Default value: default-constructed instance of type referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateEquityAssetIndex(object IndexName, object EquityEntity, object MarketConventions, object IndexReferencer)
		{

			Hashtable CreateEquityAssetIndex_args = new Hashtable();
			CreateEquityAssetIndex_args.Add("IndexName", IndexName);
			CreateEquityAssetIndex_args.Add("EquityEntity", EquityEntity);
			CreateEquityAssetIndex_args.Add("MarketConventions", MarketConventions);
			CreateEquityAssetIndex_args.Add("IndexReferencer", IndexReferencer);
			return F3Formatter.f3_style_serialization("CreateEquityAssetIndex", CreateEquityAssetIndex_args);
		}

		// <summary>
		// Define an equity entity.
		// </summary>
		// <param name="EquityName">Name to use for equity.</param>
		// <param name="Entity">Name of entity.</param>
		// <param name="Currency">Trading currency of equity.</param>
		// <param name="EquityLabel">Label for further equity-specific details. Default value: default-constructed instance of type equity_label.</param>
		// <returns>Retuns the name of the constructed object of type EquityEntity.</returns>
		public object CreateEquityEntity(object EquityName, object Entity, object Currency, object EquityLabel)
		{

			Hashtable CreateEquityEntity_args = new Hashtable();
			CreateEquityEntity_args.Add("EquityName", EquityName);
			CreateEquityEntity_args.Add("Entity", Entity);
			CreateEquityEntity_args.Add("Currency", Currency);
			CreateEquityEntity_args.Add("EquityLabel", EquityLabel);
			return F3Formatter.f3_style_serialization("CreateEquityEntity", CreateEquityEntity_args);
		}

		// <summary>
		// Create a market data set containing a set of equity futures positions.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="FuturesContractType">Type of futures contract.</param>
		// <param name="Maturities">Vector of maturity descriptors for spot date to forward start date.</param>
		// <param name="TradedPrices">Vector of prices for the futures trades.</param>
		// <param name="TagName">Name of futures market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="TagType">Type of futures market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="Underlying">Futures underlying.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateEquityFuturesMarketData(object MarketDataSetName, object FuturesContractType, object Maturities, object TradedPrices, object TagName, object TagType, object Underlying)
		{

			Hashtable CreateEquityFuturesMarketData_args = new Hashtable();
			CreateEquityFuturesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateEquityFuturesMarketData_args.Add("FuturesContractType", FuturesContractType);
			CreateEquityFuturesMarketData_args.Add("Maturities", Maturities);
			CreateEquityFuturesMarketData_args.Add("TradedPrices", TradedPrices);
			CreateEquityFuturesMarketData_args.Add("TagName", TagName);
			CreateEquityFuturesMarketData_args.Add("TagType", TagType);
			CreateEquityFuturesMarketData_args.Add("Underlying", Underlying);
			return F3Formatter.f3_style_serialization("CreateEquityFuturesMarketData", CreateEquityFuturesMarketData_args);
		}

		// <summary>
		// Define a futures contract type for a futures contract whose underlying is the equity index.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">The futures contract multiplier.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateEquityIndexFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateEquityIndexFuturesContractType_args = new Hashtable();
			CreateEquityIndexFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateEquityIndexFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateEquityIndexFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateEquityIndexFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateEquityIndexFuturesContractType", CreateEquityIndexFuturesContractType_args);
		}

		// <summary>
		// Create an equity trade.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Equity">The equity being traded.</param>
		// <param name="SettlementDetails">Specification of when the trade is agreed and settled.</param>
		// <param name="SharePrice">The agreed price per share of the equity.</param>
		// <param name="NumberOfShares">The number of shares of the equity.</param>
		// <param name="BuySell">Flag indicating purchase or sale of the equity.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateEquityProduct(object ProductName, object Equity, object SettlementDetails, object SharePrice, object NumberOfShares, object BuySell)
		{

			Hashtable CreateEquityProduct_args = new Hashtable();
			CreateEquityProduct_args.Add("ProductName", ProductName);
			CreateEquityProduct_args.Add("Equity", Equity);
			CreateEquityProduct_args.Add("SettlementDetails", SettlementDetails);
			CreateEquityProduct_args.Add("SharePrice", SharePrice);
			CreateEquityProduct_args.Add("NumberOfShares", NumberOfShares);
			CreateEquityProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateEquityProduct", CreateEquityProduct_args);
		}

		// <summary>
		// Create a valuation specification that enables the use of an equivalent product sequence.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="SequenceValuationMethod">Valuation specification for each product in the equivalent product sequence.</param>
		// <param name="SequencingStrategy">Strategy for forming the equivalent product sequence.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateEquivalentProductSequenceValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object SequenceValuationMethod, object SequencingStrategy)
		{

			Hashtable CreateEquivalentProductSequenceValuationSpecification_args = new Hashtable();
			CreateEquivalentProductSequenceValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateEquivalentProductSequenceValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateEquivalentProductSequenceValuationSpecification_args.Add("SequenceValuationMethod", SequenceValuationMethod);
			CreateEquivalentProductSequenceValuationSpecification_args.Add("SequencingStrategy", SequencingStrategy);
			return F3Formatter.f3_style_serialization("CreateEquivalentProductSequenceValuationSpecification", CreateEquivalentProductSequenceValuationSpecification_args);
		}

		// <summary>
		// Create a European option on an underlying equity.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Equity">Equity on which the option is written.</param>
		// <param name="Settlement">Specification of settlement delay for the underlying trade.</param>
		// <param name="Expiry">Time at which the option contract expires.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateEuropeanEquityOption(object ProductName, object Equity, object Settlement, object Expiry, object Notional, object Strike, object Payoff, object BuySell)
		{

			Hashtable CreateEuropeanEquityOption_args = new Hashtable();
			CreateEuropeanEquityOption_args.Add("ProductName", ProductName);
			CreateEuropeanEquityOption_args.Add("Equity", Equity);
			CreateEuropeanEquityOption_args.Add("Settlement", Settlement);
			CreateEuropeanEquityOption_args.Add("Expiry", Expiry);
			CreateEuropeanEquityOption_args.Add("Notional", Notional);
			CreateEuropeanEquityOption_args.Add("Strike", Strike);
			CreateEuropeanEquityOption_args.Add("Payoff", Payoff);
			CreateEuropeanEquityOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateEuropeanEquityOption", CreateEuropeanEquityOption_args);
		}

		// <summary>
		// Create a European option on an underlying FX rate.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="FXRate">Underlying on which the option is written.</param>
		// <param name="Expiry">Time at which the option contract expires.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateEuropeanFXOption(object ProductName, object FXRate, object Expiry, object Notional, object Strike, object Payoff, object BuySell)
		{

			Hashtable CreateEuropeanFXOption_args = new Hashtable();
			CreateEuropeanFXOption_args.Add("ProductName", ProductName);
			CreateEuropeanFXOption_args.Add("FXRate", FXRate);
			CreateEuropeanFXOption_args.Add("Expiry", Expiry);
			CreateEuropeanFXOption_args.Add("Notional", Notional);
			CreateEuropeanFXOption_args.Add("Strike", Strike);
			CreateEuropeanFXOption_args.Add("Payoff", Payoff);
			CreateEuropeanFXOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateEuropeanFXOption", CreateEuropeanFXOption_args);
		}

		// <summary>
		// Define a European futures option contract type.
		// </summary>
		// <param name="ContractName">Name to use for the European futures option contract type.</param>
		// <param name="ContractType">Underlying futures contract type .</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the option expiry date .</param>
		// <returns>Retuns the name of the constructed object of type FuturesOptionContractType.</returns>
		public object CreateEuropeanFuturesOptionContractType(object ContractName, object ContractType, object MaturityCalculator)
		{

			Hashtable CreateEuropeanFuturesOptionContractType_args = new Hashtable();
			CreateEuropeanFuturesOptionContractType_args.Add("ContractName", ContractName);
			CreateEuropeanFuturesOptionContractType_args.Add("ContractType", ContractType);
			CreateEuropeanFuturesOptionContractType_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateEuropeanFuturesOptionContractType", CreateEuropeanFuturesOptionContractType_args);
		}

		// <summary>
		// Create a European option on any underlying asset value.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Underlying">Underlying on which the option is written.</param>
		// <param name="Expiry">Time at which the option contract expires.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateEuropeanOption(object ProductName, object Underlying, object Expiry, object Notional, object Strike, object Payoff, object BuySell)
		{

			Hashtable CreateEuropeanOption_args = new Hashtable();
			CreateEuropeanOption_args.Add("ProductName", ProductName);
			CreateEuropeanOption_args.Add("Underlying", Underlying);
			CreateEuropeanOption_args.Add("Expiry", Expiry);
			CreateEuropeanOption_args.Add("Notional", Notional);
			CreateEuropeanOption_args.Add("Strike", Strike);
			CreateEuropeanOption_args.Add("Payoff", Payoff);
			CreateEuropeanOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateEuropeanOption", CreateEuropeanOption_args);
		}

		// <summary>
		// Form an index that represents an option on another index.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="Strike">Strike specification.</param>
		// <param name="Payoff">Payoff specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateEuropeanOptionIndex(object IndexName, object UnderlyingIndex, object Strike, object Payoff)
		{

			Hashtable CreateEuropeanOptionIndex_args = new Hashtable();
			CreateEuropeanOptionIndex_args.Add("IndexName", IndexName);
			CreateEuropeanOptionIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateEuropeanOptionIndex_args.Add("Strike", Strike);
			CreateEuropeanOptionIndex_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateEuropeanOptionIndex", CreateEuropeanOptionIndex_args);
		}

		// <summary>
		// Creates a European quanto option on an underlying index.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Underlying">Underlying on which the option is written.</param>
		// <param name="Expiry">Time at which the option contract expires.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="PaymentCurrency">Currency used for payment.</param>
		// <param name="FixedExchangeRate">Exchange rate between the currency in which the equity is valued and the payment currency.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateEuropeanQuantoOption(object ProductName, object Underlying, object Expiry, object Notional, object Strike, object Payoff, object PaymentCurrency, object FixedExchangeRate, object BuySell)
		{

			Hashtable CreateEuropeanQuantoOption_args = new Hashtable();
			CreateEuropeanQuantoOption_args.Add("ProductName", ProductName);
			CreateEuropeanQuantoOption_args.Add("Underlying", Underlying);
			CreateEuropeanQuantoOption_args.Add("Expiry", Expiry);
			CreateEuropeanQuantoOption_args.Add("Notional", Notional);
			CreateEuropeanQuantoOption_args.Add("Strike", Strike);
			CreateEuropeanQuantoOption_args.Add("Payoff", Payoff);
			CreateEuropeanQuantoOption_args.Add("PaymentCurrency", PaymentCurrency);
			CreateEuropeanQuantoOption_args.Add("FixedExchangeRate", FixedExchangeRate);
			CreateEuropeanQuantoOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateEuropeanQuantoOption", CreateEuropeanQuantoOption_args);
		}

		// <summary>
		// Create an evaluation function modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="EvaluationFunctions">Vector of evaluation functions.</param>
		// <param name="VectorOfIndexVectors">Vector of index vectors, one per evaluation function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateEvaluationFunctionModifier(object ModifierName, object EvaluationFunctions, object VectorOfIndexVectors)
		{

			Hashtable CreateEvaluationFunctionModifier_args = new Hashtable();
			CreateEvaluationFunctionModifier_args.Add("ModifierName", ModifierName);
			CreateEvaluationFunctionModifier_args.Add("EvaluationFunctions", EvaluationFunctions);
			CreateEvaluationFunctionModifier_args.Add("VectorOfIndexVectors", VectorOfIndexVectors);
			return F3Formatter.f3_style_serialization("CreateEvaluationFunctionModifier", CreateEvaluationFunctionModifier_args);
		}

		// <summary>
		// Create a constant value function to calculate an expected value of one underlying index multiplied by the other.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="FirstMean">The mean of the first variable.</param>
		// <param name="SecondMean">The mean of the second variable.</param>
		// <param name="FirstMeanSquare">The mean of the square of the first variable.</param>
		// <param name="SecondMeanSquare">The mean of the square of the second variable.</param>
		// <param name="Correlation">The correlation between the two variables.</param>
		// <param name="CorrelationType">Type of the market correlations between the two underlying variables.</param>
		// <param name="FirstMeanTag">Tag to use for the mean of the first variable.</param>
		// <param name="SecondMeanTag">Tag to use for the mean of the second variable.</param>
		// <param name="FirstMeanSquareTag">Tag to use for the mean of the square of the first variable.</param>
		// <param name="SecondMeanSquareTag">Tag to use for the mean of the square of the second variable.</param>
		// <param name="CorrelationTag">Tag to use for the correlation between the two variables.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateExpectedProductValueFunction(object FunctionName, object FirstMean, object SecondMean, object FirstMeanSquare, object SecondMeanSquare, object Correlation, object CorrelationType, object FirstMeanTag, object SecondMeanTag, object FirstMeanSquareTag,
		object SecondMeanSquareTag, object CorrelationTag)
		{

			Hashtable CreateExpectedProductValueFunction_args = new Hashtable();
			CreateExpectedProductValueFunction_args.Add("FunctionName", FunctionName);
			CreateExpectedProductValueFunction_args.Add("FirstMean", FirstMean);
			CreateExpectedProductValueFunction_args.Add("SecondMean", SecondMean);
			CreateExpectedProductValueFunction_args.Add("FirstMeanSquare", FirstMeanSquare);
			CreateExpectedProductValueFunction_args.Add("SecondMeanSquare", SecondMeanSquare);
			CreateExpectedProductValueFunction_args.Add("Correlation", Correlation);
			CreateExpectedProductValueFunction_args.Add("CorrelationType", CorrelationType);
			CreateExpectedProductValueFunction_args.Add("FirstMeanTag", FirstMeanTag);
			CreateExpectedProductValueFunction_args.Add("SecondMeanTag", SecondMeanTag);
			CreateExpectedProductValueFunction_args.Add("FirstMeanSquareTag", FirstMeanSquareTag);
			CreateExpectedProductValueFunction_args.Add("SecondMeanSquareTag", SecondMeanSquareTag);
			CreateExpectedProductValueFunction_args.Add("CorrelationTag", CorrelationTag);
			return F3Formatter.f3_style_serialization("CreateExpectedProductValueFunction", CreateExpectedProductValueFunction_args);
		}

		// <summary>
		// Create a matrix decomposition method to specify that the factor loadings in a factor model are explicitly provided.
		// </summary>
		// <param name="MethodName">Name to use for the matrix decomposition method.</param>
		// <param name="NumberOfFactors">Number of factors.</param>
		// <returns>Retuns the name of the constructed object of type MatrixDecomposition.</returns>
		public object CreateExplicitFactorLoadingsDecomposition(object MethodName, object NumberOfFactors)
		{

			Hashtable CreateExplicitFactorLoadingsDecomposition_args = new Hashtable();
			CreateExplicitFactorLoadingsDecomposition_args.Add("MethodName", MethodName);
			CreateExplicitFactorLoadingsDecomposition_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateExplicitFactorLoadingsDecomposition", CreateExplicitFactorLoadingsDecomposition_args);
		}

		// <summary>
		// Create a scenario generator which returns an explicit list of scenarios.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="ScenarioCollection">Scenario collection.</param>
		// <returns>Retuns the name of the constructed object of type ScenarioGenerator.</returns>
		public object CreateExplicitScenarioGenerator(object GeneratorName, object ScenarioCollection)
		{

			Hashtable CreateExplicitScenarioGenerator_args = new Hashtable();
			CreateExplicitScenarioGenerator_args.Add("GeneratorName", GeneratorName);
			CreateExplicitScenarioGenerator_args.Add("ScenarioCollection", ScenarioCollection);
			return F3Formatter.f3_style_serialization("CreateExplicitScenarioGenerator", CreateExplicitScenarioGenerator_args);
		}

		// <summary>
		// Create a sequencing strategy with an explicit collection of schedules defining the approximating products.
		// </summary>
		// <param name="StrategyName">Name to use for the created strategy.</param>
		// <param name="ScheduleCollection">Collection of date lists defining the approximating products.</param>
		// <param name="InterpolationMethod">Method for extrapolating the product values in the equivalent product sequence. Default value: SimpleLinearRegression.</param>
		// <returns>Retuns the name of the constructed object of type ProductSequencingStrategy.</returns>
		public object CreateExplicitSchedulesSequencingStrategy(object StrategyName, object ScheduleCollection, object InterpolationMethod)
		{

			Hashtable CreateExplicitSchedulesSequencingStrategy_args = new Hashtable();
			CreateExplicitSchedulesSequencingStrategy_args.Add("StrategyName", StrategyName);
			CreateExplicitSchedulesSequencingStrategy_args.Add("ScheduleCollection", ScheduleCollection);
			CreateExplicitSchedulesSequencingStrategy_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("CreateExplicitSchedulesSequencingStrategy", CreateExplicitSchedulesSequencingStrategy_args);
		}

		// <summary>
		// Define a contract type for a futures contract that pays based on the exponentially accrued value of an underlying index.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">Size of one futures contract. Default value: 100000.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="DayCountConvention">Day count convention for computing the accrued value of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateExponentialAccrualFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object DayCountConvention, object UniqueID)
		{

			Hashtable CreateExponentialAccrualFuturesContractType_args = new Hashtable();
			CreateExponentialAccrualFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateExponentialAccrualFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateExponentialAccrualFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateExponentialAccrualFuturesContractType_args.Add("DayCountConvention", DayCountConvention);
			CreateExponentialAccrualFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualFuturesContractType", CreateExponentialAccrualFuturesContractType_args);
		}

		// <summary>
		// Create an index representing the exponentially accrued value of an underlying compounding index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying compounding index.</param>
		// <param name="MarketConventions">Market conventions for calculating the accrual factor. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateExponentialAccrualIndex(object IndexName, object UnderlyingIndex, object MarketConventions)
		{

			Hashtable CreateExponentialAccrualIndex_args = new Hashtable();
			CreateExponentialAccrualIndex_args.Add("IndexName", IndexName);
			CreateExponentialAccrualIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateExponentialAccrualIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualIndex", CreateExponentialAccrualIndex_args);
		}

		// <summary>
		// Create a zero-coupon leg that pays a fixed exponentially accrued rate.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Date on which the leg starts.</param>
		// <param name="Maturity">Specification of the date on which the leg matures.</param>
		// <param name="Notional">Notional amount of the leg.</param>
		// <param name="Currency">Payment currency of the leg.</param>
		// <param name="AccrualRate">Fixed rate which is exponentially accrued and paid at the end of the leg.</param>
		// <param name="MarketConvention">Schedule generator for the leg.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the accrued rate.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateExponentialAccrualZeroCouponLeg(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object AccrualRate, object MarketConvention, object PayRec)
		{

			Hashtable CreateExponentialAccrualZeroCouponLeg_args = new Hashtable();
			CreateExponentialAccrualZeroCouponLeg_args.Add("ProductName", ProductName);
			CreateExponentialAccrualZeroCouponLeg_args.Add("StartDate", StartDate);
			CreateExponentialAccrualZeroCouponLeg_args.Add("Maturity", Maturity);
			CreateExponentialAccrualZeroCouponLeg_args.Add("Notional", Notional);
			CreateExponentialAccrualZeroCouponLeg_args.Add("Currency", Currency);
			CreateExponentialAccrualZeroCouponLeg_args.Add("AccrualRate", AccrualRate);
			CreateExponentialAccrualZeroCouponLeg_args.Add("MarketConvention", MarketConvention);
			CreateExponentialAccrualZeroCouponLeg_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualZeroCouponLeg", CreateExponentialAccrualZeroCouponLeg_args);
		}

		// <summary>
		// Create a zero-coupon swap that exchanges floating payments against a fixed exponentially accrued rate.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">Notional amount of the swap.</param>
		// <param name="AccrualRate">Fixed rate which is exponentially accrued and paid at the end of the fixed leg.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate. Default value: 0.0.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg's payment.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateExponentialAccrualZeroCouponSwap(object ProductName, object StartDate, object Maturity, object Notional, object AccrualRate, object FixedLegMarketConventions, object FloatingRateIndex, object Margin, object FloatingLegMarketConventions, object PayRec)
		{

			Hashtable CreateExponentialAccrualZeroCouponSwap_args = new Hashtable();
			CreateExponentialAccrualZeroCouponSwap_args.Add("ProductName", ProductName);
			CreateExponentialAccrualZeroCouponSwap_args.Add("StartDate", StartDate);
			CreateExponentialAccrualZeroCouponSwap_args.Add("Maturity", Maturity);
			CreateExponentialAccrualZeroCouponSwap_args.Add("Notional", Notional);
			CreateExponentialAccrualZeroCouponSwap_args.Add("AccrualRate", AccrualRate);
			CreateExponentialAccrualZeroCouponSwap_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateExponentialAccrualZeroCouponSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateExponentialAccrualZeroCouponSwap_args.Add("Margin", Margin);
			CreateExponentialAccrualZeroCouponSwap_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			CreateExponentialAccrualZeroCouponSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualZeroCouponSwap", CreateExponentialAccrualZeroCouponSwap_args);
		}

		// <summary>
		// Create an instrument type for an exponential accrual zero-coupon swap.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the fixed leg.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateExponentialAccrualZeroCouponSwapInstrumentType(object InstrumentTypeName, object FixedLegMarketConventions, object FloatingIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateExponentialAccrualZeroCouponSwapInstrumentType_args = new Hashtable();
			CreateExponentialAccrualZeroCouponSwapInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateExponentialAccrualZeroCouponSwapInstrumentType_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateExponentialAccrualZeroCouponSwapInstrumentType_args.Add("FloatingIndex", FloatingIndex);
			CreateExponentialAccrualZeroCouponSwapInstrumentType_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualZeroCouponSwapInstrumentType", CreateExponentialAccrualZeroCouponSwapInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of exponential accrual zero-coupon swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="AccrualRates">Vector of accrual rates.</param>
		// <param name="MarketDataName">Name of market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the fixed leg.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateExponentialAccrualZeroCouponSwapMarketData(object MarketDataSetName, object Maturities, object AccrualRates, object MarketDataName, object MarketDataType, object FixedLegMarketConventions, object FloatingIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateExponentialAccrualZeroCouponSwapMarketData_args = new Hashtable();
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("Maturities", Maturities);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("AccrualRates", AccrualRates);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("MarketDataName", MarketDataName);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("MarketDataType", MarketDataType);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("FloatingIndex", FloatingIndex);
			CreateExponentialAccrualZeroCouponSwapMarketData_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateExponentialAccrualZeroCouponSwapMarketData", CreateExponentialAccrualZeroCouponSwapMarketData_args);
		}

		// <summary>
		// Create an exponentially compounded interest rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for the compounded rate.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateExponentialCompoundingRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateExponentialCompoundingRateIndex_args = new Hashtable();
			CreateExponentialCompoundingRateIndex_args.Add("IndexName", IndexName);
			CreateExponentialCompoundingRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateExponentialCompoundingRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateExponentialCompoundingRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateExponentialCompoundingRateIndex", CreateExponentialCompoundingRateIndex_args);
		}

		// <summary>
		// Create a function which exponentiates a parameter by its argument.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Parameter">Parameter to be exponentiated.</param>
		// <param name="ParameterTag">Tag to use for the parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateExponentiateParameterFunction(object FunctionName, object Parameter, object ParameterTag)
		{

			Hashtable CreateExponentiateParameterFunction_args = new Hashtable();
			CreateExponentiateParameterFunction_args.Add("FunctionName", FunctionName);
			CreateExponentiateParameterFunction_args.Add("Parameter", Parameter);
			CreateExponentiateParameterFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateExponentiateParameterFunction", CreateExponentiateParameterFunction_args);
		}

		// <summary>
		// Create a function which exponentiates its argument.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Parameter">Parameter to exponentiate the argument of the function by.</param>
		// <param name="ParameterTag">Tag to use for the parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateExponentiateXFunction(object FunctionName, object Parameter, object ParameterTag)
		{

			Hashtable CreateExponentiateXFunction_args = new Hashtable();
			CreateExponentiateXFunction_args.Add("FunctionName", FunctionName);
			CreateExponentiateXFunction_args.Add("Parameter", Parameter);
			CreateExponentiateXFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateExponentiateXFunction", CreateExponentiateXFunction_args);
		}

		// <summary>
		// Create an exponentiated scaled function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Forward">Value of forward.</param>
		// <param name="Volatility">Value of volatility.</param>
		// <param name="Time">Time of forward. Default value: 1.0.</param>
		// <param name="ParameterTag">Tag to use for parameters.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateExponentiatedForwardFunction(object FunctionName, object Forward, object Volatility, object Time, object ParameterTag)
		{

			Hashtable CreateExponentiatedForwardFunction_args = new Hashtable();
			CreateExponentiatedForwardFunction_args.Add("FunctionName", FunctionName);
			CreateExponentiatedForwardFunction_args.Add("Forward", Forward);
			CreateExponentiatedForwardFunction_args.Add("Volatility", Volatility);
			CreateExponentiatedForwardFunction_args.Add("Time", Time);
			CreateExponentiatedForwardFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateExponentiatedForwardFunction", CreateExponentiatedForwardFunction_args);
		}

		// <summary>
		// Create an exponentiated scaled function from implied values.
		// </summary>
		// <param name="Function">Name to use for the function.</param>
		// <param name="ForwardCurve">Function specifying forward as function of time.</param>
		// <param name="VolatilityCurve">Function specifying volatility as a function of time.</param>
		// <param name="Time">Time of forward. Default value: 1.0.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateExponentiatedImpliedForwardFunction(object Function_name, object ForwardCurve, object VolatilityCurve, object Time)
		{

			Hashtable CreateExponentiatedImpliedForwardFunction_args = new Hashtable();
			CreateExponentiatedImpliedForwardFunction_args.Add("Function", Function_name);
			CreateExponentiatedImpliedForwardFunction_args.Add("ForwardCurve", ForwardCurve);
			CreateExponentiatedImpliedForwardFunction_args.Add("VolatilityCurve", VolatilityCurve);
			CreateExponentiatedImpliedForwardFunction_args.Add("Time", Time);
			return F3Formatter.f3_style_serialization("CreateExponentiatedImpliedForwardFunction", CreateExponentiatedImpliedForwardFunction_args);
		}

		// <summary>
		// Create a backward evolution operator for performing exponentiation.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="ExponentValue">Exponent of the operation.</param>
		// <param name="ExponentParameterTag">Tag to use for the exponent.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateExponentiationOperator(object OperatorName, object ExponentValue, object ExponentParameterTag)
		{

			Hashtable CreateExponentiationOperator_args = new Hashtable();
			CreateExponentiationOperator_args.Add("OperatorName", OperatorName);
			CreateExponentiationOperator_args.Add("ExponentValue", ExponentValue);
			CreateExponentiationOperator_args.Add("ExponentParameterTag", ExponentParameterTag);
			return F3Formatter.f3_style_serialization("CreateExponentiationOperator", CreateExponentiationOperator_args);
		}

		// <summary>
		// Create a connection to F3 Platform's asynchronous calculation service.
		// </summary>
		// <param name="ConnectionName">Name to use for connection.</param>
		// <param name="Host">Address of the network host.</param>
		// <param name="Port">TCP port for F3 Platform's asynchronous service. Default value: 8501.</param>
		// <param name="Cookie">Cookie needed to establish the connection.</param>
		// <returns>Retuns the name of the constructed object of type RemoteExecutorSource.</returns>
		public object CreateF3PlatformGridConnection(object ConnectionName, object Host, object Port, object Cookie)
		{

			Hashtable CreateF3PlatformGridConnection_args = new Hashtable();
			CreateF3PlatformGridConnection_args.Add("ConnectionName", ConnectionName);
			CreateF3PlatformGridConnection_args.Add("Host", Host);
			CreateF3PlatformGridConnection_args.Add("Port", Port);
			CreateF3PlatformGridConnection_args.Add("Cookie", Cookie);
			return F3Formatter.f3_style_serialization("CreateF3PlatformGridConnection", CreateF3PlatformGridConnection_args);
		}

		// <summary>
		// Create an instrument type for a forward rate agreement.
		// </summary>
		// <param name="InstrumentTypeName">Name of instrument type.</param>
		// <param name="MarketConventions">Market conventions to calculate quote date to spot date and spot date to forward start date.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateFRAInstrumentType(object InstrumentTypeName, object MarketConventions, object FloatingIndex)
		{

			Hashtable CreateFRAInstrumentType_args = new Hashtable();
			CreateFRAInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateFRAInstrumentType_args.Add("MarketConventions", MarketConventions);
			CreateFRAInstrumentType_args.Add("FloatingIndex", FloatingIndex);
			return F3Formatter.f3_style_serialization("CreateFRAInstrumentType", CreateFRAInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of forward rate agreements.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of maturity descriptors for spot date to forward start date.</param>
		// <param name="ContractRates">Vector of FRA contract rates.</param>
		// <param name="TagName">Name of FRA market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="TagType">Type of FRA market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="MarketConventions">Market conventions to calculate quote date to spot date and spot date to forward start date.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateFRAMarketData(object MarketDataSetName, object Maturities, object ContractRates, object TagName, object TagType, object MarketConventions, object FloatingIndex)
		{

			Hashtable CreateFRAMarketData_args = new Hashtable();
			CreateFRAMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateFRAMarketData_args.Add("Maturities", Maturities);
			CreateFRAMarketData_args.Add("ContractRates", ContractRates);
			CreateFRAMarketData_args.Add("TagName", TagName);
			CreateFRAMarketData_args.Add("TagType", TagType);
			CreateFRAMarketData_args.Add("MarketConventions", MarketConventions);
			CreateFRAMarketData_args.Add("FloatingIndex", FloatingIndex);
			return F3Formatter.f3_style_serialization("CreateFRAMarketData", CreateFRAMarketData_args);
		}

		// <summary>
		// Create a market convention suitable for calculating FX settlement and payment dates.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="CurrencyOneHolidays">Holiday conventions for payment dates.</param>
		// <param name="CurrencyOneSettlementDescriptor">Settlement maturity descriptor for currency one.</param>
		// <param name="CurrencyTwoHolidays">Holiday conventions for payment dates. Default value: NoHolidays.</param>
		// <param name="CurrencyTwoSettlementDescriptor">Settlement maturity descriptor for currency two. Default value: 0d.</param>
		// <param name="AdditionalPaymentHolidays">Holiday conventions for payment dates.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateFXMarketConvention(object MarketConventionName, object CurrencyOneHolidays, object CurrencyOneSettlementDescriptor, object CurrencyTwoHolidays, object CurrencyTwoSettlementDescriptor, object AdditionalPaymentHolidays)
		{

			Hashtable CreateFXMarketConvention_args = new Hashtable();
			CreateFXMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateFXMarketConvention_args.Add("CurrencyOneHolidays", CurrencyOneHolidays);
			CreateFXMarketConvention_args.Add("CurrencyOneSettlementDescriptor", CurrencyOneSettlementDescriptor);
			CreateFXMarketConvention_args.Add("CurrencyTwoHolidays", CurrencyTwoHolidays);
			CreateFXMarketConvention_args.Add("CurrencyTwoSettlementDescriptor", CurrencyTwoSettlementDescriptor);
			CreateFXMarketConvention_args.Add("AdditionalPaymentHolidays", AdditionalPaymentHolidays);
			return F3Formatter.f3_style_serialization("CreateFXMarketConvention", CreateFXMarketConvention_args);
		}

		// <summary>
		// Create a market data element from a set of FX rates and associated indices.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="FXRateName">Name to use for FX rates.</param>
		// <param name="FXRateType">Type name to use for FX rates.</param>
		// <param name="CurrencyIndices">Array of FX rate indices.</param>
		// <param name="FXRates">Vector of FX rate values.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateFXMarketData(object MarketDataSetName, object FXRateName, object FXRateType, object CurrencyIndices, object FXRates)
		{

			Hashtable CreateFXMarketData_args = new Hashtable();
			CreateFXMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateFXMarketData_args.Add("FXRateName", FXRateName);
			CreateFXMarketData_args.Add("FXRateType", FXRateType);
			CreateFXMarketData_args.Add("CurrencyIndices", CurrencyIndices);
			CreateFXMarketData_args.Add("FXRates", FXRates);
			return F3Formatter.f3_style_serialization("CreateFXMarketData", CreateFXMarketData_args);
		}

		// <summary>
		// Create an FX rate index.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="AssetCurrency">Asset currency.</param>
		// <param name="NumeraireCurrency">Numeraire currency.</param>
		// <param name="SettlementMarketConventions">Market conventions describing the settlement of the rate.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateFXRateIndex(object IndexName, object AssetCurrency, object NumeraireCurrency, object SettlementMarketConventions)
		{

			Hashtable CreateFXRateIndex_args = new Hashtable();
			CreateFXRateIndex_args.Add("IndexName", IndexName);
			CreateFXRateIndex_args.Add("AssetCurrency", AssetCurrency);
			CreateFXRateIndex_args.Add("NumeraireCurrency", NumeraireCurrency);
			CreateFXRateIndex_args.Add("SettlementMarketConventions", SettlementMarketConventions);
			return F3Formatter.f3_style_serialization("CreateFXRateIndex", CreateFXRateIndex_args);
		}

		// <summary>
		// Create a factor-major state variable ordering object.
		// </summary>
		// <param name="OrderingName">Name to use for the ordering.</param>
		// <param name="NumberOfFactors">Number of factors.</param>
		// <returns>Retuns the name of the constructed object of type StateVariableOrdering.</returns>
		public object CreateFactorMajorStateVariableOrdering(object OrderingName, object NumberOfFactors)
		{

			Hashtable CreateFactorMajorStateVariableOrdering_args = new Hashtable();
			CreateFactorMajorStateVariableOrdering_args.Add("OrderingName", OrderingName);
			CreateFactorMajorStateVariableOrdering_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateFactorMajorStateVariableOrdering", CreateFactorMajorStateVariableOrdering_args);
		}

		// <summary>
		// Create a backward evolution operator for performing fast Fourier transforms.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="ForwardNotInverse">True for forward transform, false for inverse transform.</param>
		// <param name="ScalingFactor">Constant factor to scale the Fourier integral by.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateFastFourierTransformOperator(object OperatorName, object ForwardNotInverse, object ScalingFactor)
		{

			Hashtable CreateFastFourierTransformOperator_args = new Hashtable();
			CreateFastFourierTransformOperator_args.Add("OperatorName", OperatorName);
			CreateFastFourierTransformOperator_args.Add("ForwardNotInverse", ForwardNotInverse);
			CreateFastFourierTransformOperator_args.Add("ScalingFactor", ScalingFactor);
			return F3Formatter.f3_style_serialization("CreateFastFourierTransformOperator", CreateFastFourierTransformOperator_args);
		}

		// <summary>
		// Specify the step size and number of steps to use in the numerical evaluation of the fast Fourier transform.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="StepSize">The step size. Default value: 0.01.</param>
		// <param name="NumberOfSteps">The number of steps to use. Default value: 16384.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateFastFourierTransformValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object StepSize, object NumberOfSteps)
		{

			Hashtable CreateFastFourierTransformValuationSpecification_args = new Hashtable();
			CreateFastFourierTransformValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateFastFourierTransformValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateFastFourierTransformValuationSpecification_args.Add("StepSize", StepSize);
			CreateFastFourierTransformValuationSpecification_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateFastFourierTransformValuationSpecification", CreateFastFourierTransformValuationSpecification_args);
		}

		// <summary>
		// Specify the step size and number of steps to use in the numerical evaluation of the fast Fourier transform.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="StepSize">The step size. Default value: 0.01.</param>
		// <param name="NumberOfSteps">The number of steps to use. Default value: 16384.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateFastFourierTransformValuationSpecificationBuilder(object BuilderName, object StepSize, object NumberOfSteps)
		{

			Hashtable CreateFastFourierTransformValuationSpecificationBuilder_args = new Hashtable();
			CreateFastFourierTransformValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateFastFourierTransformValuationSpecificationBuilder_args.Add("StepSize", StepSize);
			CreateFastFourierTransformValuationSpecificationBuilder_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateFastFourierTransformValuationSpecificationBuilder", CreateFastFourierTransformValuationSpecificationBuilder_args);
		}

		// <summary>
		// Creates a filter object which can be used to filter out objects from different repositories..
		// </summary>
		// <param name="FilterName">Name to use for the filter.</param>
		// <param name="RepositoryName">Name of the repository to use the filter with.</param>
		// <param name="FilterArguments">Array of values to be used as filtering criteria.</param>
		// <returns>Retuns the name of the constructed object of type Filter.</returns>
		public object CreateFilter(object FilterName, object RepositoryName, object FilterArguments)
		{

			Hashtable CreateFilter_args = new Hashtable();
			CreateFilter_args.Add("FilterName", FilterName);
			CreateFilter_args.Add("RepositoryName", RepositoryName);
			CreateFilter_args.Add("FilterArguments", FilterArguments);
			return F3Formatter.f3_style_serialization("CreateFilter", CreateFilter_args);
		}

		// <summary>
		// Create a date modifier which finds the nearest date from the specified list.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="DesignatedMonths">Months of the year in which the modified date can fall.</param>
		// <param name="MonthsModifiers">Date modifiers that specify the target dates in each of the designated months.</param>
		// <param name="FindPrevious">If true, find the closest previous date, instead of the next. Default value: FALSE.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateFindNearestDateModifier(object DateModifierName, object DesignatedMonths, object MonthsModifiers, object FindPrevious)
		{

			Hashtable CreateFindNearestDateModifier_args = new Hashtable();
			CreateFindNearestDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateFindNearestDateModifier_args.Add("DesignatedMonths", DesignatedMonths);
			CreateFindNearestDateModifier_args.Add("MonthsModifiers", MonthsModifiers);
			CreateFindNearestDateModifier_args.Add("FindPrevious", FindPrevious);
			return F3Formatter.f3_style_serialization("CreateFindNearestDateModifier", CreateFindNearestDateModifier_args);
		}

		// <summary>
		// Create a single currency fixed coupon bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="MarketConventions">Market conventions for the coupon schedule.</param>
		// <param name="RoundCashflows">Rounding instructions for cash flows. Default value: None.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateFixedCouponBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object MarketConventions, object RoundCashflows, object UniqueID)
		{

			Hashtable CreateFixedCouponBondType_args = new Hashtable();
			CreateFixedCouponBondType_args.Add("BondTypeName", BondTypeName);
			CreateFixedCouponBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateFixedCouponBondType_args.Add("YieldConvention", YieldConvention);
			CreateFixedCouponBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateFixedCouponBondType_args.Add("Currency", Currency);
			CreateFixedCouponBondType_args.Add("MarketConventions", MarketConventions);
			CreateFixedCouponBondType_args.Add("RoundCashflows", RoundCashflows);
			CreateFixedCouponBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateFixedCouponBondType", CreateFixedCouponBondType_args);
		}

		// <summary>
		// Create an index that can be used to define the fixed coupon of a trade.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="Referencer">Rule for calculation of an observation point. Default value: UnmodifiedPaymentDate.</param>
		// <param name="CurveName">Unique identifying string, separate from the object name, if desired. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateFixedCouponIndex(object IndexName, object Referencer, object CurveName)
		{

			Hashtable CreateFixedCouponIndex_args = new Hashtable();
			CreateFixedCouponIndex_args.Add("IndexName", IndexName);
			CreateFixedCouponIndex_args.Add("Referencer", Referencer);
			CreateFixedCouponIndex_args.Add("CurveName", CurveName);
			return F3Formatter.f3_style_serialization("CreateFixedCouponIndex", CreateFixedCouponIndex_args);
		}

		// <summary>
		// Create a single currency South African bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="StubType">Stub type. Default value: StubAtStart.</param>
		// <param name="EntitlementMaturityDescriptor">Maturity descriptor relating trade to entitlement date. Default value: 1m.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateFixedCouponSouthAfricanBondType(object BondTypeName, object StubType, object EntitlementMaturityDescriptor, object UniqueID)
		{

			Hashtable CreateFixedCouponSouthAfricanBondType_args = new Hashtable();
			CreateFixedCouponSouthAfricanBondType_args.Add("BondTypeName", BondTypeName);
			CreateFixedCouponSouthAfricanBondType_args.Add("StubType", StubType);
			CreateFixedCouponSouthAfricanBondType_args.Add("EntitlementMaturityDescriptor", EntitlementMaturityDescriptor);
			CreateFixedCouponSouthAfricanBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateFixedCouponSouthAfricanBondType", CreateFixedCouponSouthAfricanBondType_args);
		}

		// <summary>
		// Create a market convention which returns the schedule supplied on construction.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="FixedRollSchedule">Fixed roll schedule.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateFixedScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object FixedRollSchedule)
		{

			Hashtable CreateFixedScheduleMarketConvention_args = new Hashtable();
			CreateFixedScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateFixedScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateFixedScheduleMarketConvention_args.Add("FixedRollSchedule", FixedRollSchedule);
			return F3Formatter.f3_style_serialization("CreateFixedScheduleMarketConvention", CreateFixedScheduleMarketConvention_args);
		}

		// <summary>
		// Create a fixed size histogram source.
		// </summary>
		// <param name="HistogramName">Name to use for the histogram source.</param>
		// <param name="NumBins">Number of bins.</param>
		// <param name="BinWidth">Width of a bin.</param>
		// <param name="HistStart">Left-hand edge of the histogram source.</param>
		// <returns>Retuns the name of the constructed object of type Histogram.</returns>
		public object CreateFixedSizeHistogram(object HistogramName, object NumBins, object BinWidth, object HistStart)
		{

			Hashtable CreateFixedSizeHistogram_args = new Hashtable();
			CreateFixedSizeHistogram_args.Add("HistogramName", HistogramName);
			CreateFixedSizeHistogram_args.Add("NumBins", NumBins);
			CreateFixedSizeHistogram_args.Add("BinWidth", BinWidth);
			CreateFixedSizeHistogram_args.Add("HistStart", HistStart);
			return F3Formatter.f3_style_serialization("CreateFixedSizeHistogram", CreateFixedSizeHistogram_args);
		}

		// <summary>
		// Create a set of unilateral collateralization rules with constant threshold.
		// </summary>
		// <param name="ObjectName">Name to use for the constructed object.</param>
		// <param name="BaseCurrency">Currency in which collateral is to be denominated.</param>
		// <param name="Threshold">Exposure threshold, above which collateral is posted. Default value: 0.0.</param>
		// <param name="IndependentAmount">Upfront payment from the party posting collateral. Default value: 0.0.</param>
		// <param name="PostingParty">Party that posts collateral. Default value: Counterparty.</param>
		// <returns>Retuns the name of the constructed object of type CollateralAgreement.</returns>
		public object CreateFixedThresholdCollateralAgreement(object ObjectName, object BaseCurrency, object Threshold, object IndependentAmount, object PostingParty)
		{

			Hashtable CreateFixedThresholdCollateralAgreement_args = new Hashtable();
			CreateFixedThresholdCollateralAgreement_args.Add("ObjectName", ObjectName);
			CreateFixedThresholdCollateralAgreement_args.Add("BaseCurrency", BaseCurrency);
			CreateFixedThresholdCollateralAgreement_args.Add("Threshold", Threshold);
			CreateFixedThresholdCollateralAgreement_args.Add("IndependentAmount", IndependentAmount);
			CreateFixedThresholdCollateralAgreement_args.Add("PostingParty", PostingParty);
			return F3Formatter.f3_style_serialization("CreateFixedThresholdCollateralAgreement", CreateFixedThresholdCollateralAgreement_args);
		}

		// <summary>
		// Create a market data set containing fixings information.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="DateValueName">Name of fixing market data.</param>
		// <param name="DateValueType">Type of fixing market data.</param>
		// <param name="Fixings">Fixing data to store within market data set.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateFixingsMarketData(object MarketDataSetName, object DateValueName, object DateValueType, object Fixings)
		{

			Hashtable CreateFixingsMarketData_args = new Hashtable();
			CreateFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateFixingsMarketData_args.Add("DateValueName", DateValueName);
			CreateFixingsMarketData_args.Add("DateValueType", DateValueType);
			CreateFixingsMarketData_args.Add("Fixings", Fixings);
			return F3Formatter.f3_style_serialization("CreateFixingsMarketData", CreateFixingsMarketData_args);
		}

		// <summary>
		// Create a valuation specification that controls whether fixings on the valuation date are used.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="RequireFixing">Flag to indicate whether fixings are required.</param>
		// <param name="IgnoreFixing">Flag to indicate that fixings on or after the valuation date should not be used. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateFixingsRequirementValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object RequireFixing, object IgnoreFixing)
		{

			Hashtable CreateFixingsRequirementValuationSpecification_args = new Hashtable();
			CreateFixingsRequirementValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateFixingsRequirementValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateFixingsRequirementValuationSpecification_args.Add("RequireFixing", RequireFixing);
			CreateFixingsRequirementValuationSpecification_args.Add("IgnoreFixing", IgnoreFixing);
			return F3Formatter.f3_style_serialization("CreateFixingsRequirementValuationSpecification", CreateFixingsRequirementValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification that specifies a backwards time shift used in the flat rates model for CDS valuation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="TimeShiftDescriptor">A maturity descriptor specifying the backward shift.</param>
		// <param name="DayCountConvention">The day count convention that will be applied to the backward shift provided.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateFlatRatesBackwardTimeShiftValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object TimeShiftDescriptor, object DayCountConvention)
		{

			Hashtable CreateFlatRatesBackwardTimeShiftValuationSpecification_args = new Hashtable();
			CreateFlatRatesBackwardTimeShiftValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateFlatRatesBackwardTimeShiftValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateFlatRatesBackwardTimeShiftValuationSpecification_args.Add("TimeShiftDescriptor", TimeShiftDescriptor);
			CreateFlatRatesBackwardTimeShiftValuationSpecification_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateFlatRatesBackwardTimeShiftValuationSpecification", CreateFlatRatesBackwardTimeShiftValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification that specifies a forward accrual offset used in the flat rates model for CDS valuation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Maturity">The forward shift in the accrual specified by a maturity descriptor.</param>
		// <param name="DayCountConvention">The day count convention that will be applied to the forward shift provided.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateFlatRatesForwardAccrualTimeShiftValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Maturity, object DayCountConvention)
		{

			Hashtable CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args = new Hashtable();
			CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args.Add("Maturity", Maturity);
			CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateFlatRatesForwardAccrualTimeShiftValuationSpecification", CreateFlatRatesForwardAccrualTimeShiftValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification that specifies the use of flat volatility.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="VolatilityConvention">Specify the volatility type of the flat surface. Default value: Raw.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateFlatVolatilityValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object VolatilityConvention)
		{

			Hashtable CreateFlatVolatilityValuationSpecification_args = new Hashtable();
			CreateFlatVolatilityValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateFlatVolatilityValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateFlatVolatilityValuationSpecification_args.Add("VolatilityConvention", VolatilityConvention);
			return F3Formatter.f3_style_serialization("CreateFlatVolatilityValuationSpecification", CreateFlatVolatilityValuationSpecification_args);
		}

		// <summary>
		// Create a single currency floating rate note bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="MarketConventions">Market conventions for coupon schedule.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateFloatingRateNoteBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object MarketConventions, object UniqueID)
		{

			Hashtable CreateFloatingRateNoteBondType_args = new Hashtable();
			CreateFloatingRateNoteBondType_args.Add("BondTypeName", BondTypeName);
			CreateFloatingRateNoteBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateFloatingRateNoteBondType_args.Add("YieldConvention", YieldConvention);
			CreateFloatingRateNoteBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateFloatingRateNoteBondType_args.Add("Currency", Currency);
			CreateFloatingRateNoteBondType_args.Add("MarketConventions", MarketConventions);
			CreateFloatingRateNoteBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateFloatingRateNoteBondType", CreateFloatingRateNoteBondType_args);
		}

		// <summary>
		// Create a following (FOLL) or modified following (MOD FOLL) date modifier.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="UnderlyingDateModifier">An underlying date modifier that will be applied before FOLL or MOD FOLL.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		// <param name="AllowMonthChange">A flag to specify a following or modified following modifier. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateFollowingDateModifier(object DateModifierName, object UnderlyingDateModifier, object HolidayConventions, object AllowMonthChange)
		{

			Hashtable CreateFollowingDateModifier_args = new Hashtable();
			CreateFollowingDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateFollowingDateModifier_args.Add("UnderlyingDateModifier", UnderlyingDateModifier);
			CreateFollowingDateModifier_args.Add("HolidayConventions", HolidayConventions);
			CreateFollowingDateModifier_args.Add("AllowMonthChange", AllowMonthChange);
			return F3Formatter.f3_style_serialization("CreateFollowingDateModifier", CreateFollowingDateModifier_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating a forward characteristic function.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="CharFuncBuilder">Characteristic function builder.</param>
		// <param name="RealFunctions">Real functions specifying the parameters of the characteristic function.</param>
		// <param name="StartExpiry">Start expiry time of the forward period.</param>
		// <param name="EndExpiry">End expiry time of the forward period.</param>
		// <param name="StartExpiryParameterTag">Tag to use for the start expiry time.</param>
		// <param name="EndExpiryParameterTag">Tag to use for the end expiry time.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateForwardCharacteristicFunctionOperator(object OperatorName, object CharFuncBuilder, object RealFunctions, object StartExpiry, object EndExpiry, object StartExpiryParameterTag, object EndExpiryParameterTag)
		{

			Hashtable CreateForwardCharacteristicFunctionOperator_args = new Hashtable();
			CreateForwardCharacteristicFunctionOperator_args.Add("OperatorName", OperatorName);
			CreateForwardCharacteristicFunctionOperator_args.Add("CharFuncBuilder", CharFuncBuilder);
			CreateForwardCharacteristicFunctionOperator_args.Add("RealFunctions", RealFunctions);
			CreateForwardCharacteristicFunctionOperator_args.Add("StartExpiry", StartExpiry);
			CreateForwardCharacteristicFunctionOperator_args.Add("EndExpiry", EndExpiry);
			CreateForwardCharacteristicFunctionOperator_args.Add("StartExpiryParameterTag", StartExpiryParameterTag);
			CreateForwardCharacteristicFunctionOperator_args.Add("EndExpiryParameterTag", EndExpiryParameterTag);
			return F3Formatter.f3_style_serialization("CreateForwardCharacteristicFunctionOperator", CreateForwardCharacteristicFunctionOperator_args);
		}

		// <summary>
		// Create a forward differentiation method.
		// </summary>
		// <param name="FunctionName">Name to use for the method.</param>
		// <param name="StepSize">Numerical differentiation step size.</param>
		// <param name="Tag">Tag to use for the step size.</param>
		// <returns>Retuns the name of the constructed object of type DifferentiationMethod.</returns>
		public object CreateForwardDifferentiationMethod(object FunctionName, object StepSize, object Tag)
		{

			Hashtable CreateForwardDifferentiationMethod_args = new Hashtable();
			CreateForwardDifferentiationMethod_args.Add("FunctionName", FunctionName);
			CreateForwardDifferentiationMethod_args.Add("StepSize", StepSize);
			CreateForwardDifferentiationMethod_args.Add("Tag", Tag);
			return F3Formatter.f3_style_serialization("CreateForwardDifferentiationMethod", CreateForwardDifferentiationMethod_args);
		}

		// <summary>
		// Create a function to calculate a forward FX rate, given a model time.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Model">Model containing discount factor curves in each currency.</param>
		// <param name="FXRateIndex">Index specifying the FX rate.</param>
		// <param name="TimeCalculator">Methodology for computing time. Default value: default-constructed instance of type time_calculator.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateForwardFXRateFunction(object FunctionName, object Model, object FXRateIndex, object TimeCalculator)
		{

			Hashtable CreateForwardFXRateFunction_args = new Hashtable();
			CreateForwardFXRateFunction_args.Add("FunctionName", FunctionName);
			CreateForwardFXRateFunction_args.Add("Model", Model);
			CreateForwardFXRateFunction_args.Add("FXRateIndex", FXRateIndex);
			CreateForwardFXRateFunction_args.Add("TimeCalculator", TimeCalculator);
			return F3Formatter.f3_style_serialization("CreateForwardFXRateFunction", CreateForwardFXRateFunction_args);
		}

		// <summary>
		// Create a one-dimensional function to specify forward with discrete dividends as a function of time.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="AbsoluteDiscreteDividends">Vector of absolute discrete dividends.</param>
		// <param name="RelativeDiscreteDividends">Vector of relative discrete dividends.</param>
		// <param name="ForwardFunction">One-dimensional function specifying forward as function of time not including discrete dividends.</param>
		// <param name="AbsDiscreteDivsParameterTag">Tag to use for the AbsoluteDiscreteDividends.</param>
		// <param name="RelDiscreteDivsParameterTag">Tag to use for the RelativeDiscreteDividends.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateForwardFunctionWithDiscreteDividends(object FunctionName, object TimePoints, object AbsoluteDiscreteDividends, object RelativeDiscreteDividends, object ForwardFunction, object AbsDiscreteDivsParameterTag, object RelDiscreteDivsParameterTag)
		{

			Hashtable CreateForwardFunctionWithDiscreteDividends_args = new Hashtable();
			CreateForwardFunctionWithDiscreteDividends_args.Add("FunctionName", FunctionName);
			CreateForwardFunctionWithDiscreteDividends_args.Add("TimePoints", TimePoints);
			CreateForwardFunctionWithDiscreteDividends_args.Add("AbsoluteDiscreteDividends", AbsoluteDiscreteDividends);
			CreateForwardFunctionWithDiscreteDividends_args.Add("RelativeDiscreteDividends", RelativeDiscreteDividends);
			CreateForwardFunctionWithDiscreteDividends_args.Add("ForwardFunction", ForwardFunction);
			CreateForwardFunctionWithDiscreteDividends_args.Add("AbsDiscreteDivsParameterTag", AbsDiscreteDivsParameterTag);
			CreateForwardFunctionWithDiscreteDividends_args.Add("RelDiscreteDivsParameterTag", RelDiscreteDivsParameterTag);
			return F3Formatter.f3_style_serialization("CreateForwardFunctionWithDiscreteDividends", CreateForwardFunctionWithDiscreteDividends_args);
		}

		// <summary>
		// Create a forward rate agreement.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the forward rate agreement.</param>
		// <param name="Notional">The notional amount.</param>
		// <param name="ContractRate">The forward rate agreement contract rate.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateForwardRateAgreement(object ProductName, object StartDate, object Notional, object ContractRate, object FloatingRateIndex, object PayRec)
		{

			Hashtable CreateForwardRateAgreement_args = new Hashtable();
			CreateForwardRateAgreement_args.Add("ProductName", ProductName);
			CreateForwardRateAgreement_args.Add("StartDate", StartDate);
			CreateForwardRateAgreement_args.Add("Notional", Notional);
			CreateForwardRateAgreement_args.Add("ContractRate", ContractRate);
			CreateForwardRateAgreement_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateForwardRateAgreement_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateForwardRateAgreement", CreateForwardRateAgreement_args);
		}

		// <summary>
		// Create a valuation specification that specifies a forward valuation date.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Maturity">The maturity of the forward valuation date, from the model base date.</param>
		// <param name="MaturityCalculator">Methodology for calculating the forward valuation date.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateForwardValuationDateSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Maturity, object MaturityCalculator)
		{

			Hashtable CreateForwardValuationDateSpecification_args = new Hashtable();
			CreateForwardValuationDateSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateForwardValuationDateSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateForwardValuationDateSpecification_args.Add("Maturity", Maturity);
			CreateForwardValuationDateSpecification_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateForwardValuationDateSpecification", CreateForwardValuationDateSpecification_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating a forward or inverse Fourier transform.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="ForwardNotInverse">True for forward transform, false for inverse transform.</param>
		// <param name="ScalingFactor">Constant factor to scale the Fourier integral by.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateFourierTransformOperator(object OperatorName, object ForwardNotInverse, object ScalingFactor)
		{

			Hashtable CreateFourierTransformOperator_args = new Hashtable();
			CreateFourierTransformOperator_args.Add("OperatorName", OperatorName);
			CreateFourierTransformOperator_args.Add("ForwardNotInverse", ForwardNotInverse);
			CreateFourierTransformOperator_args.Add("ScalingFactor", ScalingFactor);
			return F3Formatter.f3_style_serialization("CreateFourierTransformOperator", CreateFourierTransformOperator_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating a Fourier-transformed knock-out payoff at expiry.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="Strike">Strike price.</param>
		// <param name="RelevantBarrier">Barrier level relevant to the payoff.</param>
		// <param name="DampingFactor">Damping factor to apply for ensuring the existence of the Fourier transform.</param>
		// <param name="Payoff">Call, put, digital call, or digital put.</param>
		// <param name="StrikeParameterTag">Tag to use for the strike price.</param>
		// <param name="RelevantBarrierParameterTag">Tag to use for the relevant barrier level.</param>
		// <param name="DampingFactorParameterTag">Tag to use for the damping factor.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateFourierTransformedEuropeanKnockOutPayoffOperator(object OperatorName, object Strike, object RelevantBarrier, object DampingFactor, object Payoff, object StrikeParameterTag, object RelevantBarrierParameterTag, object DampingFactorParameterTag)
		{

			Hashtable CreateFourierTransformedEuropeanKnockOutPayoffOperator_args = new Hashtable();
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("OperatorName", OperatorName);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("Strike", Strike);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("RelevantBarrier", RelevantBarrier);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("DampingFactor", DampingFactor);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("Payoff", Payoff);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("StrikeParameterTag", StrikeParameterTag);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("RelevantBarrierParameterTag", RelevantBarrierParameterTag);
			CreateFourierTransformedEuropeanKnockOutPayoffOperator_args.Add("DampingFactorParameterTag", DampingFactorParameterTag);
			return F3Formatter.f3_style_serialization("CreateFourierTransformedEuropeanKnockOutPayoffOperator", CreateFourierTransformedEuropeanKnockOutPayoffOperator_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating a Fourier-transformed vanilla payoff.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="Strike">Strike price.</param>
		// <param name="DampingFactor">Damping factor to apply for ensuring the existence of the Fourier transform.</param>
		// <param name="Payoff">Call, put, digital call, or digital put.</param>
		// <param name="StrikeParameterTag">Tag to use for the strike price.</param>
		// <param name="DampingFactorParameterTag">Tag to use for the damping factor.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateFourierTransformedVanillaPayoffOperator(object OperatorName, object Strike, object DampingFactor, object Payoff, object StrikeParameterTag, object DampingFactorParameterTag)
		{

			Hashtable CreateFourierTransformedVanillaPayoffOperator_args = new Hashtable();
			CreateFourierTransformedVanillaPayoffOperator_args.Add("OperatorName", OperatorName);
			CreateFourierTransformedVanillaPayoffOperator_args.Add("Strike", Strike);
			CreateFourierTransformedVanillaPayoffOperator_args.Add("DampingFactor", DampingFactor);
			CreateFourierTransformedVanillaPayoffOperator_args.Add("Payoff", Payoff);
			CreateFourierTransformedVanillaPayoffOperator_args.Add("StrikeParameterTag", StrikeParameterTag);
			CreateFourierTransformedVanillaPayoffOperator_args.Add("DampingFactorParameterTag", DampingFactorParameterTag);
			return F3Formatter.f3_style_serialization("CreateFourierTransformedVanillaPayoffOperator", CreateFourierTransformedVanillaPayoffOperator_args);
		}

		// <summary>
		// Create a product that represents two cash flows in opposite directions.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">First cash flow date.</param>
		// <param name="EndDate">Second cash flow date.</param>
		// <param name="Index">Index describing the cash flow payments.</param>
		// <param name="Notional">The notional amount of the cash flow.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the first cash flow.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateFrontBackCashflowLeg(object ProductName, object StartDate, object EndDate, object Index, object Notional, object Currency, object PayRec)
		{

			Hashtable CreateFrontBackCashflowLeg_args = new Hashtable();
			CreateFrontBackCashflowLeg_args.Add("ProductName", ProductName);
			CreateFrontBackCashflowLeg_args.Add("StartDate", StartDate);
			CreateFrontBackCashflowLeg_args.Add("EndDate", EndDate);
			CreateFrontBackCashflowLeg_args.Add("Index", Index);
			CreateFrontBackCashflowLeg_args.Add("Notional", Notional);
			CreateFrontBackCashflowLeg_args.Add("Currency", Currency);
			CreateFrontBackCashflowLeg_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateFrontBackCashflowLeg", CreateFrontBackCashflowLeg_args);
		}

		// <summary>
		// Create a market convention that generates front and back payments from an underlying convention.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateFrontBackMarketConvention(object MarketConventionName, object UnderlyingConventions)
		{

			Hashtable CreateFrontBackMarketConvention_args = new Hashtable();
			CreateFrontBackMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateFrontBackMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			return F3Formatter.f3_style_serialization("CreateFrontBackMarketConvention", CreateFrontBackMarketConvention_args);
		}

		// <summary>
		// Create an agreement to collateralize fully with cash or cash equivalent assets.
		// </summary>
		// <param name="ObjectName">Name to use for the constructed object.</param>
		// <param name="InterestRates">Rates at which collateral earns interest.</param>
		// <returns>Retuns the name of the constructed object of type CollateralAgreement.</returns>
		public object CreateFullCashCollateralAgreement(object ObjectName, object InterestRates)
		{

			Hashtable CreateFullCashCollateralAgreement_args = new Hashtable();
			CreateFullCashCollateralAgreement_args.Add("ObjectName", ObjectName);
			CreateFullCashCollateralAgreement_args.Add("InterestRates", InterestRates);
			return F3Formatter.f3_style_serialization("CreateFullCashCollateralAgreement", CreateFullCashCollateralAgreement_args);
		}

		// <summary>
		// Create an instrument strategy collection from one or more instrument strategies, which in turn are constructed from one or more market data objects..
		// </summary>
		// <param name="CollectionName">Name to use for the instrument strategy collection.</param>
		// <param name="MarketData">An array of market data objects from which to extract the instruments.</param>
		// <param name="Sort">Flag specifying whether or not to sort the instruments. Default value: False.</param>
		// <param name="QuoteSpecOrdering">Quote ordering source. Default value: SimpleMaturity.</param>
		// <param name="Offsets">Vector of offsets to instruments. Default value: default-constructed instance of type underlying_index_vector.</param>
		// <param name="Sizes">Vector of number of instruments to include. Default value: default-constructed instance of type underlying_index_vector.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateFullMarketDataSetInstrumentStrategyCollection(object CollectionName, object MarketData, object Sort, object QuoteSpecOrdering, object Offsets, object Sizes)
		{

			Hashtable CreateFullMarketDataSetInstrumentStrategyCollection_args = new Hashtable();
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("CollectionName", CollectionName);
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("MarketData", MarketData);
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("Sort", Sort);
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("QuoteSpecOrdering", QuoteSpecOrdering);
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("Offsets", Offsets);
			CreateFullMarketDataSetInstrumentStrategyCollection_args.Add("Sizes", Sizes);
			return F3Formatter.f3_style_serialization("CreateFullMarketDataSetInstrumentStrategyCollection", CreateFullMarketDataSetInstrumentStrategyCollection_args);
		}

		// <summary>
		// Create an index whose value is a function of an underlying index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="OneDimensionalFunction">Functional form.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateFunctionIndex(object IndexName, object UnderlyingIndex, object OneDimensionalFunction)
		{

			Hashtable CreateFunctionIndex_args = new Hashtable();
			CreateFunctionIndex_args.Add("IndexName", IndexName);
			CreateFunctionIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateFunctionIndex_args.Add("OneDimensionalFunction", OneDimensionalFunction);
			return F3Formatter.f3_style_serialization("CreateFunctionIndex", CreateFunctionIndex_args);
		}

		// <summary>
		// Create a scenario which applies two-dimensional function(s) to a set of market data.
		// </summary>
		// <param name="ScenarioName">Name to use for the scenario.</param>
		// <param name="MarketDataTags">Tags identifying the market data.</param>
		// <param name="ModificationFunctions">Modification function(s) to be applied to the market data.</param>
		// <param name="ModificationAmounts">Modification amount(s) to be applied to the market data.</param>
		// <returns>Retuns the name of the constructed object of type Scenario.</returns>
		public object CreateFunctionScenario(object ScenarioName, object MarketDataTags, object ModificationFunctions, object ModificationAmounts)
		{

			Hashtable CreateFunctionScenario_args = new Hashtable();
			CreateFunctionScenario_args.Add("ScenarioName", ScenarioName);
			CreateFunctionScenario_args.Add("MarketDataTags", MarketDataTags);
			CreateFunctionScenario_args.Add("ModificationFunctions", ModificationFunctions);
			CreateFunctionScenario_args.Add("ModificationAmounts", ModificationAmounts);
			return F3Formatter.f3_style_serialization("CreateFunctionScenario", CreateFunctionScenario_args);
		}

		// <summary>
		// Create a scenario generator which generates function scenarios.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="MarketDataTags">Tags identifying the market data.</param>
		// <param name="ModificationFunctions">Modification function(s) to be applied to the market data.</param>
		// <param name="AmountGenerator">Underlying numeric generator that generates the modification amounts.</param>
		// <param name="IsUniformAmount">Flag indicating whether or not the same modification amount is applied to all market data.</param>
		// <returns>Retuns the name of the constructed object of type ScenarioGenerator.</returns>
		public object CreateFunctionScenarioGenerator(object GeneratorName, object MarketDataTags, object ModificationFunctions, object AmountGenerator, object IsUniformAmount)
		{

			Hashtable CreateFunctionScenarioGenerator_args = new Hashtable();
			CreateFunctionScenarioGenerator_args.Add("GeneratorName", GeneratorName);
			CreateFunctionScenarioGenerator_args.Add("MarketDataTags", MarketDataTags);
			CreateFunctionScenarioGenerator_args.Add("ModificationFunctions", ModificationFunctions);
			CreateFunctionScenarioGenerator_args.Add("AmountGenerator", AmountGenerator);
			CreateFunctionScenarioGenerator_args.Add("IsUniformAmount", IsUniformAmount);
			return F3Formatter.f3_style_serialization("CreateFunctionScenarioGenerator", CreateFunctionScenarioGenerator_args);
		}

		// <summary>
		// Create a spread-over-funding rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="RateIndex">Underlying rate index.</param>
		// <param name="SourceNumeraireSpec">Source numeraire specification. Default value: default-constructed instance of type numeraire_specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateFundingSpreadIndex(object IndexName, object RateIndex, object SourceNumeraireSpec)
		{

			Hashtable CreateFundingSpreadIndex_args = new Hashtable();
			CreateFundingSpreadIndex_args.Add("IndexName", IndexName);
			CreateFundingSpreadIndex_args.Add("RateIndex", RateIndex);
			CreateFundingSpreadIndex_args.Add("SourceNumeraireSpec", SourceNumeraireSpec);
			return F3Formatter.f3_style_serialization("CreateFundingSpreadIndex", CreateFundingSpreadIndex_args);
		}

		// <summary>
		// Create a date modifier that acts as underlying modifier, only it is guaranteed to not move dates back in time.
		// </summary>
		// <param name="DateModifierName">Name of the new date modifier.</param>
		// <param name="UnderlyingDateModifier">An underlying date modifier.</param>
		// <param name="AllowPresent">Specifies if the resulting date may be the same as the original.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateFutureDateModifier(object DateModifierName, object UnderlyingDateModifier, object AllowPresent)
		{

			Hashtable CreateFutureDateModifier_args = new Hashtable();
			CreateFutureDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateFutureDateModifier_args.Add("UnderlyingDateModifier", UnderlyingDateModifier);
			CreateFutureDateModifier_args.Add("AllowPresent", AllowPresent);
			return F3Formatter.f3_style_serialization("CreateFutureDateModifier", CreateFutureDateModifier_args);
		}

		// <summary>
		// Define a futures contract .
		// </summary>
		// <param name="ContractName">Name to use for the futures contract.</param>
		// <param name="ContractType">Futures contract type .</param>
		// <param name="Underlying">Futures underlying.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContract.</returns>
		public object CreateFuturesContract(object ContractName, object ContractType, object Underlying)
		{

			Hashtable CreateFuturesContract_args = new Hashtable();
			CreateFuturesContract_args.Add("ContractName", ContractName);
			CreateFuturesContract_args.Add("ContractType", ContractType);
			CreateFuturesContract_args.Add("Underlying", Underlying);
			return F3Formatter.f3_style_serialization("CreateFuturesContract", CreateFuturesContract_args);
		}

		// <summary>
		// Define a futures contract type.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ValuePerBasisPoint">value per basis point for one contract.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateFuturesContractType(object ContractTypeName, object ValuePerBasisPoint, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateFuturesContractType_args = new Hashtable();
			CreateFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateFuturesContractType_args.Add("ValuePerBasisPoint", ValuePerBasisPoint);
			CreateFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateFuturesContractType", CreateFuturesContractType_args);
		}

		// <summary>
		// Create an index representing the value of a futures contract.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="FuturesContract">Futures contract .</param>
		// <param name="Expiry">Futures expiry.</param>
		// <param name="IndexReferencer">Index referencer. Default value: UnmodifiedPaymentDate.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateFuturesIndex(object IndexName, object FuturesContract, object Expiry, object IndexReferencer)
		{

			Hashtable CreateFuturesIndex_args = new Hashtable();
			CreateFuturesIndex_args.Add("IndexName", IndexName);
			CreateFuturesIndex_args.Add("FuturesContract", FuturesContract);
			CreateFuturesIndex_args.Add("Expiry", Expiry);
			CreateFuturesIndex_args.Add("IndexReferencer", IndexReferencer);
			return F3Formatter.f3_style_serialization("CreateFuturesIndex", CreateFuturesIndex_args);
		}

		// <summary>
		// Create an instrument type for a futures position.
		// </summary>
		// <param name="InstrumentTypeName">Name of instrument type.</param>
		// <param name="FuturesContractType">Type of futures contract. Default value: Standard.</param>
		// <param name="Underlying">Futures underlying.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateFuturesInstrumentType(object InstrumentTypeName, object FuturesContractType, object Underlying)
		{

			Hashtable CreateFuturesInstrumentType_args = new Hashtable();
			CreateFuturesInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateFuturesInstrumentType_args.Add("FuturesContractType", FuturesContractType);
			CreateFuturesInstrumentType_args.Add("Underlying", Underlying);
			return F3Formatter.f3_style_serialization("CreateFuturesInstrumentType", CreateFuturesInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of interest rate futures positions.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="FuturesContractType">Type of futures contract. Default value: Standard.</param>
		// <param name="Maturities">Vector of maturity descriptors for spot date to forward start date.</param>
		// <param name="TradedPrices">Vector of prices for the futures trades.</param>
		// <param name="TagName">Name of futures market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="TagType">Type of futures market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateFuturesMarketData(object MarketDataSetName, object FuturesContractType, object Maturities, object TradedPrices, object TagName, object TagType, object FloatingIndex)
		{

			Hashtable CreateFuturesMarketData_args = new Hashtable();
			CreateFuturesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateFuturesMarketData_args.Add("FuturesContractType", FuturesContractType);
			CreateFuturesMarketData_args.Add("Maturities", Maturities);
			CreateFuturesMarketData_args.Add("TradedPrices", TradedPrices);
			CreateFuturesMarketData_args.Add("TagName", TagName);
			CreateFuturesMarketData_args.Add("TagType", TagType);
			CreateFuturesMarketData_args.Add("FloatingIndex", FloatingIndex);
			return F3Formatter.f3_style_serialization("CreateFuturesMarketData", CreateFuturesMarketData_args);
		}

		// <summary>
		// Create a maturity calculator for Interest Rate Futures.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for maturity calculator.</param>
		// <param name="UnderlyingMaturityCalculator">Underlying maturity calculator.</param>
		// <param name="DateModifier">Date modifier.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateFuturesMaturityCalculator(object MaturityCalculatorName, object UnderlyingMaturityCalculator, object DateModifier)
		{

			Hashtable CreateFuturesMaturityCalculator_args = new Hashtable();
			CreateFuturesMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateFuturesMaturityCalculator_args.Add("UnderlyingMaturityCalculator", UnderlyingMaturityCalculator);
			CreateFuturesMaturityCalculator_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("CreateFuturesMaturityCalculator", CreateFuturesMaturityCalculator_args);
		}

		// <summary>
		// Create a product representing an option on a futures position.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="ContractType">Futures option contract type.</param>
		// <param name="Underlying">Underlying futures index on which the option is written.</param>
		// <param name="OptionExpiry">Expiry of the futures option.</param>
		// <param name="NumberOfFuturesContract">The number of futures contracts underlying the option.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Payoff">Futures option payoff specification.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateFuturesOptionProduct(object ProductName, object ContractType, object Underlying, object OptionExpiry, object NumberOfFuturesContract, object Strike, object Payoff, object BuySell)
		{

			Hashtable CreateFuturesOptionProduct_args = new Hashtable();
			CreateFuturesOptionProduct_args.Add("ProductName", ProductName);
			CreateFuturesOptionProduct_args.Add("ContractType", ContractType);
			CreateFuturesOptionProduct_args.Add("Underlying", Underlying);
			CreateFuturesOptionProduct_args.Add("OptionExpiry", OptionExpiry);
			CreateFuturesOptionProduct_args.Add("NumberOfFuturesContract", NumberOfFuturesContract);
			CreateFuturesOptionProduct_args.Add("Strike", Strike);
			CreateFuturesOptionProduct_args.Add("Payoff", Payoff);
			CreateFuturesOptionProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateFuturesOptionProduct", CreateFuturesOptionProduct_args);
		}

		// <summary>
		// Create a futures position.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="FuturesContract">Futures contract.</param>
		// <param name="Expiry">Expiry of futures contract.</param>
		// <param name="SettlementDetails">Settlement details.</param>
		// <param name="NumberOfContracts">The number of futures contracts.</param>
		// <param name="TradedPrice">Futures contract price fixed at the inception of the trade.</param>
		// <param name="BuySell">Flag indicating whether the futures contract is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateFuturesPosition(object ProductName, object FuturesContract, object Expiry, object SettlementDetails, object NumberOfContracts, object TradedPrice, object BuySell)
		{

			Hashtable CreateFuturesPosition_args = new Hashtable();
			CreateFuturesPosition_args.Add("ProductName", ProductName);
			CreateFuturesPosition_args.Add("FuturesContract", FuturesContract);
			CreateFuturesPosition_args.Add("Expiry", Expiry);
			CreateFuturesPosition_args.Add("SettlementDetails", SettlementDetails);
			CreateFuturesPosition_args.Add("NumberOfContracts", NumberOfContracts);
			CreateFuturesPosition_args.Add("TradedPrice", TradedPrice);
			CreateFuturesPosition_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateFuturesPosition", CreateFuturesPosition_args);
		}

		// <summary>
		// Create a Gauss-Legendre integration method.
		// </summary>
		// <param name="MethodName">Name to use for the method.</param>
		// <param name="NumberOfSteps">Number of steps.</param>
		// <returns>Retuns the name of the constructed object of type IntegrationMethod.</returns>
		public object CreateGaussLegendreIntegrationMethod(object MethodName, object NumberOfSteps)
		{

			Hashtable CreateGaussLegendreIntegrationMethod_args = new Hashtable();
			CreateGaussLegendreIntegrationMethod_args.Add("MethodName", MethodName);
			CreateGaussLegendreIntegrationMethod_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateGaussLegendreIntegrationMethod", CreateGaussLegendreIntegrationMethod_args);
		}

		// <summary>
		// Create a generator from an underlying generator and a modifier.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="UnderlyingGenerator">Underlying generator.</param>
		// <param name="Modifier">Modifier to apply to generator.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreateGenerator(object GeneratorName, object UnderlyingGenerator, object Modifier)
		{

			Hashtable CreateGenerator_args = new Hashtable();
			CreateGenerator_args.Add("GeneratorName", GeneratorName);
			CreateGenerator_args.Add("UnderlyingGenerator", UnderlyingGenerator);
			CreateGenerator_args.Add("Modifier", Modifier);
			return F3Formatter.f3_style_serialization("CreateGenerator", CreateGenerator_args);
		}

		// <summary>
		// Create a single currency coupon-indexed bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="MarketConventions">Market conventions for coupon schedule.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateGenericCouponIndexedBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object MarketConventions, object UniqueID)
		{

			Hashtable CreateGenericCouponIndexedBondType_args = new Hashtable();
			CreateGenericCouponIndexedBondType_args.Add("BondTypeName", BondTypeName);
			CreateGenericCouponIndexedBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateGenericCouponIndexedBondType_args.Add("YieldConvention", YieldConvention);
			CreateGenericCouponIndexedBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateGenericCouponIndexedBondType_args.Add("Currency", Currency);
			CreateGenericCouponIndexedBondType_args.Add("MarketConventions", MarketConventions);
			CreateGenericCouponIndexedBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateGenericCouponIndexedBondType", CreateGenericCouponIndexedBondType_args);
		}

		// <summary>
		// Create a valuation specification that specifies a methodology for solving for a generic (non-linear) par coupon.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="CouponMarker">Index marking the coupon. Default value: FixedCoupon.</param>
		// <param name="InitialGuess">Initial guess for the value of the par coupon. Default value: 1.0.</param>
		// <param name="Constraint">Constraint on the coupon value applied during the search for the par value. Default value: NoBoundConstraint.</param>
		// <param name="OptimObjective">Valuation metric to be used for the calculation. Default value: SingleCurrencyValue.</param>
		// <param name="Optimizer">Methodology for searching for the par value of the coupon. Default value: Bootstrap.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateGenericParCouponValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object CouponMarker, object InitialGuess, object Constraint, object OptimObjective, object Optimizer)
		{

			Hashtable CreateGenericParCouponValuationSpecification_args = new Hashtable();
			CreateGenericParCouponValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateGenericParCouponValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateGenericParCouponValuationSpecification_args.Add("CouponMarker", CouponMarker);
			CreateGenericParCouponValuationSpecification_args.Add("InitialGuess", InitialGuess);
			CreateGenericParCouponValuationSpecification_args.Add("Constraint", Constraint);
			CreateGenericParCouponValuationSpecification_args.Add("OptimObjective", OptimObjective);
			CreateGenericParCouponValuationSpecification_args.Add("Optimizer", Optimizer);
			return F3Formatter.f3_style_serialization("CreateGenericParCouponValuationSpecification", CreateGenericParCouponValuationSpecification_args);
		}

		// <summary>
		// Create a product that represents a leg of floating-rate linked flows in one currency.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="RollSchedule">Roll schedule for the cash flows.</param>
		// <param name="FloatingRateIndices">A vector of floating rate indices.</param>
		// <param name="Notionals">The notionals of the cash flows.</param>
		// <param name="Currency">Currency of the notionals.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flows.</param>
		// <param name="ScalingIndices">A vector of indices scaling the cash flow payments.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateGenericSingleCurrencyFloatingLeg(object ProductName, object RollSchedule, object FloatingRateIndices, object Notionals, object Currency, object PayRec, object ScalingIndices)
		{

			Hashtable CreateGenericSingleCurrencyFloatingLeg_args = new Hashtable();
			CreateGenericSingleCurrencyFloatingLeg_args.Add("ProductName", ProductName);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("RollSchedule", RollSchedule);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("FloatingRateIndices", FloatingRateIndices);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("Notionals", Notionals);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("Currency", Currency);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("PayRec", PayRec);
			CreateGenericSingleCurrencyFloatingLeg_args.Add("ScalingIndices", ScalingIndices);
			return F3Formatter.f3_style_serialization("CreateGenericSingleCurrencyFloatingLeg", CreateGenericSingleCurrencyFloatingLeg_args);
		}

		// <summary>
		// Create a generic single-event credit default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="Premium">The premium paid on each roll of the premium leg.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="MarketConvention">market conventions.</param>
		// <param name="PremiumIndex">Premium index.</param>
		// <param name="ProtectionIndex">Protection index.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <param name="OffsettingMarketConvention">Market conventions for the offsetting leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateGenericSingleEventCreditDefaultSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object Premium, object UpfrontFee, object MarketConvention, object PremiumIndex, object ProtectionIndex,
		object PayRec, object OffsettingMarketConvention)
		{

			Hashtable CreateGenericSingleEventCreditDefaultSwap_args = new Hashtable();
			CreateGenericSingleEventCreditDefaultSwap_args.Add("ProductName", ProductName);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("StartDate", StartDate);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("Maturity", Maturity);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("Notional", Notional);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("Currency", Currency);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("Premium", Premium);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("PremiumIndex", PremiumIndex);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("ProtectionIndex", ProtectionIndex);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("PayRec", PayRec);
			CreateGenericSingleEventCreditDefaultSwap_args.Add("OffsettingMarketConvention", OffsettingMarketConvention);
			return F3Formatter.f3_style_serialization("CreateGenericSingleEventCreditDefaultSwap", CreateGenericSingleEventCreditDefaultSwap_args);
		}

		// <summary>
		// Create a product that represents the swap of one stream of cash flows for another which may be in different currencies.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="CouponLeg">Product to use as the coupon-bearing leg.</param>
		// <param name="OffsettingLeg">Product to use as the offsetting leg.</param>
		// <param name="ExtraProducts">Set of weighted products to include in addition to the two legs. Default value: default-constructed instance of type weighted_products.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateGenericSwap(object ProductName, object CouponLeg, object OffsettingLeg, object ExtraProducts)
		{

			Hashtable CreateGenericSwap_args = new Hashtable();
			CreateGenericSwap_args.Add("ProductName", ProductName);
			CreateGenericSwap_args.Add("CouponLeg", CouponLeg);
			CreateGenericSwap_args.Add("OffsettingLeg", OffsettingLeg);
			CreateGenericSwap_args.Add("ExtraProducts", ExtraProducts);
			return F3Formatter.f3_style_serialization("CreateGenericSwap", CreateGenericSwap_args);
		}

		// <summary>
		// Create a generic yield convention for bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for measuring the period from the settlement date to the next payment date.</param>
		// <param name="SimpleInLast">Use simple yield for settlement dates in the last payment period. Default value: true.</param>
		// <param name="CompoundingFrequency">The type of compounding to use in the calculation of yield. Default value: Natural.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateGenericYieldConvention(object YieldConventionName, object AccrualConvention, object SimpleInLast, object CompoundingFrequency)
		{

			Hashtable CreateGenericYieldConvention_args = new Hashtable();
			CreateGenericYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateGenericYieldConvention_args.Add("AccrualConvention", AccrualConvention);
			CreateGenericYieldConvention_args.Add("SimpleInLast", SimpleInLast);
			CreateGenericYieldConvention_args.Add("CompoundingFrequency", CompoundingFrequency);
			return F3Formatter.f3_style_serialization("CreateGenericYieldConvention", CreateGenericYieldConvention_args);
		}

		// <summary>
		// Create a geometric average rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingRateIndex">Underlying per-period rate index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <param name="MarketConventions">Market conventions for rate sampling.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateGeometricAverageRateIndex(object IndexName, object UnderlyingRateIndex, object FixingReferencer, object MarketConventions)
		{

			Hashtable CreateGeometricAverageRateIndex_args = new Hashtable();
			CreateGeometricAverageRateIndex_args.Add("IndexName", IndexName);
			CreateGeometricAverageRateIndex_args.Add("UnderlyingRateIndex", UnderlyingRateIndex);
			CreateGeometricAverageRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateGeometricAverageRateIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateGeometricAverageRateIndex", CreateGeometricAverageRateIndex_args);
		}

		// <summary>
		// Create an index whose value is true if the first input is greater than the second.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="FirstIndex">First index in comparison.</param>
		// <param name="SecondIndex">Second index in comparison.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateGreaterThanIndex(object IndexName, object FirstIndex, object SecondIndex)
		{

			Hashtable CreateGreaterThanIndex_args = new Hashtable();
			CreateGreaterThanIndex_args.Add("IndexName", IndexName);
			CreateGreaterThanIndex_args.Add("FirstIndex", FirstIndex);
			CreateGreaterThanIndex_args.Add("SecondIndex", SecondIndex);
			return F3Formatter.f3_style_serialization("CreateGreaterThanIndex", CreateGreaterThanIndex_args);
		}

		// <summary>
		// Create a cache processor that uses a grid connection to external F3 instances.
		// </summary>
		// <param name="CacheProcessorName">Name to use for cache processor.</param>
		// <param name="GridConnection">External grid connection.</param>
		// <returns>Retuns the name of the constructed object of type CacheProcessor.</returns>
		public object CreateGridCacheProcessor(object CacheProcessorName, object GridConnection)
		{

			Hashtable CreateGridCacheProcessor_args = new Hashtable();
			CreateGridCacheProcessor_args.Add("CacheProcessorName", CacheProcessorName);
			CreateGridCacheProcessor_args.Add("GridConnection", GridConnection);
			return F3Formatter.f3_style_serialization("CreateGridCacheProcessor", CreateGridCacheProcessor_args);
		}

		// <summary>
		// Start HTTP server instance for this context..
		// </summary>
		// <param name="ServerName">Object name.</param>
		// <param name="TCPSocket">Socket to use for HTTP server.</param>
		// <param name="PortNumber">Port number to listen on. Default value: 0.</param>
		// <param name="LogFile">Optional target filename for verbose output. The parent directory must exist. Default value: default-constructed instance of type logfile.</param>
		// <returns>Retuns the name of the constructed object of type Server.</returns>
		public object CreateHTTPServer(object ServerName, object TCPSocket, object PortNumber, object LogFile)
		{

			Hashtable CreateHTTPServer_args = new Hashtable();
			CreateHTTPServer_args.Add("ServerName", ServerName);
			CreateHTTPServer_args.Add("TCPSocket", TCPSocket);
			CreateHTTPServer_args.Add("PortNumber", PortNumber);
			CreateHTTPServer_args.Add("LogFile", LogFile);
			return F3Formatter.f3_style_serialization("CreateHTTPServer", CreateHTTPServer_args);
		}

		// <summary>
		// Create a day count convention that returns half the time accrued between two dates based on the underlying convention.
		// </summary>
		// <param name="DayCountName">Name to use for the day counting type.</param>
		// <param name="UnderlyingDayCountConvention">The underlying day count convention.</param>
		// <returns>Retuns the name of the constructed object of type DayCountConvention.</returns>
		public object CreateHalfTimeDayCountConvention(object DayCountName, object UnderlyingDayCountConvention)
		{

			Hashtable CreateHalfTimeDayCountConvention_args = new Hashtable();
			CreateHalfTimeDayCountConvention_args.Add("DayCountName", DayCountName);
			CreateHalfTimeDayCountConvention_args.Add("UnderlyingDayCountConvention", UnderlyingDayCountConvention);
			return F3Formatter.f3_style_serialization("CreateHalfTimeDayCountConvention", CreateHalfTimeDayCountConvention_args);
		}

		// <summary>
		// Create an analytic version of the Heaviside step function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TransitionParameter">Transition parameter.</param>
		// <param name="TransitionParameterTag">Tag to use for the transition parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateHeavisideFunction(object FunctionName, object TransitionParameter, object TransitionParameterTag)
		{

			Hashtable CreateHeavisideFunction_args = new Hashtable();
			CreateHeavisideFunction_args.Add("FunctionName", FunctionName);
			CreateHeavisideFunction_args.Add("TransitionParameter", TransitionParameter);
			CreateHeavisideFunction_args.Add("TransitionParameterTag", TransitionParameterTag);
			return F3Formatter.f3_style_serialization("CreateHeavisideFunction", CreateHeavisideFunction_args);
		}

		// <summary>
		// Create a Heston model modifier that uses Quadratic-Exponential discretization.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of fixing time points.</param>
		// <param name="NumberOfSimulationPoints">Number of time points, in addition to the number of fixing time points, to use in the discretization.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="InitialVariance">Initial variance.</param>
		// <param name="InitialVarianceTag">Tag to use for the initial variance.</param>
		// <param name="LongTermVarianceFunction">Long term variance function.</param>
		// <param name="SpeedOfMeanReversionFunction">Speed of mean reversion function.</param>
		// <param name="VolatilityOfVarianceFunction">Volatility of variance function.</param>
		// <param name="CorrelationFunction">Correlation function.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHestonModifierWithQuadraticExponentialDiscretisation(object ModifierName, object TimePoints, object NumberOfSimulationPoints, object ForwardFunction, object InitialVariance, object InitialVarianceTag, object LongTermVarianceFunction, object SpeedOfMeanReversionFunction, object VolatilityOfVarianceFunction, object CorrelationFunction,
		object UseBrownianBridge)
		{

			Hashtable CreateHestonModifierWithQuadraticExponentialDiscretisation_args = new Hashtable();
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("ModifierName", ModifierName);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("TimePoints", TimePoints);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("NumberOfSimulationPoints", NumberOfSimulationPoints);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("ForwardFunction", ForwardFunction);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("InitialVariance", InitialVariance);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("InitialVarianceTag", InitialVarianceTag);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("LongTermVarianceFunction", LongTermVarianceFunction);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("SpeedOfMeanReversionFunction", SpeedOfMeanReversionFunction);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("VolatilityOfVarianceFunction", VolatilityOfVarianceFunction);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("CorrelationFunction", CorrelationFunction);
			CreateHestonModifierWithQuadraticExponentialDiscretisation_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateHestonModifierWithQuadraticExponentialDiscretisation", CreateHestonModifierWithQuadraticExponentialDiscretisation_args);
		}

		// <summary>
		// Create a state variable template that models a stochastic process according to the Heston model.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateHestonStateVariableTemplate(object StateVariableTemplateName, object UseBrownianBridge)
		{

			Hashtable CreateHestonStateVariableTemplate_args = new Hashtable();
			CreateHestonStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateHestonStateVariableTemplate_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateHestonStateVariableTemplate", CreateHestonStateVariableTemplate_args);
		}

		// <summary>
		// Create a histogram accumulator source.
		// </summary>
		// <param name="AccumulatorName">Name to use for the accumulator source.</param>
		// <param name="HistogramSource">Histogram source.</param>
		// <param name="PercentileLevel">Percentile level.</param>
		// <returns>Retuns the name of the constructed object of type AccumulatorSource.</returns>
		public object CreateHistogramAccumulator(object AccumulatorName, object HistogramSource, object PercentileLevel)
		{

			Hashtable CreateHistogramAccumulator_args = new Hashtable();
			CreateHistogramAccumulator_args.Add("AccumulatorName", AccumulatorName);
			CreateHistogramAccumulator_args.Add("HistogramSource", HistogramSource);
			CreateHistogramAccumulator_args.Add("PercentileLevel", PercentileLevel);
			return F3Formatter.f3_style_serialization("CreateHistogramAccumulator", CreateHistogramAccumulator_args);
		}

		// <summary>
		// Create a valuation specification that provides a policy for constructing histograms within a valuation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Histogram">Form of the histogram to use during valuation.</param>
		// <param name="Percentiles">Percentiles of the distribution to report. Default value: <d>0.01</d><d>0.05</d><d>0.5</d><d>0.95</d><d>0.99</d>.</param>
		// <param name="InterpolationMethod">Interpolation method to use for creating the percentile interpolation function. Default value: LinearWithLinearExtrapolation.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateHistogramValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Histogram, object Percentiles, object InterpolationMethod)
		{

			Hashtable CreateHistogramValuationSpecification_args = new Hashtable();
			CreateHistogramValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateHistogramValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateHistogramValuationSpecification_args.Add("Histogram", Histogram);
			CreateHistogramValuationSpecification_args.Add("Percentiles", Percentiles);
			CreateHistogramValuationSpecification_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("CreateHistogramValuationSpecification", CreateHistogramValuationSpecification_args);
		}

		// <summary>
		// Create a historical prices modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="ParameterValues">Vector of historical prices.</param>
		// <param name="ParameterTag">Tag to use for the historical prices.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHistoricalPricesModifier(object ModifierName, object ParameterValues, object ParameterTag)
		{

			Hashtable CreateHistoricalPricesModifier_args = new Hashtable();
			CreateHistoricalPricesModifier_args.Add("ModifierName", ModifierName);
			CreateHistoricalPricesModifier_args.Add("ParameterValues", ParameterValues);
			CreateHistoricalPricesModifier_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateHistoricalPricesModifier", CreateHistoricalPricesModifier_args);
		}

		// <summary>
		// Create a convexity adjustment function based on the Ho Lee interest rate model.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TermVarianceFunction">Function which returns the variance of change in short rate over time interval.</param>
		// <param name="RateTenor">Tenor in years of underlying rate.</param>
		// <returns>Retuns the name of the constructed object of type ConvexityAdjustmentFunction.</returns>
		public object CreateHoLeeConvexityAdjustmentFunction(object FunctionName, object TermVarianceFunction, object RateTenor)
		{

			Hashtable CreateHoLeeConvexityAdjustmentFunction_args = new Hashtable();
			CreateHoLeeConvexityAdjustmentFunction_args.Add("FunctionName", FunctionName);
			CreateHoLeeConvexityAdjustmentFunction_args.Add("TermVarianceFunction", TermVarianceFunction);
			CreateHoLeeConvexityAdjustmentFunction_args.Add("RateTenor", RateTenor);
			return F3Formatter.f3_style_serialization("CreateHoLeeConvexityAdjustmentFunction", CreateHoLeeConvexityAdjustmentFunction_args);
		}

		// <summary>
		// Create a holiday convention from a list of dates.
		// </summary>
		// <param name="HolidayConventionName">Name to use for the holiday convention.</param>
		// <param name="ListOfDates">List of dates to be used for the holiday convention.</param>
		// <returns>Retuns the name of the constructed object of type HolidayConvention.</returns>
		public object CreateHolidayConventionFromDates(object HolidayConventionName, object ListOfDates)
		{

			Hashtable CreateHolidayConventionFromDates_args = new Hashtable();
			CreateHolidayConventionFromDates_args.Add("HolidayConventionName", HolidayConventionName);
			CreateHolidayConventionFromDates_args.Add("ListOfDates", ListOfDates);
			return F3Formatter.f3_style_serialization("CreateHolidayConventionFromDates", CreateHolidayConventionFromDates_args);
		}

		// <summary>
		// Create a market data set from an instrument type and quote information.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="InstrumentType">Instrument type.</param>
		// <param name="QuoteSpecifications">Vector of quote specifications.</param>
		// <param name="Quotes">Vector of quotes.</param>
		// <param name="MarketDataName">Name of market data element. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of market data element. Default value: default-constructed instance of type marketdata_type.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateHomogeneousMarketDataElement(object MarketDataSetName, object InstrumentType, object QuoteSpecifications, object Quotes, object MarketDataName, object MarketDataType)
		{

			Hashtable CreateHomogeneousMarketDataElement_args = new Hashtable();
			CreateHomogeneousMarketDataElement_args.Add("MarketDataSetName", MarketDataSetName);
			CreateHomogeneousMarketDataElement_args.Add("InstrumentType", InstrumentType);
			CreateHomogeneousMarketDataElement_args.Add("QuoteSpecifications", QuoteSpecifications);
			CreateHomogeneousMarketDataElement_args.Add("Quotes", Quotes);
			CreateHomogeneousMarketDataElement_args.Add("MarketDataName", MarketDataName);
			CreateHomogeneousMarketDataElement_args.Add("MarketDataType", MarketDataType);
			return F3Formatter.f3_style_serialization("CreateHomogeneousMarketDataElement", CreateHomogeneousMarketDataElement_args);
		}

		// <summary>
		// Create a multi-factor Hull-White modifier with a time-varying volatility function and constant mean reversion coefficient for each short rate factor. Integrals are done numerically.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversionValues">Vector of mean reversion coefficients (constants).</param>
		// <param name="MeanReversionTags">Mean reversion tags.</param>
		// <param name="VolatilityFunctions">Vector of short rate volatilities functions.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <param name="IntegrationMethod">The numerical method to evaluate integrals of the short rate volatility function with exponential factor.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteMultiFactorWithNumericalIntegrationModifier(object ModifierName, object TimePoints, object MeanReversionValues, object MeanReversionTags, object VolatilityFunctions, object ForwardMeasureIndex, object DiscountFunction, object IntegrationMethod)
		{

			Hashtable CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args = new Hashtable();
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("MeanReversionValues", MeanReversionValues);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("MeanReversionTags", MeanReversionTags);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("VolatilityFunctions", VolatilityFunctions);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("CreateHullWhiteMultiFactorWithNumericalIntegrationModifier", CreateHullWhiteMultiFactorWithNumericalIntegrationModifier_args);
		}

		// <summary>
		// Create a multi-factor Hull-White modifier with a piecewise-constant volatility function and constant mean reversion coefficient for each short rate factor. Integrals are done analytically.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of simulation time points.</param>
		// <param name="MeanReversionValues">Vector of mean reversion coefficients (constants).</param>
		// <param name="MeanReversionTags">Mean reversion tags.</param>
		// <param name="VolatilityFunctions">Vector of short rate piecewise-constant instantaneous volatility functions.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <param name="TimePointsForVolatilityFunctions">Sets of time points defining the piecewise-constant volatility function for each short factor.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier(object ModifierName, object TimePoints, object MeanReversionValues, object MeanReversionTags, object VolatilityFunctions, object ForwardMeasureIndex, object DiscountFunction, object TimePointsForVolatilityFunctions)
		{

			Hashtable CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args = new Hashtable();
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("MeanReversionValues", MeanReversionValues);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("MeanReversionTags", MeanReversionTags);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("VolatilityFunctions", VolatilityFunctions);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args.Add("TimePointsForVolatilityFunctions", TimePointsForVolatilityFunctions);
			return F3Formatter.f3_style_serialization("CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier", CreateHullWhiteMultiFactorWithPiecewiseConstantVolatilityModifier_args);
		}

		// <summary>
		// Create a state variable template for a multi-factor Hull-White model.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="NumberOfFactors">Number of factors in the Hull-White model.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateHullWhiteStateVariableTemplate(object StateVariableTemplateName, object NumberOfFactors)
		{

			Hashtable CreateHullWhiteStateVariableTemplate_args = new Hashtable();
			CreateHullWhiteStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateHullWhiteStateVariableTemplate_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateHullWhiteStateVariableTemplate", CreateHullWhiteStateVariableTemplate_args);
		}

		// <summary>
		// Create a Hull-White modifier with constant mean reversion coefficient and volatility.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="Volatility">Volatility (constant).</param>
		// <param name="VolatilityTag">Volatility tag.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object Volatility, object VolatilityTag, object ForwardMeasureIndex, object DiscountFunction)
		{

			Hashtable CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args = new Hashtable();
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("MeanReversion", MeanReversion);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("Volatility", Volatility);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("VolatilityTag", VolatilityTag);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args.Add("DiscountFunction", DiscountFunction);
			return F3Formatter.f3_style_serialization("CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier", CreateHullWhiteWithConstantMeanReversionAndVolatilityModifier_args);
		}

		// <summary>
		// Create a Hull-White modifier with a time-varying volatility function and a constant mean reversion coefficient. Integrals are done numerically.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="VolatilityFunction">Short rate volatility function.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <param name="IntegrationMethod">The numerical method to evaluate integrals of the short rate volatility function with exponential factor.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteWithNumericalIntegrationModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object VolatilityFunction, object ForwardMeasureIndex, object DiscountFunction, object IntegrationMethod)
		{

			Hashtable CreateHullWhiteWithNumericalIntegrationModifier_args = new Hashtable();
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("MeanReversion", MeanReversion);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateHullWhiteWithNumericalIntegrationModifier_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("CreateHullWhiteWithNumericalIntegrationModifier", CreateHullWhiteWithNumericalIntegrationModifier_args);
		}

		// <summary>
		// Create a Hull-White modifier with a time-varying volatility function and a constant mean reversion coefficient. Integrals are done analytically assuming piecewise-constant instantaneous volatility.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="VolatilityFunction">Short rate volatility function.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <param name="TimePointsForVolatilityFunction">Time points defining the piecewise-constant volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object VolatilityFunction, object ForwardMeasureIndex, object DiscountFunction, object TimePointsForVolatilityFunction)
		{

			Hashtable CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args = new Hashtable();
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("MeanReversion", MeanReversion);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("TimePointsForVolatilityFunction", TimePointsForVolatilityFunction);
			return F3Formatter.f3_style_serialization("CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier", CreateHullWhiteWithPiecewiseConstantInstantaneousVolatilityModifier_args);
		}

		// <summary>
		// Create a multi-factor Hull-White modifier with a piecewise-linear volatility function and constant mean reversion coefficient. Integrals are done analytically.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of simulation time points.</param>
		// <param name="MeanReversion">Mean reversion coefficients (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="VolatilityFunction">Short rate piecewise-linear instantaneous volatility function.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="DiscountFunction">Zero curve (discount factor curve) as a real function.</param>
		// <param name="TimePointsForVolatilityFunctions">Time points defining the piecewise-linear volatility function for each short rate factor.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHullWhiteWithPiecewiseLinearVolatilityModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object VolatilityFunction, object ForwardMeasureIndex, object DiscountFunction, object TimePointsForVolatilityFunctions)
		{

			Hashtable CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args = new Hashtable();
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("MeanReversion", MeanReversion);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args.Add("TimePointsForVolatilityFunctions", TimePointsForVolatilityFunctions);
			return F3Formatter.f3_style_serialization("CreateHullWhiteWithPiecewiseLinearVolatilityModifier", CreateHullWhiteWithPiecewiseLinearVolatilityModifier_args);
		}

		// <summary>
		// Create a correlation modifier for hybrid modeling.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="StateVariableOrderings">State variable ordering objects.</param>
		// <param name="CorrelationMatrices">Collection of correlation matrices or factor loadings.</param>
		// <param name="CorrelationParameterTag">Tag to use for correlation parameters.</param>
		// <param name="CorrelationSpecification">Method to correlate the underlying random numbers. Default value: Cholesky.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateHybridCorrelationModifier(object ModifierName, object StateVariableOrderings, object CorrelationMatrices, object CorrelationParameterTag, object CorrelationSpecification)
		{

			Hashtable CreateHybridCorrelationModifier_args = new Hashtable();
			CreateHybridCorrelationModifier_args.Add("ModifierName", ModifierName);
			CreateHybridCorrelationModifier_args.Add("StateVariableOrderings", StateVariableOrderings);
			CreateHybridCorrelationModifier_args.Add("CorrelationMatrices", CorrelationMatrices);
			CreateHybridCorrelationModifier_args.Add("CorrelationParameterTag", CorrelationParameterTag);
			CreateHybridCorrelationModifier_args.Add("CorrelationSpecification", CorrelationSpecification);
			return F3Formatter.f3_style_serialization("CreateHybridCorrelationModifier", CreateHybridCorrelationModifier_args);
		}

		// <summary>
		// Create a market convention incorporating standard ISDA CDS features.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="RollLength">Length of roll period in months.</param>
		// <param name="DayCountConvention">Day count convention.</param>
		// <param name="StubType">Stub type. Default value: StubAtStart.</param>
		// <param name="RemoveStub">TRUE if the stub period is replaced with full periods if the first period is a stub period. Default value: false.</param>
		// <param name="BusinessDayConvention">Date adjustment convention.</param>
		// <param name="MoveTo20th">True if this market convention adjusts a date to the 20th in the same month.</param>
		// <param name="Holidays">Holiday conventions to define business days.</param>
		// <param name="SingleRoll">True if this market convention creates a single roll.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateISDAStandardCDSMarketConvention(object MarketConventionName, object RollLength, object DayCountConvention, object StubType, object RemoveStub, object BusinessDayConvention, object MoveTo20th, object Holidays, object SingleRoll)
		{

			Hashtable CreateISDAStandardCDSMarketConvention_args = new Hashtable();
			CreateISDAStandardCDSMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateISDAStandardCDSMarketConvention_args.Add("RollLength", RollLength);
			CreateISDAStandardCDSMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			CreateISDAStandardCDSMarketConvention_args.Add("StubType", StubType);
			CreateISDAStandardCDSMarketConvention_args.Add("RemoveStub", RemoveStub);
			CreateISDAStandardCDSMarketConvention_args.Add("BusinessDayConvention", BusinessDayConvention);
			CreateISDAStandardCDSMarketConvention_args.Add("MoveTo20th", MoveTo20th);
			CreateISDAStandardCDSMarketConvention_args.Add("Holidays", Holidays);
			CreateISDAStandardCDSMarketConvention_args.Add("SingleRoll", SingleRoll);
			return F3Formatter.f3_style_serialization("CreateISDAStandardCDSMarketConvention", CreateISDAStandardCDSMarketConvention_args);
		}

		// <summary>
		// Create a valuation specification that is needed for the ISDA CDS model.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="CashSettlementMaturity">Specification of the cash settlement date.</param>
		// <param name="StepInMaturity">Specification of the time at which protection begins.</param>
		// <param name="MaturityCalculator">Calculator for adjusting dates.</param>
		// <param name="DayCountConvention">The day count convention that will be applied to the forward shift and simple accrual convention.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateISDAStandardCDSValuationSpecification(object ValuationMethod, object CashSettlementMaturity, object StepInMaturity, object MaturityCalculator, object DayCountConvention)
		{

			Hashtable CreateISDAStandardCDSValuationSpecification_args = new Hashtable();
			CreateISDAStandardCDSValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateISDAStandardCDSValuationSpecification_args.Add("CashSettlementMaturity", CashSettlementMaturity);
			CreateISDAStandardCDSValuationSpecification_args.Add("StepInMaturity", StepInMaturity);
			CreateISDAStandardCDSValuationSpecification_args.Add("MaturityCalculator", MaturityCalculator);
			CreateISDAStandardCDSValuationSpecification_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateISDAStandardCDSValuationSpecification", CreateISDAStandardCDSValuationSpecification_args);
		}

		// <summary>
		// Create an instrument strategy from an instrument list.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="InstrumenIdentifiertList">Vector of market data instrument identifiers.</param>
		// <param name="QuoteSpecOrdering">Quote ordering source. Default value: SingleMaturity.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateIdentifierListInstrumentStrategy(object StrategyName, object InstrumenIdentifiertList, object QuoteSpecOrdering)
		{

			Hashtable CreateIdentifierListInstrumentStrategy_args = new Hashtable();
			CreateIdentifierListInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateIdentifierListInstrumentStrategy_args.Add("InstrumenIdentifiertList", InstrumenIdentifiertList);
			CreateIdentifierListInstrumentStrategy_args.Add("QuoteSpecOrdering", QuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("CreateIdentifierListInstrumentStrategy", CreateIdentifierListInstrumentStrategy_args);
		}

		// <summary>
		// Create a valuation specification that ignores the spread when simulating a rate.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateIgnoredRateSpreadsValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod)
		{

			Hashtable CreateIgnoredRateSpreadsValuationSpecification_args = new Hashtable();
			CreateIgnoredRateSpreadsValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateIgnoredRateSpreadsValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			return F3Formatter.f3_style_serialization("CreateIgnoredRateSpreadsValuationSpecification", CreateIgnoredRateSpreadsValuationSpecification_args);
		}

		// <summary>
		// Create an immediate version of an FX rate index.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="UnderlyingFXIndex">Underlying FX index.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateImmediateFXRateIndex(object IndexName, object UnderlyingFXIndex)
		{

			Hashtable CreateImmediateFXRateIndex_args = new Hashtable();
			CreateImmediateFXRateIndex_args.Add("IndexName", IndexName);
			CreateImmediateFXRateIndex_args.Add("UnderlyingFXIndex", UnderlyingFXIndex);
			return F3Formatter.f3_style_serialization("CreateImmediateFXRateIndex", CreateImmediateFXRateIndex_args);
		}

		// <summary>
		// Create a modifier whose outputs are correlated based on the input values.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="BlackVolatilityFunction">Black volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateImpliedBlackCorrelatedPathModifier(object ModifierName, object TimePoints, object BlackVolatilityFunction)
		{

			Hashtable CreateImpliedBlackCorrelatedPathModifier_args = new Hashtable();
			CreateImpliedBlackCorrelatedPathModifier_args.Add("ModifierName", ModifierName);
			CreateImpliedBlackCorrelatedPathModifier_args.Add("TimePoints", TimePoints);
			CreateImpliedBlackCorrelatedPathModifier_args.Add("BlackVolatilityFunction", BlackVolatilityFunction);
			return F3Formatter.f3_style_serialization("CreateImpliedBlackCorrelatedPathModifier", CreateImpliedBlackCorrelatedPathModifier_args);
		}

		// <summary>
		// Create a two-dimensional function of implied Black correlation between two time points.
		// </summary>
		// <param name="Function">Name to use for the function.</param>
		// <param name="VolatilityCurve">One-dimensional volatility term structure.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateImpliedBlackCorrelationSurface(object Function_name, object VolatilityCurve)
		{

			Hashtable CreateImpliedBlackCorrelationSurface_args = new Hashtable();
			CreateImpliedBlackCorrelationSurface_args.Add("Function", Function_name);
			CreateImpliedBlackCorrelationSurface_args.Add("VolatilityCurve", VolatilityCurve);
			return F3Formatter.f3_style_serialization("CreateImpliedBlackCorrelationSurface", CreateImpliedBlackCorrelationSurface_args);
		}

		// <summary>
		// Create an index representing an implied funding rate.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="NumeraireCurrency">Numeraire currency of the funding.</param>
		// <param name="CollateralAgreement">The collateral agreement associated with the funding rate.</param>
		// <param name="MarketConventions">Market conventions for the rate.</param>
		// <param name="FixingReferencer">Index referencer. Default value: default-constructed instance of type referencer.</param>
		// <param name="OptionalFixingTableName">Optional name for the fixings table associated with the index. Default value: default-constructed instance of type fixings_name.</param>
		// <param name="OptionalCurveReferenceName">Optional name for the curve associated with the index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateImpliedFundingRateIndex(object IndexName, object NumeraireCurrency, object CollateralAgreement, object MarketConventions, object FixingReferencer, object OptionalFixingTableName, object OptionalCurveReferenceName)
		{

			Hashtable CreateImpliedFundingRateIndex_args = new Hashtable();
			CreateImpliedFundingRateIndex_args.Add("IndexName", IndexName);
			CreateImpliedFundingRateIndex_args.Add("NumeraireCurrency", NumeraireCurrency);
			CreateImpliedFundingRateIndex_args.Add("CollateralAgreement", CollateralAgreement);
			CreateImpliedFundingRateIndex_args.Add("MarketConventions", MarketConventions);
			CreateImpliedFundingRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateImpliedFundingRateIndex_args.Add("OptionalFixingTableName", OptionalFixingTableName);
			CreateImpliedFundingRateIndex_args.Add("OptionalCurveReferenceName", OptionalCurveReferenceName);
			return F3Formatter.f3_style_serialization("CreateImpliedFundingRateIndex", CreateImpliedFundingRateIndex_args);
		}

		// <summary>
		// Create an incomplete gamma function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ParameterValue">Value of the parameter.</param>
		// <param name="ParameterTag">Tag to use for the parameter value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateIncompleteGammaFunction(object FunctionName, object ParameterValue, object ParameterTag)
		{

			Hashtable CreateIncompleteGammaFunction_args = new Hashtable();
			CreateIncompleteGammaFunction_args.Add("FunctionName", FunctionName);
			CreateIncompleteGammaFunction_args.Add("ParameterValue", ParameterValue);
			CreateIncompleteGammaFunction_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateIncompleteGammaFunction", CreateIncompleteGammaFunction_args);
		}

		// <summary>
		// Create a set of unilateral collateralization rules that exclusively relate to the posting                                                                              of an independent amount of collateral.
		// </summary>
		// <param name="ObjectName">Name to use for the constructed object.</param>
		// <param name="BaseCurrency">Currency in which collateral is to be denominated.</param>
		// <param name="IndependentAmount">Upfront payment from the party posting collateral. Default value: 0.0.</param>
		// <param name="PostingParty">Party that posts collateral. Default value: Counterparty.</param>
		// <returns>Retuns the name of the constructed object of type CollateralAgreement.</returns>
		public object CreateIndependentAmountCollateralAgreement(object ObjectName, object BaseCurrency, object IndependentAmount, object PostingParty)
		{

			Hashtable CreateIndependentAmountCollateralAgreement_args = new Hashtable();
			CreateIndependentAmountCollateralAgreement_args.Add("ObjectName", ObjectName);
			CreateIndependentAmountCollateralAgreement_args.Add("BaseCurrency", BaseCurrency);
			CreateIndependentAmountCollateralAgreement_args.Add("IndependentAmount", IndependentAmount);
			CreateIndependentAmountCollateralAgreement_args.Add("PostingParty", PostingParty);
			return F3Formatter.f3_style_serialization("CreateIndependentAmountCollateralAgreement", CreateIndependentAmountCollateralAgreement_args);
		}

		// <summary>
		// Create an index formed from another index or index expression.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="UnderlyingIndex">Underlying index or expression.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndex(object IndexName, object UnderlyingIndex)
		{

			Hashtable CreateIndex_args = new Hashtable();
			CreateIndex_args.Add("IndexName", IndexName);
			CreateIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("CreateIndex", CreateIndex_args);
		}

		// <summary>
		// Create a market data set containing a set of credit portfolio index swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="CreditContracts">Vector of credit contracts.</param>
		// <param name="SwapRates">Vector of CDS premia.</param>
		// <param name="Currency">Currency of CDS.</param>
		// <param name="MarketDataName">Name used to identify the CDS market data in a Model.</param>
		// <param name="MarketDataType">Type (string) used to identify the CDS market data in a Model.</param>
		// <param name="MarketConventions">Market conventions for premium leg.</param>
		// <param name="PayAccrued">Switch for whether or not to pay accrued interest upon default. Default value: true.</param>
		// <param name="OffsettingLegMarketConventions">Market conventions for the offsetting (default) leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateIndexCDSMarketData(object MarketDataSetName, object CreditContracts, object SwapRates, object Currency, object MarketDataName, object MarketDataType, object MarketConventions, object PayAccrued, object OffsettingLegMarketConventions, object QuoteDate)
		{

			Hashtable CreateIndexCDSMarketData_args = new Hashtable();
			CreateIndexCDSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateIndexCDSMarketData_args.Add("CreditContracts", CreditContracts);
			CreateIndexCDSMarketData_args.Add("SwapRates", SwapRates);
			CreateIndexCDSMarketData_args.Add("Currency", Currency);
			CreateIndexCDSMarketData_args.Add("MarketDataName", MarketDataName);
			CreateIndexCDSMarketData_args.Add("MarketDataType", MarketDataType);
			CreateIndexCDSMarketData_args.Add("MarketConventions", MarketConventions);
			CreateIndexCDSMarketData_args.Add("PayAccrued", PayAccrued);
			CreateIndexCDSMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			CreateIndexCDSMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateIndexCDSMarketData", CreateIndexCDSMarketData_args);
		}

		// <summary>
		// Create a market data set containing fixings information for a specified index.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Fixings">Fixing data to store within market data set.</param>
		// <param name="FixingsIndex">The index for which fixings will be provided.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateIndexFixingsMarketData(object MarketDataSetName, object Fixings, object FixingsIndex)
		{

			Hashtable CreateIndexFixingsMarketData_args = new Hashtable();
			CreateIndexFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateIndexFixingsMarketData_args.Add("Fixings", Fixings);
			CreateIndexFixingsMarketData_args.Add("FixingsIndex", FixingsIndex);
			return F3Formatter.f3_style_serialization("CreateIndexFixingsMarketData", CreateIndexFixingsMarketData_args);
		}

		// <summary>
		// Create an index from a FITR specification.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="FITRSpecification">Input file, or other stream-based resource, containing FITR representation of index.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndexFromFITR(object IndexName, object FITRSpecification, object RefSpec)
		{

			Hashtable CreateIndexFromFITR_args = new Hashtable();
			CreateIndexFromFITR_args.Add("IndexName", IndexName);
			CreateIndexFromFITR_args.Add("FITRSpecification", FITRSpecification);
			CreateIndexFromFITR_args.Add("RefSpec", RefSpec);
			return F3Formatter.f3_style_serialization("CreateIndexFromFITR", CreateIndexFromFITR_args);
		}

		// <summary>
		// Create an index from a FITR specification in text form.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="FITRSpecification">FITR representation of index, as a string or array of strings.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndexFromFITRText(object IndexName, object FITRSpecification, object RefSpec)
		{

			Hashtable CreateIndexFromFITRText_args = new Hashtable();
			CreateIndexFromFITRText_args.Add("IndexName", IndexName);
			CreateIndexFromFITRText_args.Add("FITRSpecification", FITRSpecification);
			CreateIndexFromFITRText_args.Add("RefSpec", RefSpec);
			return F3Formatter.f3_style_serialization("CreateIndexFromFITRText", CreateIndexFromFITRText_args);
		}

		// <summary>
		// Create an index from a FLIRST specification.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="FLIRSTRepresentation">Input file, or other stream-based resource, containing FLIRST representation of index.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndexFromFLIRST(object IndexName, object FLIRSTRepresentation, object RefSpec)
		{

			Hashtable CreateIndexFromFLIRST_args = new Hashtable();
			CreateIndexFromFLIRST_args.Add("IndexName", IndexName);
			CreateIndexFromFLIRST_args.Add("FLIRSTRepresentation", FLIRSTRepresentation);
			CreateIndexFromFLIRST_args.Add("RefSpec", RefSpec);
			return F3Formatter.f3_style_serialization("CreateIndexFromFLIRST", CreateIndexFromFLIRST_args);
		}

		// <summary>
		// Create an index from a FLIRST specification in text form.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="FLIRSTRepresentation">FLIRST representation of index, as a string or array of strings.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndexFromFLIRSTText(object IndexName, object FLIRSTRepresentation, object RefSpec)
		{

			Hashtable CreateIndexFromFLIRSTText_args = new Hashtable();
			CreateIndexFromFLIRSTText_args.Add("IndexName", IndexName);
			CreateIndexFromFLIRSTText_args.Add("FLIRSTRepresentation", FLIRSTRepresentation);
			CreateIndexFromFLIRSTText_args.Add("RefSpec", RefSpec);
			return F3Formatter.f3_style_serialization("CreateIndexFromFLIRSTText", CreateIndexFromFLIRSTText_args);
		}

		// <summary>
		// Create an index referencer.
		// </summary>
		// <param name="ReferencerName">Name to use for referencer.</param>
		// <param name="ReferencerDefinition">Index referencer definition to use.</param>
		// <returns>Retuns the name of the constructed object of type IndexReferencer.</returns>
		public object CreateIndexReferencer(object ReferencerName, object ReferencerDefinition)
		{

			Hashtable CreateIndexReferencer_args = new Hashtable();
			CreateIndexReferencer_args.Add("ReferencerName", ReferencerName);
			CreateIndexReferencer_args.Add("ReferencerDefinition", ReferencerDefinition);
			return F3Formatter.f3_style_serialization("CreateIndexReferencer", CreateIndexReferencer_args);
		}

		// <summary>
		// Create an index with a different referencer.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying index to use with new the referencer.</param>
		// <param name="Referencer">Index referencer to use.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateIndexWithDifferentReferencer(object IndexName, object UnderlyingIndex, object Referencer)
		{

			Hashtable CreateIndexWithDifferentReferencer_args = new Hashtable();
			CreateIndexWithDifferentReferencer_args.Add("IndexName", IndexName);
			CreateIndexWithDifferentReferencer_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateIndexWithDifferentReferencer_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateIndexWithDifferentReferencer", CreateIndexWithDifferentReferencer_args);
		}

		// <summary>
		// Create a single currency inflation-linked capital-indexed bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="MarketConventions">Market conventions for coupon schedule.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <param name="BaseInflationReferencer">Referencer used to form the base inflation index. Default value: default-constructed instance of type referencer.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateInflationLinkedCapitalIndexedBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object MarketConventions, object UniqueID, object BaseInflationReferencer)
		{

			Hashtable CreateInflationLinkedCapitalIndexedBondType_args = new Hashtable();
			CreateInflationLinkedCapitalIndexedBondType_args.Add("BondTypeName", BondTypeName);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("YieldConvention", YieldConvention);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("Currency", Currency);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("MarketConventions", MarketConventions);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("UniqueID", UniqueID);
			CreateInflationLinkedCapitalIndexedBondType_args.Add("BaseInflationReferencer", BaseInflationReferencer);
			return F3Formatter.f3_style_serialization("CreateInflationLinkedCapitalIndexedBondType", CreateInflationLinkedCapitalIndexedBondType_args);
		}

		// <summary>
		// Create a single currency inflation-linked coupon-indexed bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="MarketConventions">Market conventions for coupon schedule.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateInflationLinkedCouponIndexedBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object MarketConventions, object UniqueID)
		{

			Hashtable CreateInflationLinkedCouponIndexedBondType_args = new Hashtable();
			CreateInflationLinkedCouponIndexedBondType_args.Add("BondTypeName", BondTypeName);
			CreateInflationLinkedCouponIndexedBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateInflationLinkedCouponIndexedBondType_args.Add("YieldConvention", YieldConvention);
			CreateInflationLinkedCouponIndexedBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateInflationLinkedCouponIndexedBondType_args.Add("Currency", Currency);
			CreateInflationLinkedCouponIndexedBondType_args.Add("MarketConventions", MarketConventions);
			CreateInflationLinkedCouponIndexedBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateInflationLinkedCouponIndexedBondType", CreateInflationLinkedCouponIndexedBondType_args);
		}

		// <summary>
		// Create a valuation specification that defines time calculators for use in inflation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="InflationTimeCalculator">Time calculator for the inflation curve.</param>
		// <param name="SeasonalityTimeCalculator">Time calculator for the seasonality curve.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateInflationTimeCalculatorValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object InflationTimeCalculator, object SeasonalityTimeCalculator)
		{

			Hashtable CreateInflationTimeCalculatorValuationSpecification_args = new Hashtable();
			CreateInflationTimeCalculatorValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateInflationTimeCalculatorValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateInflationTimeCalculatorValuationSpecification_args.Add("InflationTimeCalculator", InflationTimeCalculator);
			CreateInflationTimeCalculatorValuationSpecification_args.Add("SeasonalityTimeCalculator", SeasonalityTimeCalculator);
			return F3Formatter.f3_style_serialization("CreateInflationTimeCalculatorValuationSpecification", CreateInflationTimeCalculatorValuationSpecification_args);
		}

		// <summary>
		// Create a market convention that generates schedules using different market conventions in different periods.
		// </summary>
		// <param name="MarketConventionName">Name to use for the market convention.</param>
		// <param name="MainConvention">Main underlying market convention.</param>
		// <param name="RollConventions">Market conventions for roll generation. Default value: default-constructed instance of type market_conventions_collection.</param>
		// <param name="PeriodLengths">Maturities specifying the length of each period for which the roll conventions are to be applied. Default value: default-constructed instance of type maturity_descriptors.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateInhomogeneousMarketConvention(object MarketConventionName, object MainConvention, object RollConventions, object PeriodLengths)
		{

			Hashtable CreateInhomogeneousMarketConvention_args = new Hashtable();
			CreateInhomogeneousMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateInhomogeneousMarketConvention_args.Add("MainConvention", MainConvention);
			CreateInhomogeneousMarketConvention_args.Add("RollConventions", RollConventions);
			CreateInhomogeneousMarketConvention_args.Add("PeriodLengths", PeriodLengths);
			return F3Formatter.f3_style_serialization("CreateInhomogeneousMarketConvention", CreateInhomogeneousMarketConvention_args);
		}

		// <summary>
		// Creates a new inproceedings bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the inproceedings bibliography entry.</param>
		// <param name="Author">Author to use for the inproceedings bibliography entry.</param>
		// <param name="Year">Year to use for the inproceedings bibliography entry.</param>
		// <param name="Title">Title to use for the inproceedings bibliography entry.</param>
		// <param name="Book">Book to use for the inproceedings bibliography entry.</param>
		// <param name="Publisher">Publisher to use for the inproceedings bibliography entry.</param>
		// <param name="Pages">Pages to use for the inproceedings bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateInproceedingsBibliographyEntry(object Name, object Author, object Year, object Title, object Book, object Publisher, object Pages)
		{

			Hashtable CreateInproceedingsBibliographyEntry_args = new Hashtable();
			CreateInproceedingsBibliographyEntry_args.Add("Name", Name);
			CreateInproceedingsBibliographyEntry_args.Add("Author", Author);
			CreateInproceedingsBibliographyEntry_args.Add("Year", Year);
			CreateInproceedingsBibliographyEntry_args.Add("Title", Title);
			CreateInproceedingsBibliographyEntry_args.Add("Book", Book);
			CreateInproceedingsBibliographyEntry_args.Add("Publisher", Publisher);
			CreateInproceedingsBibliographyEntry_args.Add("Pages", Pages);
			return F3Formatter.f3_style_serialization("CreateInproceedingsBibliographyEntry", CreateInproceedingsBibliographyEntry_args);
		}

		// <summary>
		// Create input-output type metadata for alternative possible underlyings.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="Underlyings">Collection of alternative underlying types.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeAlternativesMetaData(object InputOutputTypeName, object Underlyings)
		{

			Hashtable CreateInputOutputTypeAlternativesMetaData_args = new Hashtable();
			CreateInputOutputTypeAlternativesMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeAlternativesMetaData_args.Add("Underlyings", Underlyings);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeAlternativesMetaData", CreateInputOutputTypeAlternativesMetaData_args);
		}

		// <summary>
		// Create input-output type metadata for basic input.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="ShortName">Short name for the basic type.</param>
		// <param name="Description">Text description of the basic type.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeBasicMetaData(object InputOutputTypeName, object ShortName, object Description)
		{

			Hashtable CreateInputOutputTypeBasicMetaData_args = new Hashtable();
			CreateInputOutputTypeBasicMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeBasicMetaData_args.Add("ShortName", ShortName);
			CreateInputOutputTypeBasicMetaData_args.Add("Description", Description);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeBasicMetaData", CreateInputOutputTypeBasicMetaData_args);
		}

		// <summary>
		// Create input-output type metadata for documentation.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="DisplayName">The display name for the object.</param>
		// <param name="Summary">The summary for the object.</param>
		// <param name="Description">The description for the object.</param>
		// <param name="FromRepositoryName">Repository in which the values for this argument type refers to its members. If omitted then the type is considered to not be from a repository..</param>
		// <param name="Requests">The description of the requests for the object.</param>
		// <param name="Delegates">The description of the delegates for the object.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeDocumentationMetaData(object InputOutputTypeName, object DisplayName, object Summary, object Description, object FromRepositoryName, object Requests, object Delegates)
		{

			Hashtable CreateInputOutputTypeDocumentationMetaData_args = new Hashtable();
			CreateInputOutputTypeDocumentationMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeDocumentationMetaData_args.Add("DisplayName", DisplayName);
			CreateInputOutputTypeDocumentationMetaData_args.Add("Summary", Summary);
			CreateInputOutputTypeDocumentationMetaData_args.Add("Description", Description);
			CreateInputOutputTypeDocumentationMetaData_args.Add("FromRepositoryName", FromRepositoryName);
			CreateInputOutputTypeDocumentationMetaData_args.Add("Requests", Requests);
			CreateInputOutputTypeDocumentationMetaData_args.Add("Delegates", Delegates);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeDocumentationMetaData", CreateInputOutputTypeDocumentationMetaData_args);
		}

		// <summary>
		// Create input-output type metadata for chained underlyings.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="Constituents">Ordered chained underlying types.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeMultipleMetaData(object InputOutputTypeName, object Constituents)
		{

			Hashtable CreateInputOutputTypeMultipleMetaData_args = new Hashtable();
			CreateInputOutputTypeMultipleMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeMultipleMetaData_args.Add("Constituents", Constituents);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeMultipleMetaData", CreateInputOutputTypeMultipleMetaData_args);
		}

		// <summary>
		// Create input-output type metadata for a repository.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="RepositoryName">Repository name.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeRepositoryMetaData(object InputOutputTypeName, object RepositoryName)
		{

			Hashtable CreateInputOutputTypeRepositoryMetaData_args = new Hashtable();
			CreateInputOutputTypeRepositoryMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeRepositoryMetaData_args.Add("RepositoryName", RepositoryName);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeRepositoryMetaData", CreateInputOutputTypeRepositoryMetaData_args);
		}

		// <summary>
		// Create input-output type metadata for repeated input.
		// </summary>
		// <param name="InputOutputTypeName">Name to use for created metadata object.</param>
		// <param name="UnderlyingType">Underlying type metadata.</param>
		// <returns>Retuns the name of the constructed object of type InputOutputType.</returns>
		public object CreateInputOutputTypeVectorMetaData(object InputOutputTypeName, object UnderlyingType)
		{

			Hashtable CreateInputOutputTypeVectorMetaData_args = new Hashtable();
			CreateInputOutputTypeVectorMetaData_args.Add("InputOutputTypeName", InputOutputTypeName);
			CreateInputOutputTypeVectorMetaData_args.Add("UnderlyingType", UnderlyingType);
			return F3Formatter.f3_style_serialization("CreateInputOutputTypeVectorMetaData", CreateInputOutputTypeVectorMetaData_args);
		}

		// <summary>
		// Create a product representing a physical option on a vanilla instrument.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Expiry">Expiry of the option.</param>
		// <param name="Instrument">Market data instrument describing the underlying product.</param>
		// <param name="Payoff">Option payoff specification.</param>
		// <param name="Notional">Notional amount of the product underlying the option.</param>
		// <param name="BuySell">Buy or sell the option.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateInstrumentOptionProduct(object ProductName, object Expiry, object Instrument, object Payoff, object Notional, object BuySell)
		{

			Hashtable CreateInstrumentOptionProduct_args = new Hashtable();
			CreateInstrumentOptionProduct_args.Add("ProductName", ProductName);
			CreateInstrumentOptionProduct_args.Add("Expiry", Expiry);
			CreateInstrumentOptionProduct_args.Add("Instrument", Instrument);
			CreateInstrumentOptionProduct_args.Add("Payoff", Payoff);
			CreateInstrumentOptionProduct_args.Add("Notional", Notional);
			CreateInstrumentOptionProduct_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateInstrumentOptionProduct", CreateInstrumentOptionProduct_args);
		}

		// <summary>
		// Create a product from an instrument and a trade date.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="TradeDate">Trade date of the instrument.</param>
		// <param name="Instrument">Market data instrument.</param>
		// <param name="Notional">Notional amount of the product. Default value: 1000000.</param>
		// <param name="PayRec">Pay/Receive or Buy/Sell specification. Default value: pay.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateInstrumentProduct(object ProductName, object TradeDate, object Instrument, object Notional, object PayRec)
		{

			Hashtable CreateInstrumentProduct_args = new Hashtable();
			CreateInstrumentProduct_args.Add("ProductName", ProductName);
			CreateInstrumentProduct_args.Add("TradeDate", TradeDate);
			CreateInstrumentProduct_args.Add("Instrument", Instrument);
			CreateInstrumentProduct_args.Add("Notional", Notional);
			CreateInstrumentProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateInstrumentProduct", CreateInstrumentProduct_args);
		}

		// <summary>
		// Form an instrument strategy as a container of one or more underlying strategies.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="Constituents">List of instrument strategies.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateInstrumentStrategyCollection(object StrategyName, object Constituents)
		{

			Hashtable CreateInstrumentStrategyCollection_args = new Hashtable();
			CreateInstrumentStrategyCollection_args.Add("StrategyName", StrategyName);
			CreateInstrumentStrategyCollection_args.Add("Constituents", Constituents);
			return F3Formatter.f3_style_serialization("CreateInstrumentStrategyCollection", CreateInstrumentStrategyCollection_args);
		}

		// <summary>
		// Create an instrument strategy from an instrument list.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateInstrumentStrategyList(object StrategyName, object InstrumentList)
		{

			Hashtable CreateInstrumentStrategyList_args = new Hashtable();
			CreateInstrumentStrategyList_args.Add("StrategyName", StrategyName);
			CreateInstrumentStrategyList_args.Add("InstrumentList", InstrumentList);
			return F3Formatter.f3_style_serialization("CreateInstrumentStrategyList", CreateInstrumentStrategyList_args);
		}

		// <summary>
		// Create a modified Bessel function of integer order.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Order">Order n.</param>
		// <param name="OrderParameterTag">Tag to use for the order value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateIntegerOrderModifiedBesselFunction(object FunctionName, object Order, object OrderParameterTag)
		{

			Hashtable CreateIntegerOrderModifiedBesselFunction_args = new Hashtable();
			CreateIntegerOrderModifiedBesselFunction_args.Add("FunctionName", FunctionName);
			CreateIntegerOrderModifiedBesselFunction_args.Add("Order", Order);
			CreateIntegerOrderModifiedBesselFunction_args.Add("OrderParameterTag", OrderParameterTag);
			return F3Formatter.f3_style_serialization("CreateIntegerOrderModifiedBesselFunction", CreateIntegerOrderModifiedBesselFunction_args);
		}

		// <summary>
		// Create a function that returns the integral of another from a given lower limit. The argument of the function forms the upper limit.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Integrand">One-dimensional function to be integrated.</param>
		// <param name="LowerLimit">Lower limit for the integral.</param>
		// <param name="Method">The numerical method to evaluate the integral.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateIntegratedFunction(object FunctionName, object Integrand, object LowerLimit, object Method)
		{

			Hashtable CreateIntegratedFunction_args = new Hashtable();
			CreateIntegratedFunction_args.Add("FunctionName", FunctionName);
			CreateIntegratedFunction_args.Add("Integrand", Integrand);
			CreateIntegratedFunction_args.Add("LowerLimit", LowerLimit);
			CreateIntegratedFunction_args.Add("Method", Method);
			return F3Formatter.f3_style_serialization("CreateIntegratedFunction", CreateIntegratedFunction_args);
		}

		// <summary>
		// Create a single currency interest rate caplet or floorlet.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="RateIndex">Index describing the underlying interest rate.</param>
		// <param name="Strike">Strike specification.</param>
		// <param name="Expiry">Expiry of the option.</param>
		// <param name="Notional">Notional amount of the product.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="CallPut">Call is a caplet and Put is a floorlet.</param>
		// <param name="BuySell">Flag indicating buying or selling the product.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateInterestRateCaplet(object ProductName, object RateIndex, object Strike, object Expiry, object Notional, object Currency, object CallPut, object BuySell)
		{

			Hashtable CreateInterestRateCaplet_args = new Hashtable();
			CreateInterestRateCaplet_args.Add("ProductName", ProductName);
			CreateInterestRateCaplet_args.Add("RateIndex", RateIndex);
			CreateInterestRateCaplet_args.Add("Strike", Strike);
			CreateInterestRateCaplet_args.Add("Expiry", Expiry);
			CreateInterestRateCaplet_args.Add("Notional", Notional);
			CreateInterestRateCaplet_args.Add("Currency", Currency);
			CreateInterestRateCaplet_args.Add("CallPut", CallPut);
			CreateInterestRateCaplet_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateInterestRateCaplet", CreateInterestRateCaplet_args);
		}

		// <summary>
		// Create a market data set containing a set of interest rate futures positions.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="FuturesContractType">Type of futures contract. Default value: Standard.</param>
		// <param name="Maturities">Vector of maturity descriptors for spot date to forward start date.</param>
		// <param name="TradedPrices">Vector of prices for the futures trades.</param>
		// <param name="TagName">Name of futures market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="TagType">Type of futures market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="Underlying">Futures underlying.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateInterestRateFuturesMarketData(object MarketDataSetName, object FuturesContractType, object Maturities, object TradedPrices, object TagName, object TagType, object Underlying)
		{

			Hashtable CreateInterestRateFuturesMarketData_args = new Hashtable();
			CreateInterestRateFuturesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateInterestRateFuturesMarketData_args.Add("FuturesContractType", FuturesContractType);
			CreateInterestRateFuturesMarketData_args.Add("Maturities", Maturities);
			CreateInterestRateFuturesMarketData_args.Add("TradedPrices", TradedPrices);
			CreateInterestRateFuturesMarketData_args.Add("TagName", TagName);
			CreateInterestRateFuturesMarketData_args.Add("TagType", TagType);
			CreateInterestRateFuturesMarketData_args.Add("Underlying", Underlying);
			return F3Formatter.f3_style_serialization("CreateInterestRateFuturesMarketData", CreateInterestRateFuturesMarketData_args);
		}

		// <summary>
		// Create an interest rate futures position.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="ContractType">Type of futures contract.</param>
		// <param name="StartDate">Reference date for calculation of expiry.</param>
		// <param name="Maturity">Expiry of futures contract.</param>
		// <param name="NumContracts">The number of contracts.</param>
		// <param name="TradedPrice">Price at which the futures trade was done.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="PayRec">flag indicating payment or receipt of the amount proportional to (1-FloatingRate).</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateInterestRateFuturesPosition(object ProductName, object ContractType, object StartDate, object Maturity, object NumContracts, object TradedPrice, object FloatingRateIndex, object PayRec)
		{

			Hashtable CreateInterestRateFuturesPosition_args = new Hashtable();
			CreateInterestRateFuturesPosition_args.Add("ProductName", ProductName);
			CreateInterestRateFuturesPosition_args.Add("ContractType", ContractType);
			CreateInterestRateFuturesPosition_args.Add("StartDate", StartDate);
			CreateInterestRateFuturesPosition_args.Add("Maturity", Maturity);
			CreateInterestRateFuturesPosition_args.Add("NumContracts", NumContracts);
			CreateInterestRateFuturesPosition_args.Add("TradedPrice", TradedPrice);
			CreateInterestRateFuturesPosition_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateInterestRateFuturesPosition_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateInterestRateFuturesPosition", CreateInterestRateFuturesPosition_args);
		}

		// <summary>
		// Create a single currency interest rate swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure for the fixed leg.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="FixedCoupon">The fixed coupon paid on each roll of the fixed leg.</param>
		// <param name="MarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <param name="FloatingLegMarketConventions">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateInterestRateSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object FixedCoupon, object MarketConvention, object FloatingRateIndex, object Margin, object PayRec,
		object FloatingLegMarketConventions)
		{

			Hashtable CreateInterestRateSwap_args = new Hashtable();
			CreateInterestRateSwap_args.Add("ProductName", ProductName);
			CreateInterestRateSwap_args.Add("StartDate", StartDate);
			CreateInterestRateSwap_args.Add("Maturity", Maturity);
			CreateInterestRateSwap_args.Add("Notional", Notional);
			CreateInterestRateSwap_args.Add("Currency", Currency);
			CreateInterestRateSwap_args.Add("FixedCoupon", FixedCoupon);
			CreateInterestRateSwap_args.Add("MarketConvention", MarketConvention);
			CreateInterestRateSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateInterestRateSwap_args.Add("Margin", Margin);
			CreateInterestRateSwap_args.Add("PayRec", PayRec);
			CreateInterestRateSwap_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateInterestRateSwap", CreateInterestRateSwap_args);
		}

		// <summary>
		// Create a function from the weighted sum of a collection of functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="AnchorDate">Date from which to base the length calculation.</param>
		// <param name="LengthSetOfTrade">Length set of the trade.</param>
		// <param name="LengthCalculatorForTrade">Length calculator to use for the trade.</param>
		// <param name="LengthCalculatorForMarketData">Length calculator to use for the market data.</param>
		// <param name="MarketDataMaturities">Collection of market data maturities.</param>
		// <param name="MaturityWeightParamTag">Tag to use for the maturities used to determine the weights.</param>
		// <param name="Functions">Collection of one-dimensional functions.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateInterpolatedFunctionGivenLengthSet(object FunctionName, object AnchorDate, object LengthSetOfTrade, object LengthCalculatorForTrade, object LengthCalculatorForMarketData, object MarketDataMaturities, object MaturityWeightParamTag, object Functions)
		{

			Hashtable CreateInterpolatedFunctionGivenLengthSet_args = new Hashtable();
			CreateInterpolatedFunctionGivenLengthSet_args.Add("FunctionName", FunctionName);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("AnchorDate", AnchorDate);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("LengthSetOfTrade", LengthSetOfTrade);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("LengthCalculatorForTrade", LengthCalculatorForTrade);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("LengthCalculatorForMarketData", LengthCalculatorForMarketData);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("MarketDataMaturities", MarketDataMaturities);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("MaturityWeightParamTag", MaturityWeightParamTag);
			CreateInterpolatedFunctionGivenLengthSet_args.Add("Functions", Functions);
			return F3Formatter.f3_style_serialization("CreateInterpolatedFunctionGivenLengthSet", CreateInterpolatedFunctionGivenLengthSet_args);
		}

		// <summary>
		// Create a modifier which applies the inverse of the cumulative distribution functions between simulation time points of a stochastic process to the underlying state variable vector.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Simulation time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="CumulativeDistributionFunctions">Cumulative distribution functions between simulation time points of the stochastic process.</param>
		// <param name="GridPoints">Interpolation grid points.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateInterpolatedInverseCumulativeDistributionFunctionModifier(object ModifierName, object TimePoints, object ForwardFunction, object CumulativeDistributionFunctions, object GridPoints)
		{

			Hashtable CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args = new Hashtable();
			CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args.Add("ModifierName", ModifierName);
			CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args.Add("TimePoints", TimePoints);
			CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args.Add("CumulativeDistributionFunctions", CumulativeDistributionFunctions);
			CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args.Add("GridPoints", GridPoints);
			return F3Formatter.f3_style_serialization("CreateInterpolatedInverseCumulativeDistributionFunctionModifier", CreateInterpolatedInverseCumulativeDistributionFunctionModifier_args);
		}

		// <summary>
		// Form a simple rate index by interpolating over fixed length indices.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="LiborIndices">List of fixed-length LIBOR indices.</param>
		// <param name="RollWeightCalculator">Calculator for determining relative weights.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateInterpolatedLiborIndex(object IndexName, object LiborIndices, object RollWeightCalculator)
		{

			Hashtable CreateInterpolatedLiborIndex_args = new Hashtable();
			CreateInterpolatedLiborIndex_args.Add("IndexName", IndexName);
			CreateInterpolatedLiborIndex_args.Add("LiborIndices", LiborIndices);
			CreateInterpolatedLiborIndex_args.Add("RollWeightCalculator", RollWeightCalculator);
			return F3Formatter.f3_style_serialization("CreateInterpolatedLiborIndex", CreateInterpolatedLiborIndex_args);
		}

		// <summary>
		// Create a holiday convention from the intersection of others.
		// </summary>
		// <param name="HolidayConventionName">Name to use for the new holiday convention.</param>
		// <param name="FirstHolidayConventions">First set of underlying holiday conventions to use.</param>
		// <param name="SecondHolidayConventions">Second set of underlying holiday conventions to use.</param>
		// <returns>Retuns the name of the constructed object of type HolidayConvention.</returns>
		public object CreateIntersectionHolidayConvention(object HolidayConventionName, object FirstHolidayConventions, object SecondHolidayConventions)
		{

			Hashtable CreateIntersectionHolidayConvention_args = new Hashtable();
			CreateIntersectionHolidayConvention_args.Add("HolidayConventionName", HolidayConventionName);
			CreateIntersectionHolidayConvention_args.Add("FirstHolidayConventions", FirstHolidayConventions);
			CreateIntersectionHolidayConvention_args.Add("SecondHolidayConventions", SecondHolidayConventions);
			return F3Formatter.f3_style_serialization("CreateIntersectionHolidayConvention", CreateIntersectionHolidayConvention_args);
		}

		// <summary>
		// Create an inverse cumulative normal distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="MuValue">Value of mean.</param>
		// <param name="SigmaValue">Value of standard deviation.</param>
		// <param name="MuParameterTag">Tag to use for the mu value.</param>
		// <param name="SigmaParameterTag">Tag to use for the sigma value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateInverseCumulativeNormalFunction(object FunctionName, object MuValue, object SigmaValue, object MuParameterTag, object SigmaParameterTag)
		{

			Hashtable CreateInverseCumulativeNormalFunction_args = new Hashtable();
			CreateInverseCumulativeNormalFunction_args.Add("FunctionName", FunctionName);
			CreateInverseCumulativeNormalFunction_args.Add("MuValue", MuValue);
			CreateInverseCumulativeNormalFunction_args.Add("SigmaValue", SigmaValue);
			CreateInverseCumulativeNormalFunction_args.Add("MuParameterTag", MuParameterTag);
			CreateInverseCumulativeNormalFunction_args.Add("SigmaParameterTag", SigmaParameterTag);
			return F3Formatter.f3_style_serialization("CreateInverseCumulativeNormalFunction", CreateInverseCumulativeNormalFunction_args);
		}

		// <summary>
		// Create the inverse of an FX rate index.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="UnderlyingFXIndex">Underlying FX index.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateInverseFXRateIndex(object IndexName, object UnderlyingFXIndex)
		{

			Hashtable CreateInverseFXRateIndex_args = new Hashtable();
			CreateInverseFXRateIndex_args.Add("IndexName", IndexName);
			CreateInverseFXRateIndex_args.Add("UnderlyingFXIndex", UnderlyingFXIndex);
			return F3Formatter.f3_style_serialization("CreateInverseFXRateIndex", CreateInverseFXRateIndex_args);
		}

		// <summary>
		// Create an inverse of a one-dimensional function by root finding.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SourceFunction">Function to take the inverse of.</param>
		// <param name="StartingPoint">Starting point of root search. Default value: 0.0.</param>
		// <param name="LowerBound">Lower bound for root search. Default value: -1.0e8.</param>
		// <param name="UpperBound">Upper bound for root search. Default value: 1.0e8.</param>
		// <param name="MaxIters">Maximum iterations for root search. Default value: 500.</param>
		// <param name="Tolerance">Tolerance for terminating root search. Default value: 1.0e-8.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateInverseFunction(object FunctionName, object SourceFunction, object StartingPoint, object LowerBound, object UpperBound, object MaxIters, object Tolerance)
		{

			Hashtable CreateInverseFunction_args = new Hashtable();
			CreateInverseFunction_args.Add("FunctionName", FunctionName);
			CreateInverseFunction_args.Add("SourceFunction", SourceFunction);
			CreateInverseFunction_args.Add("StartingPoint", StartingPoint);
			CreateInverseFunction_args.Add("LowerBound", LowerBound);
			CreateInverseFunction_args.Add("UpperBound", UpperBound);
			CreateInverseFunction_args.Add("MaxIters", MaxIters);
			CreateInverseFunction_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreateInverseFunction", CreateInverseFunction_args);
		}

		// <summary>
		// Create an inverse function by interpolation.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SourceFunction">Function to take the inverse of.</param>
		// <param name="LowerBound">The lower bound of the function's argument.</param>
		// <param name="UpperBound">The upper bound of the function's argument.</param>
		// <param name="NumberOfPoints">The number of points at which to evaluate the function.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateInverseInterpolatedFunction(object FunctionName, object SourceFunction, object LowerBound, object UpperBound, object NumberOfPoints)
		{

			Hashtable CreateInverseInterpolatedFunction_args = new Hashtable();
			CreateInverseInterpolatedFunction_args.Add("FunctionName", FunctionName);
			CreateInverseInterpolatedFunction_args.Add("SourceFunction", SourceFunction);
			CreateInverseInterpolatedFunction_args.Add("LowerBound", LowerBound);
			CreateInverseInterpolatedFunction_args.Add("UpperBound", UpperBound);
			CreateInverseInterpolatedFunction_args.Add("NumberOfPoints", NumberOfPoints);
			return F3Formatter.f3_style_serialization("CreateInverseInterpolatedFunction", CreateInverseInterpolatedFunction_args);
		}

		// <summary>
		// Create an underlying rate function from an m-times-per-year compounded function with term structure.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTimePoint">Base time point.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="CompoundedFactors">Vector of compounded factors.</param>
		// <param name="TimeCalculator">Time calculator to use.</param>
		// <param name="CompoundedFactorsTag">Tag to use for the compounded factors.</param>
		// <param name="CompoundingPeriodsPerYear">An integer specifying the number of times       per year the rate is compounded.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateInverseOfMTimesPerYearCompoundingFunction(object FunctionName, object BaseTimePoint, object TimePoints, object CompoundedFactors, object TimeCalculator, object CompoundedFactorsTag, object CompoundingPeriodsPerYear)
		{

			Hashtable CreateInverseOfMTimesPerYearCompoundingFunction_args = new Hashtable();
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("FunctionName", FunctionName);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("BaseTimePoint", BaseTimePoint);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("TimePoints", TimePoints);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("CompoundedFactors", CompoundedFactors);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("TimeCalculator", TimeCalculator);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("CompoundedFactorsTag", CompoundedFactorsTag);
			CreateInverseOfMTimesPerYearCompoundingFunction_args.Add("CompoundingPeriodsPerYear", CompoundingPeriodsPerYear);
			return F3Formatter.f3_style_serialization("CreateInverseOfMTimesPerYearCompoundingFunction", CreateInverseOfMTimesPerYearCompoundingFunction_args);
		}

		// <summary>
		// Create a closed-form valuation specification for the LIBOR Market Model .
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="LiborRateIndices">Array of LIBOR rate indices.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateLMMClosedFormValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object LiborRateIndices)
		{

			Hashtable CreateLMMClosedFormValuationSpecification_args = new Hashtable();
			CreateLMMClosedFormValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateLMMClosedFormValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateLMMClosedFormValuationSpecification_args.Add("LiborRateIndices", LiborRateIndices);
			return F3Formatter.f3_style_serialization("CreateLMMClosedFormValuationSpecification", CreateLMMClosedFormValuationSpecification_args);
		}

		// <summary>
		// Create a closed-form valuation specification builder for the LIBOR Market Model.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="LiborRateIndices">Array of LIBOR rate indices.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateLMMClosedFormValuationSpecificationBuilder(object BuilderName, object LiborRateIndices)
		{

			Hashtable CreateLMMClosedFormValuationSpecificationBuilder_args = new Hashtable();
			CreateLMMClosedFormValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateLMMClosedFormValuationSpecificationBuilder_args.Add("LiborRateIndices", LiborRateIndices);
			return F3Formatter.f3_style_serialization("CreateLMMClosedFormValuationSpecificationBuilder", CreateLMMClosedFormValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a modifier which converts a set of underlying forward rates to discount factors at simulation time points.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="LiborTerms">Vector of LIBOR start and end times.</param>
		// <param name="LiborFixingTimes">Vector of LIBOR fixing times.</param>
		// <param name="DiscountFunction">Initial zero curve (discount factor curve) as a real function.</param>
		// <param name="ForwardMeasureIndex">Index of LIBOR end time as the forward measure index.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLMMDiscountFactorsModifier(object ModifierName, object TimePoints, object LiborTerms, object LiborFixingTimes, object DiscountFunction, object ForwardMeasureIndex)
		{

			Hashtable CreateLMMDiscountFactorsModifier_args = new Hashtable();
			CreateLMMDiscountFactorsModifier_args.Add("ModifierName", ModifierName);
			CreateLMMDiscountFactorsModifier_args.Add("TimePoints", TimePoints);
			CreateLMMDiscountFactorsModifier_args.Add("LiborTerms", LiborTerms);
			CreateLMMDiscountFactorsModifier_args.Add("LiborFixingTimes", LiborFixingTimes);
			CreateLMMDiscountFactorsModifier_args.Add("DiscountFunction", DiscountFunction);
			CreateLMMDiscountFactorsModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			return F3Formatter.f3_style_serialization("CreateLMMDiscountFactorsModifier", CreateLMMDiscountFactorsModifier_args);
		}

		// <summary>
		// Create a LIBOR Market Model drift modifier with Euler discretization.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="LiborFixingTimes">Vector of LIBOR fixing times.</param>
		// <param name="InitialLibors">Vector of initial values of LIBOR.</param>
		// <param name="InitialLiborsTag">Tag to use for initial values of LIBOR.</param>
		// <param name="LiborStartTimes">Vector of LIBOR start times and the end time of the last LIBOR.</param>
		// <param name="CovarianceMatrices">The terminal covariance matrices.</param>
		// <param name="CovarianceParameterTag">Tag to use for covariance parameters.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in LiborStartTimes.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLMMDriftWithEulerDiscretizationModifier(object ModifierName, object TimePoints, object LiborFixingTimes, object InitialLibors, object InitialLiborsTag, object LiborStartTimes, object CovarianceMatrices, object CovarianceParameterTag, object ForwardMeasureIndex)
		{

			Hashtable CreateLMMDriftWithEulerDiscretizationModifier_args = new Hashtable();
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("ModifierName", ModifierName);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("TimePoints", TimePoints);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("LiborFixingTimes", LiborFixingTimes);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("InitialLibors", InitialLibors);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("InitialLiborsTag", InitialLiborsTag);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("LiborStartTimes", LiborStartTimes);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("CovarianceMatrices", CovarianceMatrices);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("CovarianceParameterTag", CovarianceParameterTag);
			CreateLMMDriftWithEulerDiscretizationModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			return F3Formatter.f3_style_serialization("CreateLMMDriftWithEulerDiscretizationModifier", CreateLMMDriftWithEulerDiscretizationModifier_args);
		}

		// <summary>
		// Create a LIBOR Market Model drift modifier with predictor-corrector discretization scheme.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="LiborFixingTimes">Vector of LIBOR fixing times.</param>
		// <param name="InitialLibors">Vector of initial values of LIBOR.</param>
		// <param name="InitialLiborsTag">Tag to use for initial values of LIBOR.</param>
		// <param name="LiborStartTimes">Vector of LIBOR start times and the end time of the last LIBOR.</param>
		// <param name="CovarianceMatrices">The terminal covariance matrices.</param>
		// <param name="CovarianceParameterTag">Tag to use for covariance parameters.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in LiborStartTimes.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLMMDriftWithPredictorCorrectorModifier(object ModifierName, object TimePoints, object LiborFixingTimes, object InitialLibors, object InitialLiborsTag, object LiborStartTimes, object CovarianceMatrices, object CovarianceParameterTag, object ForwardMeasureIndex)
		{

			Hashtable CreateLMMDriftWithPredictorCorrectorModifier_args = new Hashtable();
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("ModifierName", ModifierName);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("TimePoints", TimePoints);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("LiborFixingTimes", LiborFixingTimes);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("InitialLibors", InitialLibors);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("InitialLiborsTag", InitialLiborsTag);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("LiborStartTimes", LiborStartTimes);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("CovarianceMatrices", CovarianceMatrices);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("CovarianceParameterTag", CovarianceParameterTag);
			CreateLMMDriftWithPredictorCorrectorModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			return F3Formatter.f3_style_serialization("CreateLMMDriftWithPredictorCorrectorModifier", CreateLMMDriftWithPredictorCorrectorModifier_args);
		}

		// <summary>
		// Create a modifier which generates the stochastic factors   in the LIBOR Market Model using a principal components construction.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of simulation time points.</param>
		// <param name="LiborFixingTimes">Vector of LIBOR fixing times.</param>
		// <param name="CovarianceMatrices">Vector of terminal covariance matrices of Libors between simulation time points.</param>
		// <param name="CovarianceParameterTag">Tag to use for covariance parameters.</param>
		// <param name="CovarianceDecompositionMethod">The method for covariance decomposition.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLMMPrincipalComponentsModifier(object ModifierName, object TimePoints, object LiborFixingTimes, object CovarianceMatrices, object CovarianceParameterTag, object CovarianceDecompositionMethod)
		{

			Hashtable CreateLMMPrincipalComponentsModifier_args = new Hashtable();
			CreateLMMPrincipalComponentsModifier_args.Add("ModifierName", ModifierName);
			CreateLMMPrincipalComponentsModifier_args.Add("TimePoints", TimePoints);
			CreateLMMPrincipalComponentsModifier_args.Add("LiborFixingTimes", LiborFixingTimes);
			CreateLMMPrincipalComponentsModifier_args.Add("CovarianceMatrices", CovarianceMatrices);
			CreateLMMPrincipalComponentsModifier_args.Add("CovarianceParameterTag", CovarianceParameterTag);
			CreateLMMPrincipalComponentsModifier_args.Add("CovarianceDecompositionMethod", CovarianceDecompositionMethod);
			return F3Formatter.f3_style_serialization("CreateLMMPrincipalComponentsModifier", CreateLMMPrincipalComponentsModifier_args);
		}

		// <summary>
		// Create a state variable template that models LIBOR rates                          according to the LIBOR Market Model.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="LiborIndex">LIBOR index to simulate.</param>
		// <param name="CovarianceDecompositionMethod">The method for covariance decomposition. Default value: Cholesky.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateLMMStateVariableTemplate(object StateVariableTemplateName, object LiborIndex, object CovarianceDecompositionMethod)
		{

			Hashtable CreateLMMStateVariableTemplate_args = new Hashtable();
			CreateLMMStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateLMMStateVariableTemplate_args.Add("LiborIndex", LiborIndex);
			CreateLMMStateVariableTemplate_args.Add("CovarianceDecompositionMethod", CovarianceDecompositionMethod);
			return F3Formatter.f3_style_serialization("CreateLMMStateVariableTemplate", CreateLMMStateVariableTemplate_args);
		}

		// <summary>
		// Create a modifier which returns the stochastic factors in the LIBOR Market Model.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="LiborFixingTimes">Vector of LIBOR fixing times.</param>
		// <param name="CovarianceMatrices">Vector of terminal covariance matrices of LIBORs between simulation time points.</param>
		// <param name="CovarianceParameterTag">Tag to use for covariance parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLMMStochasticFactorsModifier(object ModifierName, object TimePoints, object LiborFixingTimes, object CovarianceMatrices, object CovarianceParameterTag)
		{

			Hashtable CreateLMMStochasticFactorsModifier_args = new Hashtable();
			CreateLMMStochasticFactorsModifier_args.Add("ModifierName", ModifierName);
			CreateLMMStochasticFactorsModifier_args.Add("TimePoints", TimePoints);
			CreateLMMStochasticFactorsModifier_args.Add("LiborFixingTimes", LiborFixingTimes);
			CreateLMMStochasticFactorsModifier_args.Add("CovarianceMatrices", CovarianceMatrices);
			CreateLMMStochasticFactorsModifier_args.Add("CovarianceParameterTag", CovarianceParameterTag);
			return F3Formatter.f3_style_serialization("CreateLMMStochasticFactorsModifier", CreateLMMStochasticFactorsModifier_args);
		}

		// <summary>
		// Create a Laguerre polynomial of order n.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Order">Order n.</param>
		// <param name="OrderParameterTag">Tag to use for the order value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateLaguerrePolynomial(object FunctionName, object Order, object OrderParameterTag)
		{

			Hashtable CreateLaguerrePolynomial_args = new Hashtable();
			CreateLaguerrePolynomial_args.Add("FunctionName", FunctionName);
			CreateLaguerrePolynomial_args.Add("Order", Order);
			CreateLaguerrePolynomial_args.Add("OrderParameterTag", OrderParameterTag);
			return F3Formatter.f3_style_serialization("CreateLaguerrePolynomial", CreateLaguerrePolynomial_args);
		}

		// <summary>
		// Create a date modifier that finds the latest of two underlying modified dates, and then applies a third modifier to it.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="FirstDateModifier">First alternative date modifier.</param>
		// <param name="SecondDateModifier">Second alternative date modifier.</param>
		// <param name="FinalDateModifier">Overall date modifier.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateLatestDateModifier(object DateModifierName, object FirstDateModifier, object SecondDateModifier, object FinalDateModifier)
		{

			Hashtable CreateLatestDateModifier_args = new Hashtable();
			CreateLatestDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateLatestDateModifier_args.Add("FirstDateModifier", FirstDateModifier);
			CreateLatestDateModifier_args.Add("SecondDateModifier", SecondDateModifier);
			CreateLatestDateModifier_args.Add("FinalDateModifier", FinalDateModifier);
			return F3Formatter.f3_style_serialization("CreateLatestDateModifier", CreateLatestDateModifier_args);
		}

		// <summary>
		// Create a maturity calculator that uses the latest of two underlying maturity calculators.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for maturity calculator.</param>
		// <param name="FirstUnderlyingCalculator">First underlying maturity calculator.</param>
		// <param name="SecondUnderlyingCalculator">Second underlying maturity calculator.</param>
		// <param name="DateModifier">Date modifier. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateLatestMaturityCalculator(object MaturityCalculatorName, object FirstUnderlyingCalculator, object SecondUnderlyingCalculator, object DateModifier)
		{

			Hashtable CreateLatestMaturityCalculator_args = new Hashtable();
			CreateLatestMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateLatestMaturityCalculator_args.Add("FirstUnderlyingCalculator", FirstUnderlyingCalculator);
			CreateLatestMaturityCalculator_args.Add("SecondUnderlyingCalculator", SecondUnderlyingCalculator);
			CreateLatestMaturityCalculator_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("CreateLatestMaturityCalculator", CreateLatestMaturityCalculator_args);
		}

		// <summary>
		// Create a date modifier that finds the latest trade date for a start date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="MarketConventions">Market conventions for trade-start date relationship.</param>
		// <param name="AllowInvalidTradeDate">Allow an invalid trade date to be returned. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateLatestTradeDateModifier(object DateModifierName, object MarketConventions, object AllowInvalidTradeDate)
		{

			Hashtable CreateLatestTradeDateModifier_args = new Hashtable();
			CreateLatestTradeDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateLatestTradeDateModifier_args.Add("MarketConventions", MarketConventions);
			CreateLatestTradeDateModifier_args.Add("AllowInvalidTradeDate", AllowInvalidTradeDate);
			return F3Formatter.f3_style_serialization("CreateLatestTradeDateModifier", CreateLatestTradeDateModifier_args);
		}

		// <summary>
		// Create a product by extracting one leg from a swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Swap">The swap product from which the leg product will be extracted.</param>
		// <param name="ExtractCouponBearingLeg">Flag indicating which leg to extract.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateLegProductFromSwap(object ProductName, object Swap, object ExtractCouponBearingLeg)
		{

			Hashtable CreateLegProductFromSwap_args = new Hashtable();
			CreateLegProductFromSwap_args.Add("ProductName", ProductName);
			CreateLegProductFromSwap_args.Add("Swap", Swap);
			CreateLegProductFromSwap_args.Add("ExtractCouponBearingLeg", ExtractCouponBearingLeg);
			return F3Formatter.f3_style_serialization("CreateLegProductFromSwap", CreateLegProductFromSwap_args);
		}

		// <summary>
		// Create an index whose value is true if the first input is less than the second.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="FirstIndex">First index in comparison.</param>
		// <param name="SecondIndex">Second index in comparison.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateLessThanIndex(object IndexName, object FirstIndex, object SecondIndex)
		{

			Hashtable CreateLessThanIndex_args = new Hashtable();
			CreateLessThanIndex_args.Add("IndexName", IndexName);
			CreateLessThanIndex_args.Add("FirstIndex", FirstIndex);
			CreateLessThanIndex_args.Add("SecondIndex", SecondIndex);
			return F3Formatter.f3_style_serialization("CreateLessThanIndex", CreateLessThanIndex_args);
		}

		// <summary>
		// Create a least-squares optimizer with the Levenberg-Marquardt algorithm.
		// </summary>
		// <param name="OptimizerName">Name to use for optimizer.</param>
		// <param name="Tolerance">Tolerance for convergence. Default value: 0.0001.</param>
		// <param name="MaxIterations">Maximum number of iterations. Default value: 50.</param>
		// <param name="LikelihoodRiskBump">Amount by which to bump the exposure of the Likelihood. Default value: 1.0e-9.</param>
		// <param name="CollectDiagnostics">Flag indicating whether or not to collect diagnostic information on each iteration. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationOptimizer.</returns>
		public object CreateLevenbergMarquardtLeastSquaresOptimizer(object OptimizerName, object Tolerance, object MaxIterations, object LikelihoodRiskBump, object CollectDiagnostics)
		{

			Hashtable CreateLevenbergMarquardtLeastSquaresOptimizer_args = new Hashtable();
			CreateLevenbergMarquardtLeastSquaresOptimizer_args.Add("OptimizerName", OptimizerName);
			CreateLevenbergMarquardtLeastSquaresOptimizer_args.Add("Tolerance", Tolerance);
			CreateLevenbergMarquardtLeastSquaresOptimizer_args.Add("MaxIterations", MaxIterations);
			CreateLevenbergMarquardtLeastSquaresOptimizer_args.Add("LikelihoodRiskBump", LikelihoodRiskBump);
			CreateLevenbergMarquardtLeastSquaresOptimizer_args.Add("CollectDiagnostics", CollectDiagnostics);
			return F3Formatter.f3_style_serialization("CreateLevenbergMarquardtLeastSquaresOptimizer", CreateLevenbergMarquardtLeastSquaresOptimizer_args);
		}

		// <summary>
		// Create a simple single period interest rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Currency">Currency underlying rate.</param>
		// <param name="MarketConventions">Market conventions for the rate.</param>
		// <param name="FixingReferencer">Index referencer. Default value: default-constructed instance of type referencer.</param>
		// <param name="OptionalFixingTableName">Optional name for the fixings table associated with the index. Default value: default-constructed instance of type fixings_name.</param>
		// <param name="OptionalCurveReferenceName">Optional name for the curve associated with the index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateLiborIndex(object IndexName, object Currency, object MarketConventions, object FixingReferencer, object OptionalFixingTableName, object OptionalCurveReferenceName)
		{

			Hashtable CreateLiborIndex_args = new Hashtable();
			CreateLiborIndex_args.Add("IndexName", IndexName);
			CreateLiborIndex_args.Add("Currency", Currency);
			CreateLiborIndex_args.Add("MarketConventions", MarketConventions);
			CreateLiborIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateLiborIndex_args.Add("OptionalFixingTableName", OptionalFixingTableName);
			CreateLiborIndex_args.Add("OptionalCurveReferenceName", OptionalCurveReferenceName);
			return F3Formatter.f3_style_serialization("CreateLiborIndex", CreateLiborIndex_args);
		}

		// <summary>
		// Create a simulation function template for the simulaton of a range accrual using linear interpolation.
		// </summary>
		// <param name="SimulationFunctionTemplate">Name to use for the simulation function template.</param>
		// <param name="MarketConvention">Market convention used in the simulation of a derived index.</param>
		// <returns>Retuns the name of the constructed object of type SimulationFunctions.</returns>
		public object CreateLinearRangeAccrualSimulationFunctionTemplate(object SimulationFunctionTemplate, object MarketConvention)
		{

			Hashtable CreateLinearRangeAccrualSimulationFunctionTemplate_args = new Hashtable();
			CreateLinearRangeAccrualSimulationFunctionTemplate_args.Add("SimulationFunctionTemplate", SimulationFunctionTemplate);
			CreateLinearRangeAccrualSimulationFunctionTemplate_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("CreateLinearRangeAccrualSimulationFunctionTemplate", CreateLinearRangeAccrualSimulationFunctionTemplate_args);
		}

		// <summary>
		// Create a modifier whose outputs are a set of summed underlying values.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Coefficients">Matrix of coefficients, one row per ouput.</param>
		// <param name="CoefficientsParameterTag">Tag to use for coefficient parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLinearSumModifier(object ModifierName, object Coefficients, object CoefficientsParameterTag)
		{

			Hashtable CreateLinearSumModifier_args = new Hashtable();
			CreateLinearSumModifier_args.Add("ModifierName", ModifierName);
			CreateLinearSumModifier_args.Add("Coefficients", Coefficients);
			CreateLinearSumModifier_args.Add("CoefficientsParameterTag", CoefficientsParameterTag);
			return F3Formatter.f3_style_serialization("CreateLinearSumModifier", CreateLinearSumModifier_args);
		}

		// <summary>
		// Create an index that linearly interpolates the inflation that is observed on a monthly basis.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="UnderlyingInflationIndex">The underlying inflation index to interpolate.</param>
		// <param name="Referencer">Index referencer. Default value: UnmodifiedPaymentDate.</param>
		// <param name="DayCountConvention">Day count convention for calculation of accrual factors. Default value: NumberOfDays.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateLinearlyDateInterpolatedMonthlyInflationIndex(object IndexName, object UnderlyingInflationIndex, object Referencer, object DayCountConvention)
		{

			Hashtable CreateLinearlyDateInterpolatedMonthlyInflationIndex_args = new Hashtable();
			CreateLinearlyDateInterpolatedMonthlyInflationIndex_args.Add("IndexName", IndexName);
			CreateLinearlyDateInterpolatedMonthlyInflationIndex_args.Add("UnderlyingInflationIndex", UnderlyingInflationIndex);
			CreateLinearlyDateInterpolatedMonthlyInflationIndex_args.Add("Referencer", Referencer);
			CreateLinearlyDateInterpolatedMonthlyInflationIndex_args.Add("DayCountConvention", DayCountConvention);
			return F3Formatter.f3_style_serialization("CreateLinearlyDateInterpolatedMonthlyInflationIndex", CreateLinearlyDateInterpolatedMonthlyInflationIndex_args);
		}

		// <summary>
		// Create an instrument strategy from an instrument list.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateListInstrumentStrategy(object StrategyName, object InstrumentList)
		{

			Hashtable CreateListInstrumentStrategy_args = new Hashtable();
			CreateListInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateListInstrumentStrategy_args.Add("InstrumentList", InstrumentList);
			return F3Formatter.f3_style_serialization("CreateListInstrumentStrategy", CreateListInstrumentStrategy_args);
		}

		// <summary>
		// Create a loan-only credit default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <param name="Premium">The premium paid on each roll of the premium leg.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="PayAccruedInterestUponDefault">Pay accrued interest upon default.</param>
		// <param name="MarketConvention">market conventions.</param>
		// <param name="WeightDefaultUnit">The weight of the default unit index. Default value: 1.0.</param>
		// <param name="WeightDefaultRecovery">The weight of the default recovery index. Default value: -1.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateLoanOnlyCreditDefaultSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object CreditContract, object Premium, object UpfrontFee, object PayAccruedInterestUponDefault, object MarketConvention,
		object WeightDefaultUnit, object WeightDefaultRecovery, object PayRec)
		{

			Hashtable CreateLoanOnlyCreditDefaultSwap_args = new Hashtable();
			CreateLoanOnlyCreditDefaultSwap_args.Add("ProductName", ProductName);
			CreateLoanOnlyCreditDefaultSwap_args.Add("StartDate", StartDate);
			CreateLoanOnlyCreditDefaultSwap_args.Add("Maturity", Maturity);
			CreateLoanOnlyCreditDefaultSwap_args.Add("Notional", Notional);
			CreateLoanOnlyCreditDefaultSwap_args.Add("Currency", Currency);
			CreateLoanOnlyCreditDefaultSwap_args.Add("CreditContract", CreditContract);
			CreateLoanOnlyCreditDefaultSwap_args.Add("Premium", Premium);
			CreateLoanOnlyCreditDefaultSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateLoanOnlyCreditDefaultSwap_args.Add("PayAccruedInterestUponDefault", PayAccruedInterestUponDefault);
			CreateLoanOnlyCreditDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateLoanOnlyCreditDefaultSwap_args.Add("WeightDefaultUnit", WeightDefaultUnit);
			CreateLoanOnlyCreditDefaultSwap_args.Add("WeightDefaultRecovery", WeightDefaultRecovery);
			CreateLoanOnlyCreditDefaultSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateLoanOnlyCreditDefaultSwap", CreateLoanOnlyCreditDefaultSwap_args);
		}

		// <summary>
		// Create a connection that causes all tasks to be executed locally.
		// </summary>
		// <param name="ConnectionName">Name to use for connection.</param>
		// <returns>Retuns the name of the constructed object of type RemoteExecutorSource.</returns>
		public object CreateLocalGridConnection(object ConnectionName)
		{

			Hashtable CreateLocalGridConnection_args = new Hashtable();
			CreateLocalGridConnection_args.Add("ConnectionName", ConnectionName);
			return F3Formatter.f3_style_serialization("CreateLocalGridConnection", CreateLocalGridConnection_args);
		}

		// <summary>
		// Create a local stochastic volatility modifier that uses quadratic exponential discretization.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of fixing time points.</param>
		// <param name="NumSimPoints">Number of time points, in addition to the number of fixing time points, to use in the discretization.</param>
		// <param name="Forward">Forward price function.</param>
		// <param name="LocalVol">Incremental local volatility function.</param>
		// <param name="LocalVolQuantStrat">Local volatility quantization strategy builder. Default value: <s>LognormalStdDev</s><s>1000</s><s>3</s><s>true</s>.</param>
		// <param name="InitialVar">Initial variance.</param>
		// <param name="InitialVarTag">Tag to use for the initial variance.</param>
		// <param name="LongTermVar">Long term variance function.</param>
		// <param name="SpeedOfMeanRev">Speed of mean reversion function.</param>
		// <param name="VolOfVar">Volatility of variance function.</param>
		// <param name="Correlation">Correlation function.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization(object ModifierName, object TimePoints, object NumSimPoints, object Forward, object LocalVol, object LocalVolQuantStrat, object InitialVar, object InitialVarTag, object LongTermVar, object SpeedOfMeanRev,
		object VolOfVar, object Correlation, object UseBrownianBridge)
		{

			Hashtable CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args = new Hashtable();
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("ModifierName", ModifierName);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("TimePoints", TimePoints);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("NumSimPoints", NumSimPoints);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("Forward", Forward);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("LocalVol", LocalVol);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("LocalVolQuantStrat", LocalVolQuantStrat);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("InitialVar", InitialVar);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("InitialVarTag", InitialVarTag);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("LongTermVar", LongTermVar);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("SpeedOfMeanRev", SpeedOfMeanRev);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("VolOfVar", VolOfVar);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("Correlation", Correlation);
			CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization", CreateLocalStochasticVolatilityModifierWithQuadraticExponentialDiscretization_args);
		}

		// <summary>
		// Create a state variable template that models a stochastic process according to a local stochastic volatility model.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="VolatilityQuantizationStrategy">Volatility quantization strategy builder. Default value: <s>LognormalStdDev</s><s>1000</s><s>3</s><s>true</s>.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateLocalStochasticVolatilityStateVariableTemplate(object StateVariableTemplateName, object VolatilityQuantizationStrategy, object UseBrownianBridge)
		{

			Hashtable CreateLocalStochasticVolatilityStateVariableTemplate_args = new Hashtable();
			CreateLocalStochasticVolatilityStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateLocalStochasticVolatilityStateVariableTemplate_args.Add("VolatilityQuantizationStrategy", VolatilityQuantizationStrategy);
			CreateLocalStochasticVolatilityStateVariableTemplate_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateLocalStochasticVolatilityStateVariableTemplate", CreateLocalStochasticVolatilityStateVariableTemplate_args);
		}

		// <summary>
		// Create a local volatility model modifier that uses Euler discretization.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of fixing time points.</param>
		// <param name="NumberOfSimulationPoints">Number of time points, in addition to the number of fixing time points, to use in the discretization.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Incremental local volatility function.</param>
		// <param name="VolatilityQuantizationStrategy">Volatility quantization strategy builder. Default value: <s>LognormalStdDev</s><s>1000</s><s>3</s><s>true</s>.</param>
		// <param name="UseLogCoordinate">Whether or not to use the logarithm of the forward price in the simulation. Default value: true.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLocalVolatilityModifierWithEulerDiscretization(object ModifierName, object TimePoints, object NumberOfSimulationPoints, object ForwardFunction, object VolatilityFunction, object VolatilityQuantizationStrategy, object UseLogCoordinate, object UseBrownianBridge)
		{

			Hashtable CreateLocalVolatilityModifierWithEulerDiscretization_args = new Hashtable();
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("ModifierName", ModifierName);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("TimePoints", TimePoints);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("NumberOfSimulationPoints", NumberOfSimulationPoints);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("ForwardFunction", ForwardFunction);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("VolatilityFunction", VolatilityFunction);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("VolatilityQuantizationStrategy", VolatilityQuantizationStrategy);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("UseLogCoordinate", UseLogCoordinate);
			CreateLocalVolatilityModifierWithEulerDiscretization_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateLocalVolatilityModifierWithEulerDiscretization", CreateLocalVolatilityModifierWithEulerDiscretization_args);
		}

		// <summary>
		// Create a state variable template that models a stochastic process according to a local volatility model.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="VolatilityQuantizationStrategy">Volatility quantization strategy builder. Default value: <s>LognormalStdDev</s><s>1000</s><s>3</s><s>true</s>.</param>
		// <param name="UseLogCoordinate">Whether or not to use the logarithm of the forward price in the simulation. Default value: true.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateLocalVolatilityStateVariableTemplate(object StateVariableTemplateName, object VolatilityQuantizationStrategy, object UseLogCoordinate, object UseBrownianBridge)
		{

			Hashtable CreateLocalVolatilityStateVariableTemplate_args = new Hashtable();
			CreateLocalVolatilityStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateLocalVolatilityStateVariableTemplate_args.Add("VolatilityQuantizationStrategy", VolatilityQuantizationStrategy);
			CreateLocalVolatilityStateVariableTemplate_args.Add("UseLogCoordinate", UseLogCoordinate);
			CreateLocalVolatilityStateVariableTemplate_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateLocalVolatilityStateVariableTemplate", CreateLocalVolatilityStateVariableTemplate_args);
		}

		// <summary>
		// Create a backward evolution operator for calculating the logarithm of a forward price relative to a strike.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="Strike">Strike price.</param>
		// <param name="StrikeParameterTag">Tag to use for the strike price.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateLogRelativePriceOperator(object OperatorName, object Strike, object StrikeParameterTag)
		{

			Hashtable CreateLogRelativePriceOperator_args = new Hashtable();
			CreateLogRelativePriceOperator_args.Add("OperatorName", OperatorName);
			CreateLogRelativePriceOperator_args.Add("Strike", Strike);
			CreateLogRelativePriceOperator_args.Add("StrikeParameterTag", StrikeParameterTag);
			return F3Formatter.f3_style_serialization("CreateLogRelativePriceOperator", CreateLogRelativePriceOperator_args);
		}

		// <summary>
		// Create a lognormal modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Black volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLognormalModifier(object ModifierName, object TimePoints, object ForwardFunction, object VolatilityFunction)
		{

			Hashtable CreateLognormalModifier_args = new Hashtable();
			CreateLognormalModifier_args.Add("ModifierName", ModifierName);
			CreateLognormalModifier_args.Add("TimePoints", TimePoints);
			CreateLognormalModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateLognormalModifier_args.Add("VolatilityFunction", VolatilityFunction);
			return F3Formatter.f3_style_serialization("CreateLognormalModifier", CreateLognormalModifier_args);
		}

		// <summary>
		// Create a lognormal model modifier which uses Euler discretization.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of fixing time points.</param>
		// <param name="NumberOfSimulationPoints">Number of time points, in addition to the number of fixing time points, to use in the discretization.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Incremental local volatility function.</param>
		// <param name="UseLogCoordinate">Whether or not to use the logarithm of the forward price in the simulation. Default value: true.</param>
		// <param name="UseBrownianBridge">Whether or not to use a Brownian bridge construction in the simulation. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateLognormalModifierWithEulerDiscretization(object ModifierName, object TimePoints, object NumberOfSimulationPoints, object ForwardFunction, object VolatilityFunction, object UseLogCoordinate, object UseBrownianBridge)
		{

			Hashtable CreateLognormalModifierWithEulerDiscretization_args = new Hashtable();
			CreateLognormalModifierWithEulerDiscretization_args.Add("ModifierName", ModifierName);
			CreateLognormalModifierWithEulerDiscretization_args.Add("TimePoints", TimePoints);
			CreateLognormalModifierWithEulerDiscretization_args.Add("NumberOfSimulationPoints", NumberOfSimulationPoints);
			CreateLognormalModifierWithEulerDiscretization_args.Add("ForwardFunction", ForwardFunction);
			CreateLognormalModifierWithEulerDiscretization_args.Add("VolatilityFunction", VolatilityFunction);
			CreateLognormalModifierWithEulerDiscretization_args.Add("UseLogCoordinate", UseLogCoordinate);
			CreateLognormalModifierWithEulerDiscretization_args.Add("UseBrownianBridge", UseBrownianBridge);
			return F3Formatter.f3_style_serialization("CreateLognormalModifierWithEulerDiscretization", CreateLognormalModifierWithEulerDiscretization_args);
		}

		// <summary>
		// Create a valuation specification for the construction of a loss distribution for multiple-event credit.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Spacing">Time intervals in years at which the discrete loss amounts of the underlying notional pool will be calculated.</param>
		// <param name="LossQuantization">Size of discrete loss amounts of the underlying notional pool.</param>
		// <param name="TimeHorizon">Final time point at which to compute the loss distrution.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateLossCalibrationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Spacing, object LossQuantization, object TimeHorizon)
		{

			Hashtable CreateLossCalibrationValuationSpecification_args = new Hashtable();
			CreateLossCalibrationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateLossCalibrationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateLossCalibrationValuationSpecification_args.Add("Spacing", Spacing);
			CreateLossCalibrationValuationSpecification_args.Add("LossQuantization", LossQuantization);
			CreateLossCalibrationValuationSpecification_args.Add("TimeHorizon", TimeHorizon);
			return F3Formatter.f3_style_serialization("CreateLossCalibrationValuationSpecification", CreateLossCalibrationValuationSpecification_args);
		}

		// <summary>
		// Create an index representing the value of loss given default..
		// </summary>
		// <param name="IndexName">Name to use for created index.</param>
		// <param name="Contract">Definition of credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateLossGivenDefaultIndex(object IndexName, object Contract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateLossGivenDefaultIndex_args = new Hashtable();
			CreateLossGivenDefaultIndex_args.Add("IndexName", IndexName);
			CreateLossGivenDefaultIndex_args.Add("Contract", Contract);
			CreateLossGivenDefaultIndex_args.Add("Currency", Currency);
			CreateLossGivenDefaultIndex_args.Add("MarketConventions", MarketConventions);
			CreateLossGivenDefaultIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateLossGivenDefaultIndex", CreateLossGivenDefaultIndex_args);
		}

		// <summary>
		// Create a lower bound constraint to use in calibration.
		// </summary>
		// <param name="ConstraintName">Name to use for constraint.</param>
		// <param name="LowerBound">Lower bound value.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationBoundConstraint.</returns>
		public object CreateLowerBoundCalibrationConstraint(object ConstraintName, object LowerBound)
		{

			Hashtable CreateLowerBoundCalibrationConstraint_args = new Hashtable();
			CreateLowerBoundCalibrationConstraint_args.Add("ConstraintName", ConstraintName);
			CreateLowerBoundCalibrationConstraint_args.Add("LowerBound", LowerBound);
			return F3Formatter.f3_style_serialization("CreateLowerBoundCalibrationConstraint", CreateLowerBoundCalibrationConstraint_args);
		}

		// <summary>
		// Create an m-times-per-year compounded function from a rate with term structure.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="BaseTimePoint">Base time point.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="Rates">Vector of rates.</param>
		// <param name="TimeCalculator">Time calculator to use.</param>
		// <param name="RatesTag">Tag to use for the rates.</param>
		// <param name="CompoundingPeriodsPerYear">An integer specifying the number of times       per year the rate is compounded.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateMTimesPerYearCompoundingFunction(object FunctionName, object BaseTimePoint, object TimePoints, object Rates, object TimeCalculator, object RatesTag, object CompoundingPeriodsPerYear)
		{

			Hashtable CreateMTimesPerYearCompoundingFunction_args = new Hashtable();
			CreateMTimesPerYearCompoundingFunction_args.Add("FunctionName", FunctionName);
			CreateMTimesPerYearCompoundingFunction_args.Add("BaseTimePoint", BaseTimePoint);
			CreateMTimesPerYearCompoundingFunction_args.Add("TimePoints", TimePoints);
			CreateMTimesPerYearCompoundingFunction_args.Add("Rates", Rates);
			CreateMTimesPerYearCompoundingFunction_args.Add("TimeCalculator", TimeCalculator);
			CreateMTimesPerYearCompoundingFunction_args.Add("RatesTag", RatesTag);
			CreateMTimesPerYearCompoundingFunction_args.Add("CompoundingPeriodsPerYear", CompoundingPeriodsPerYear);
			return F3Formatter.f3_style_serialization("CreateMTimesPerYearCompoundingFunction", CreateMTimesPerYearCompoundingFunction_args);
		}

		// <summary>
		// Create a collateral agreement that takes into account a margin period.
		// </summary>
		// <param name="ObjectName">Name to use for the constructed object.</param>
		// <param name="MarginPeriod">Length of the margin period.</param>
		// <param name="HolidayConvention">Holiday convention for the margin period.</param>
		// <param name="UnderlyingAgreement">Underlying collateral agreement.</param>
		// <param name="FixingsName">Optional ID to use for identifying associated fixings. Default value: UnspecifiedCollateralAgreementFixingsName.</param>
		// <returns>Retuns the name of the constructed object of type CollateralAgreement.</returns>
		public object CreateMarginPeriodOfRiskCollateralAgreement(object ObjectName, object MarginPeriod, object HolidayConvention, object UnderlyingAgreement, object FixingsName)
		{

			Hashtable CreateMarginPeriodOfRiskCollateralAgreement_args = new Hashtable();
			CreateMarginPeriodOfRiskCollateralAgreement_args.Add("ObjectName", ObjectName);
			CreateMarginPeriodOfRiskCollateralAgreement_args.Add("MarginPeriod", MarginPeriod);
			CreateMarginPeriodOfRiskCollateralAgreement_args.Add("HolidayConvention", HolidayConvention);
			CreateMarginPeriodOfRiskCollateralAgreement_args.Add("UnderlyingAgreement", UnderlyingAgreement);
			CreateMarginPeriodOfRiskCollateralAgreement_args.Add("FixingsName", FixingsName);
			return F3Formatter.f3_style_serialization("CreateMarginPeriodOfRiskCollateralAgreement", CreateMarginPeriodOfRiskCollateralAgreement_args);
		}

		// <summary>
		// Create a market convention object from any input that explicitly or implicitly defines one.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="MarketConvention">Some input that contains market conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateMarketConvention(object MarketConventionName, object MarketConvention)
		{

			Hashtable CreateMarketConvention_args = new Hashtable();
			CreateMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateMarketConvention_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("CreateMarketConvention", CreateMarketConvention_args);
		}

		// <summary>
		// Create sampling strategy from market conventions.
		// </summary>
		// <param name="SamplingStrategyName">Name to use for sampling strategy.</param>
		// <param name="MarketConventions">Market conventions for sampling.</param>
		// <returns>Retuns the name of the constructed object of type SamplingStrategy.</returns>
		public object CreateMarketConventionSamplingStrategy(object SamplingStrategyName, object MarketConventions)
		{

			Hashtable CreateMarketConventionSamplingStrategy_args = new Hashtable();
			CreateMarketConventionSamplingStrategy_args.Add("SamplingStrategyName", SamplingStrategyName);
			CreateMarketConventionSamplingStrategy_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateMarketConventionSamplingStrategy", CreateMarketConventionSamplingStrategy_args);
		}

		// <summary>
		// Create a market data set from a list of instrument types and quote information.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MarketDataName">Name of market data element.</param>
		// <param name="MarketDataType">Type of market data element.</param>
		// <param name="InstrumentTypeList">Vector of market data instrument types.</param>
		// <param name="QuoteSpecifications">Vector of quote specifications, one per instrument.</param>
		// <param name="Quotes">Vector of quotes, one per instrument.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateMarketDataElement(object MarketDataSetName, object MarketDataName, object MarketDataType, object InstrumentTypeList, object QuoteSpecifications, object Quotes)
		{

			Hashtable CreateMarketDataElement_args = new Hashtable();
			CreateMarketDataElement_args.Add("MarketDataSetName", MarketDataSetName);
			CreateMarketDataElement_args.Add("MarketDataName", MarketDataName);
			CreateMarketDataElement_args.Add("MarketDataType", MarketDataType);
			CreateMarketDataElement_args.Add("InstrumentTypeList", InstrumentTypeList);
			CreateMarketDataElement_args.Add("QuoteSpecifications", QuoteSpecifications);
			CreateMarketDataElement_args.Add("Quotes", Quotes);
			return F3Formatter.f3_style_serialization("CreateMarketDataElement", CreateMarketDataElement_args);
		}

		// <summary>
		// Create a market data set from a list of instrument types and quote information.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MarketDataName">Name of market data element.</param>
		// <param name="MarketDataType">Type of market data element.</param>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateMarketDataElementFromInstruments(object MarketDataSetName, object MarketDataName, object MarketDataType, object InstrumentList)
		{

			Hashtable CreateMarketDataElementFromInstruments_args = new Hashtable();
			CreateMarketDataElementFromInstruments_args.Add("MarketDataSetName", MarketDataSetName);
			CreateMarketDataElementFromInstruments_args.Add("MarketDataName", MarketDataName);
			CreateMarketDataElementFromInstruments_args.Add("MarketDataType", MarketDataType);
			CreateMarketDataElementFromInstruments_args.Add("InstrumentList", InstrumentList);
			return F3Formatter.f3_style_serialization("CreateMarketDataElementFromInstruments", CreateMarketDataElementFromInstruments_args);
		}

		// <summary>
		// Create a profit-and-loss operation based on the market data in a model corresponding to a collection of market data tags.
		// </summary>
		// <param name="OperationName">Name to use for the created profit-and-loss operation.</param>
		// <param name="MarketDataTags">Tags identifying the market data to change.</param>
		// <returns>Retuns the name of the constructed object of type ProfitLossOperation.</returns>
		public object CreateMarketDataSetOperation(object OperationName, object MarketDataTags)
		{

			Hashtable CreateMarketDataSetOperation_args = new Hashtable();
			CreateMarketDataSetOperation_args.Add("OperationName", OperationName);
			CreateMarketDataSetOperation_args.Add("MarketDataTags", MarketDataTags);
			return F3Formatter.f3_style_serialization("CreateMarketDataSetOperation", CreateMarketDataSetOperation_args);
		}

		// <summary>
		// Create a maximum size multiple modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Modifiers">List of modifiers to use to form the multiple modifier.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateMaximalMultipleModifier(object ModifierName, object Modifiers)
		{

			Hashtable CreateMaximalMultipleModifier_args = new Hashtable();
			CreateMaximalMultipleModifier_args.Add("ModifierName", ModifierName);
			CreateMaximalMultipleModifier_args.Add("Modifiers", Modifiers);
			return F3Formatter.f3_style_serialization("CreateMaximalMultipleModifier", CreateMaximalMultipleModifier_args);
		}

		// <summary>
		// Create a cache processor that uses an external memcached process as the actual cache.
		// </summary>
		// <param name="CacheProcessorName">Name to use for cache processor.</param>
		// <param name="UnderlyingProcessor">Underlying cache processor.</param>
		// <param name="ServerSettings">Server settings for cache process access.</param>
		// <returns>Retuns the name of the constructed object of type CacheProcessor.</returns>
		public object CreateMemcachedExternalCache(object CacheProcessorName, object UnderlyingProcessor, object ServerSettings)
		{

			Hashtable CreateMemcachedExternalCache_args = new Hashtable();
			CreateMemcachedExternalCache_args.Add("CacheProcessorName", CacheProcessorName);
			CreateMemcachedExternalCache_args.Add("UnderlyingProcessor", UnderlyingProcessor);
			CreateMemcachedExternalCache_args.Add("ServerSettings", ServerSettings);
			return F3Formatter.f3_style_serialization("CreateMemcachedExternalCache", CreateMemcachedExternalCache_args);
		}

		// <summary>
		// Create a Mersenne Twister generator given a specific seed.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="Seed">Initial seed to use for generator. Default value: 1.</param>
		// <param name="IncludeZero">Whether or not to include zero in the generated numbers. Default value: false.</param>
		// <param name="IncrementSeed">Controls whether skipping or seed incrementing is used in parallel computation. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreateMersenneTwisterGenerator(object GeneratorName, object Seed, object IncludeZero, object IncrementSeed)
		{

			Hashtable CreateMersenneTwisterGenerator_args = new Hashtable();
			CreateMersenneTwisterGenerator_args.Add("GeneratorName", GeneratorName);
			CreateMersenneTwisterGenerator_args.Add("Seed", Seed);
			CreateMersenneTwisterGenerator_args.Add("IncludeZero", IncludeZero);
			CreateMersenneTwisterGenerator_args.Add("IncrementSeed", IncrementSeed);
			return F3Formatter.f3_style_serialization("CreateMersenneTwisterGenerator", CreateMersenneTwisterGenerator_args);
		}

		// <summary>
		// Create a yield to maturity convention for fixed coupon Mexican bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldAccrualConvention">Accrual convention for measuring the accrual fraction                                                                                       used in yield calculation.</param>
		// <param name="AccrueWholeCoupon">Accrue a whole regular first period when the settlement is a roll start date. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateMexicanYieldToMaturityConvention(object YieldConventionName, object YieldAccrualConvention, object AccrueWholeCoupon)
		{

			Hashtable CreateMexicanYieldToMaturityConvention_args = new Hashtable();
			CreateMexicanYieldToMaturityConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateMexicanYieldToMaturityConvention_args.Add("YieldAccrualConvention", YieldAccrualConvention);
			CreateMexicanYieldToMaturityConvention_args.Add("AccrueWholeCoupon", AccrueWholeCoupon);
			return F3Formatter.f3_style_serialization("CreateMexicanYieldToMaturityConvention", CreateMexicanYieldToMaturityConvention_args);
		}

		// <summary>
		// Create a replication strategy using a portfolio of call and put options, which are separated at the middle point of the input range..
		// </summary>
		// <param name="StrategyName">Name to use for the strategy.</param>
		// <param name="NumberOfOptions">Number of options to use in replication.</param>
		// <param name="LowerStrikeCutoff">The lowest strike to use in the replication. Default value: <s>Ratio</s><d>0.0</d>.</param>
		// <param name="UpperStrikeCutoff">The highest strike to use in the replication. Default value: <s>Ratio</s><d>5.0</d>.</param>
		// <returns>Retuns the name of the constructed object of type ReplicationStrategy.</returns>
		public object CreateMidPointMatchingReplicationStrategy(object StrategyName, object NumberOfOptions, object LowerStrikeCutoff, object UpperStrikeCutoff)
		{

			Hashtable CreateMidPointMatchingReplicationStrategy_args = new Hashtable();
			CreateMidPointMatchingReplicationStrategy_args.Add("StrategyName", StrategyName);
			CreateMidPointMatchingReplicationStrategy_args.Add("NumberOfOptions", NumberOfOptions);
			CreateMidPointMatchingReplicationStrategy_args.Add("LowerStrikeCutoff", LowerStrikeCutoff);
			CreateMidPointMatchingReplicationStrategy_args.Add("UpperStrikeCutoff", UpperStrikeCutoff);
			return F3Formatter.f3_style_serialization("CreateMidPointMatchingReplicationStrategy", CreateMidPointMatchingReplicationStrategy_args);
		}

		// <summary>
		// Creates a new miscellaneous bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the miscellaneous bibliography entry.</param>
		// <param name="Author">Author to use for the miscellaneous bibliography entry.</param>
		// <param name="Year">Year to use for the miscellaneous bibliography entry.</param>
		// <param name="Title">Title to use for the miscellaneous bibliography entry.</param>
		// <param name="Note">Note to use for the miscellaneous bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateMiscellaneousBibliographyEntry(object Name, object Author, object Year, object Title, object Note)
		{

			Hashtable CreateMiscellaneousBibliographyEntry_args = new Hashtable();
			CreateMiscellaneousBibliographyEntry_args.Add("Name", Name);
			CreateMiscellaneousBibliographyEntry_args.Add("Author", Author);
			CreateMiscellaneousBibliographyEntry_args.Add("Year", Year);
			CreateMiscellaneousBibliographyEntry_args.Add("Title", Title);
			CreateMiscellaneousBibliographyEntry_args.Add("Note", Note);
			return F3Formatter.f3_style_serialization("CreateMiscellaneousBibliographyEntry", CreateMiscellaneousBibliographyEntry_args);
		}

		// <summary>
		// Create an object by modifying a property of an existing object.
		// </summary>
		// <param name="NewObjectName">Name of newly created object.</param>
		// <param name="SourceObjectType">Repository to which the source object belongs.</param>
		// <param name="SourceObjectName">Name of source object.</param>
		// <param name="TargetPropertiesValues">Properties to modify when forming the new object and new values of corresponding properties.</param>
		// <returns>Retuns the name of the constructed object of type <Dynamic>.</returns>
		public object CreateModifiedObject(object NewObjectName, object SourceObjectType, object SourceObjectName, object TargetPropertiesValues)
		{

			Hashtable CreateModifiedObject_args = new Hashtable();
			CreateModifiedObject_args.Add("NewObjectName", NewObjectName);
			CreateModifiedObject_args.Add("SourceObjectType", SourceObjectType);
			CreateModifiedObject_args.Add("SourceObjectName", SourceObjectName);
			CreateModifiedObject_args.Add("TargetPropertiesValues", TargetPropertiesValues);
			return F3Formatter.f3_style_serialization("CreateModifiedObject", CreateModifiedObject_args);
		}

		// <summary>
		// Create a market convention which uses a date modifier to modify roll payment dates.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="PaymentModifier">Date modifier to be applied to payment dates. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateModifiedPaymentScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object PaymentModifier)
		{

			Hashtable CreateModifiedPaymentScheduleMarketConvention_args = new Hashtable();
			CreateModifiedPaymentScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateModifiedPaymentScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateModifiedPaymentScheduleMarketConvention_args.Add("PaymentModifier", PaymentModifier);
			return F3Formatter.f3_style_serialization("CreateModifiedPaymentScheduleMarketConvention", CreateModifiedPaymentScheduleMarketConvention_args);
		}

		// <summary>
		// Create a market convention using a date modifier for settlement calculations.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="PaymentHolidays">Holiday conventions for payment dates.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementModifier">Date modifier providing trade date to start date adjustment.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateModifierSettlementMarketConvention(object MarketConventionName, object PaymentHolidays, object MaturityCalculator, object SettlementModifier)
		{

			Hashtable CreateModifierSettlementMarketConvention_args = new Hashtable();
			CreateModifierSettlementMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateModifierSettlementMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateModifierSettlementMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateModifierSettlementMarketConvention_args.Add("SettlementModifier", SettlementModifier);
			return F3Formatter.f3_style_serialization("CreateModifierSettlementMarketConvention", CreateModifierSettlementMarketConvention_args);
		}

		// <summary>
		// Form a modifier from a stack of other modifiers.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Modifiers">List of modifiers to use to form a stack.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateModifierStack(object ModifierName, object Modifiers)
		{

			Hashtable CreateModifierStack_args = new Hashtable();
			CreateModifierStack_args.Add("ModifierName", ModifierName);
			CreateModifierStack_args.Add("Modifiers", Modifiers);
			return F3Formatter.f3_style_serialization("CreateModifierStack", CreateModifierStack_args);
		}

		// <summary>
		// Create a maturity calculator that modifies an underlying calculation according to a date modifier.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for maturity calculator.</param>
		// <param name="UnderlyingMaturityCalculator">Underlying maturity calculator.</param>
		// <param name="DateModifier">Date modifier. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateModifyingMaturityCalculator(object MaturityCalculatorName, object UnderlyingMaturityCalculator, object DateModifier)
		{

			Hashtable CreateModifyingMaturityCalculator_args = new Hashtable();
			CreateModifyingMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateModifyingMaturityCalculator_args.Add("UnderlyingMaturityCalculator", UnderlyingMaturityCalculator);
			CreateModifyingMaturityCalculator_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("CreateModifyingMaturityCalculator", CreateModifyingMaturityCalculator_args);
		}

		// <summary>
		// Define a contract type for a futures contract that pays based on the average value of the underlying index during the expiry month.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ValuePerBasisPoint">value per basis point for one contract.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateMonthlyAverageFuturesContractType(object ContractTypeName, object ValuePerBasisPoint, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateMonthlyAverageFuturesContractType_args = new Hashtable();
			CreateMonthlyAverageFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateMonthlyAverageFuturesContractType_args.Add("ValuePerBasisPoint", ValuePerBasisPoint);
			CreateMonthlyAverageFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateMonthlyAverageFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateMonthlyAverageFuturesContractType", CreateMonthlyAverageFuturesContractType_args);
		}

		// <summary>
		// Create a market data set containing monthly index fixings.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MonthValueName">Name of fixing market data.</param>
		// <param name="MonthValueType">Type of fixing market data.</param>
		// <param name="MonthlyFixings">Monthly fixing data.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateMonthlyFixingsMarketData(object MarketDataSetName, object MonthValueName, object MonthValueType, object MonthlyFixings)
		{

			Hashtable CreateMonthlyFixingsMarketData_args = new Hashtable();
			CreateMonthlyFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateMonthlyFixingsMarketData_args.Add("MonthValueName", MonthValueName);
			CreateMonthlyFixingsMarketData_args.Add("MonthValueType", MonthValueType);
			CreateMonthlyFixingsMarketData_args.Add("MonthlyFixings", MonthlyFixings);
			return F3Formatter.f3_style_serialization("CreateMonthlyFixingsMarketData", CreateMonthlyFixingsMarketData_args);
		}

		// <summary>
		// Create a market data set containing monthly fixings information for a specified index.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MonthlyFixings">Monthly fixing data to store within market data set.</param>
		// <param name="FixingsIndex">The index for which fixings will be provided.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateMonthlyIndexFixingsMarketData(object MarketDataSetName, object MonthlyFixings, object FixingsIndex)
		{

			Hashtable CreateMonthlyIndexFixingsMarketData_args = new Hashtable();
			CreateMonthlyIndexFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateMonthlyIndexFixingsMarketData_args.Add("MonthlyFixings", MonthlyFixings);
			CreateMonthlyIndexFixingsMarketData_args.Add("FixingsIndex", FixingsIndex);
			return F3Formatter.f3_style_serialization("CreateMonthlyIndexFixingsMarketData", CreateMonthlyIndexFixingsMarketData_args);
		}

		// <summary>
		// Create an index which is lagged by a certain number of months..
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Name of the underlying index.</param>
		// <param name="LagInMonths">Number of months to look back.</param>
		// <param name="HolidayConvention">Holiday convention for date adjustment. Default value: NoHolidays.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateMonthlyLaggedIndex(object IndexName, object UnderlyingIndex, object LagInMonths, object HolidayConvention)
		{

			Hashtable CreateMonthlyLaggedIndex_args = new Hashtable();
			CreateMonthlyLaggedIndex_args.Add("IndexName", IndexName);
			CreateMonthlyLaggedIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateMonthlyLaggedIndex_args.Add("LagInMonths", LagInMonths);
			CreateMonthlyLaggedIndex_args.Add("HolidayConvention", HolidayConvention);
			return F3Formatter.f3_style_serialization("CreateMonthlyLaggedIndex", CreateMonthlyLaggedIndex_args);
		}

		// <summary>
		// Create a market convention that generates schedules with rolls that are an integer number of months long.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="RollLength">Roll length, in months.</param>
		// <param name="StubType">Stub type.</param>
		// <param name="RollDayModifier">Date modifier applied to all roll end dates, excluding the final roll..</param>
		// <param name="DayCountConvention">Day count convention for calculation of accrual factors.</param>
		// <param name="ModifyStart">True if start date should also be adjusted using the RollDay modifier. Default value: false.</param>
		// <param name="EndDateModifier">Date modifier for the end date of the final roll. Default value: NullModifier.</param>
		// <param name="MonthEndMethod">Input specifying how to augment schedule generation when the schedule end date falls on the month end. Default value: NoAdjustment.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateMonthlyScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object RollLength, object StubType, object RollDayModifier, object DayCountConvention, object ModifyStart, object EndDateModifier, object MonthEndMethod)
		{

			Hashtable CreateMonthlyScheduleMarketConvention_args = new Hashtable();
			CreateMonthlyScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateMonthlyScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateMonthlyScheduleMarketConvention_args.Add("RollLength", RollLength);
			CreateMonthlyScheduleMarketConvention_args.Add("StubType", StubType);
			CreateMonthlyScheduleMarketConvention_args.Add("RollDayModifier", RollDayModifier);
			CreateMonthlyScheduleMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			CreateMonthlyScheduleMarketConvention_args.Add("ModifyStart", ModifyStart);
			CreateMonthlyScheduleMarketConvention_args.Add("EndDateModifier", EndDateModifier);
			CreateMonthlyScheduleMarketConvention_args.Add("MonthEndMethod", MonthEndMethod);
			return F3Formatter.f3_style_serialization("CreateMonthlyScheduleMarketConvention", CreateMonthlyScheduleMarketConvention_args);
		}

		// <summary>
		// Create a date modifier that finds the Nth valid date for a start date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="NumberOfDays">Number of days to adjust the date.</param>
		// <param name="HolidayConventions">Holiday conventions determine whether a given day is a valid payment date. Default value: NoHolidays.</param>
		// <param name="MoveForward">Set this flag to false to get backward date. This  parameter indicates if the adjustment is forward or backward. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateMoveDaysDateModifier(object DateModifierName, object NumberOfDays, object HolidayConventions, object MoveForward)
		{

			Hashtable CreateMoveDaysDateModifier_args = new Hashtable();
			CreateMoveDaysDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateMoveDaysDateModifier_args.Add("NumberOfDays", NumberOfDays);
			CreateMoveDaysDateModifier_args.Add("HolidayConventions", HolidayConventions);
			CreateMoveDaysDateModifier_args.Add("MoveForward", MoveForward);
			return F3Formatter.f3_style_serialization("CreateMoveDaysDateModifier", CreateMoveDaysDateModifier_args);
		}

		// <summary>
		// Create a date modifier that finds the Nth valid month for a start date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="NumberOfMonths">Number of months to adjust the date.</param>
		// <param name="HolidayConventions">Holiday conventions determine whether a given day is a valid payment date. Default value: NoHolidays.</param>
		// <param name="RollIntoNextMonth">Set this flag to true to allow adjusted date to roll into the next month. Default value: false.</param>
		// <param name="PreserveMonthEnd">Controls how the month end should be treated. Default value: PreserveIntermediate.</param>
		// <param name="MoveForward">Set this flag to true to adjust the date forward, false to adjust backward. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateMoveMonthsDateModifier(object DateModifierName, object NumberOfMonths, object HolidayConventions, object RollIntoNextMonth, object PreserveMonthEnd, object MoveForward)
		{

			Hashtable CreateMoveMonthsDateModifier_args = new Hashtable();
			CreateMoveMonthsDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateMoveMonthsDateModifier_args.Add("NumberOfMonths", NumberOfMonths);
			CreateMoveMonthsDateModifier_args.Add("HolidayConventions", HolidayConventions);
			CreateMoveMonthsDateModifier_args.Add("RollIntoNextMonth", RollIntoNextMonth);
			CreateMoveMonthsDateModifier_args.Add("PreserveMonthEnd", PreserveMonthEnd);
			CreateMoveMonthsDateModifier_args.Add("MoveForward", MoveForward);
			return F3Formatter.f3_style_serialization("CreateMoveMonthsDateModifier", CreateMoveMonthsDateModifier_args);
		}

		// <summary>
		// Create a date modifier that finds the Nth valid quarter for a start date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="NumberOfQuarters">Number of quarters to adjust the date.</param>
		// <param name="HolidayConventions">Holiday conventions determine whether a given day is a valid payment date. Default value: NoHolidays.</param>
		// <param name="RollIntoNextQuarter">Set this flag to true to allow the adjusted date to roll into the next quarter. Default value: false.</param>
		// <param name="PreserveQuarterEnd">Set this flag to true to preserve the quarter end if the start date is at the end of a quarter. Default value: true.</param>
		// <param name="MoveForward">Set this flag to true to adjust the date forward and to false to adjust the date backward. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateMoveQuartersDateModifier(object DateModifierName, object NumberOfQuarters, object HolidayConventions, object RollIntoNextQuarter, object PreserveQuarterEnd, object MoveForward)
		{

			Hashtable CreateMoveQuartersDateModifier_args = new Hashtable();
			CreateMoveQuartersDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateMoveQuartersDateModifier_args.Add("NumberOfQuarters", NumberOfQuarters);
			CreateMoveQuartersDateModifier_args.Add("HolidayConventions", HolidayConventions);
			CreateMoveQuartersDateModifier_args.Add("RollIntoNextQuarter", RollIntoNextQuarter);
			CreateMoveQuartersDateModifier_args.Add("PreserveQuarterEnd", PreserveQuarterEnd);
			CreateMoveQuartersDateModifier_args.Add("MoveForward", MoveForward);
			return F3Formatter.f3_style_serialization("CreateMoveQuartersDateModifier", CreateMoveQuartersDateModifier_args);
		}

		// <summary>
		// Create a multi-asset correlating modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Correlations">Matrix of inter-asset correlations.</param>
		// <param name="CorrelationsParameterTag">Tag to use for correlation parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateMultiAssetConstantCorrelationModifier(object ModifierName, object Correlations, object CorrelationsParameterTag)
		{

			Hashtable CreateMultiAssetConstantCorrelationModifier_args = new Hashtable();
			CreateMultiAssetConstantCorrelationModifier_args.Add("ModifierName", ModifierName);
			CreateMultiAssetConstantCorrelationModifier_args.Add("Correlations", Correlations);
			CreateMultiAssetConstantCorrelationModifier_args.Add("CorrelationsParameterTag", CorrelationsParameterTag);
			return F3Formatter.f3_style_serialization("CreateMultiAssetConstantCorrelationModifier", CreateMultiAssetConstantCorrelationModifier_args);
		}

		// <summary>
		// Create a multi-asset correlating modifier given term volatility and correlation functions and a vector of time points.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="VolatlityFunctions">Vector of volatility functions.</param>
		// <param name="CorrelationFunctions">Vector of correlation functions.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateMultiAssetCorrelationModifier(object ModifierName, object VolatlityFunctions, object CorrelationFunctions, object TimePoints)
		{

			Hashtable CreateMultiAssetCorrelationModifier_args = new Hashtable();
			CreateMultiAssetCorrelationModifier_args.Add("ModifierName", ModifierName);
			CreateMultiAssetCorrelationModifier_args.Add("VolatlityFunctions", VolatlityFunctions);
			CreateMultiAssetCorrelationModifier_args.Add("CorrelationFunctions", CorrelationFunctions);
			CreateMultiAssetCorrelationModifier_args.Add("TimePoints", TimePoints);
			return F3Formatter.f3_style_serialization("CreateMultiAssetCorrelationModifier", CreateMultiAssetCorrelationModifier_args);
		}

		// <summary>
		// Create a multi-asset correlating modifier given a set of term covariance matrices.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="CovarianceMatrices">Collection of term covariance matrices.</param>
		// <param name="CovarianceParameterTag">Tag to use for covariance parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier(object ModifierName, object CovarianceMatrices, object CovarianceParameterTag)
		{

			Hashtable CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier_args = new Hashtable();
			CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier_args.Add("ModifierName", ModifierName);
			CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier_args.Add("CovarianceMatrices", CovarianceMatrices);
			CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier_args.Add("CovarianceParameterTag", CovarianceParameterTag);
			return F3Formatter.f3_style_serialization("CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier", CreateMultiAssetCorrelationWithTermCovarianceMatricesModifier_args);
		}

		// <summary>
		// Create a closed-form valuation specification for the multi-factor Hull-White model.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="NumberOfFactors">Number of factors in the Hull-White model.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateMultiFactorHullWhiteClosedFormValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object NumberOfFactors)
		{

			Hashtable CreateMultiFactorHullWhiteClosedFormValuationSpecification_args = new Hashtable();
			CreateMultiFactorHullWhiteClosedFormValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateMultiFactorHullWhiteClosedFormValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateMultiFactorHullWhiteClosedFormValuationSpecification_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateMultiFactorHullWhiteClosedFormValuationSpecification", CreateMultiFactorHullWhiteClosedFormValuationSpecification_args);
		}

		// <summary>
		// Create a closed-form valuation specification builder for the multi-factor Hull-White model.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="NumberOfFactors">Number of factors in the Hull-White model.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder(object BuilderName, object NumberOfFactors)
		{

			Hashtable CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder_args = new Hashtable();
			CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder", CreateMultiFactorHullWhiteClosedFormValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a multiple-event credit tranche accrual index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateMultipleEventCreditTrancheAccrualIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateMultipleEventCreditTrancheAccrualIndex_args = new Hashtable();
			CreateMultipleEventCreditTrancheAccrualIndex_args.Add("IndexName", IndexName);
			CreateMultipleEventCreditTrancheAccrualIndex_args.Add("CreditContract", CreditContract);
			CreateMultipleEventCreditTrancheAccrualIndex_args.Add("Currency", Currency);
			CreateMultipleEventCreditTrancheAccrualIndex_args.Add("MarketConventions", MarketConventions);
			CreateMultipleEventCreditTrancheAccrualIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateMultipleEventCreditTrancheAccrualIndex", CreateMultipleEventCreditTrancheAccrualIndex_args);
		}

		// <summary>
		// Create a multiple-event credit tranche default index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateMultipleEventCreditTrancheDefaultIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateMultipleEventCreditTrancheDefaultIndex_args = new Hashtable();
			CreateMultipleEventCreditTrancheDefaultIndex_args.Add("IndexName", IndexName);
			CreateMultipleEventCreditTrancheDefaultIndex_args.Add("CreditContract", CreditContract);
			CreateMultipleEventCreditTrancheDefaultIndex_args.Add("Currency", Currency);
			CreateMultipleEventCreditTrancheDefaultIndex_args.Add("MarketConventions", MarketConventions);
			CreateMultipleEventCreditTrancheDefaultIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateMultipleEventCreditTrancheDefaultIndex", CreateMultipleEventCreditTrancheDefaultIndex_args);
		}

		// <summary>
		// Create a multiple-event credit tranche pool index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of credit events and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateMultipleEventCreditTranchePoolIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateMultipleEventCreditTranchePoolIndex_args = new Hashtable();
			CreateMultipleEventCreditTranchePoolIndex_args.Add("IndexName", IndexName);
			CreateMultipleEventCreditTranchePoolIndex_args.Add("CreditContract", CreditContract);
			CreateMultipleEventCreditTranchePoolIndex_args.Add("Currency", Currency);
			CreateMultipleEventCreditTranchePoolIndex_args.Add("MarketConventions", MarketConventions);
			CreateMultipleEventCreditTranchePoolIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateMultipleEventCreditTranchePoolIndex", CreateMultipleEventCreditTranchePoolIndex_args);
		}

		// <summary>
		// Create a calculation method that uses a given number of threads.
		// </summary>
		// <param name="MethodName">Name to use for new method instance.</param>
		// <param name="NumberOfThreads">Number of separate threads of execution.</param>
		// <returns>Retuns the name of the constructed object of type CalculationStrategy.</returns>
		public object CreateMultithreadedCalculationStrategy(object MethodName, object NumberOfThreads)
		{

			Hashtable CreateMultithreadedCalculationStrategy_args = new Hashtable();
			CreateMultithreadedCalculationStrategy_args.Add("MethodName", MethodName);
			CreateMultithreadedCalculationStrategy_args.Add("NumberOfThreads", NumberOfThreads);
			return F3Formatter.f3_style_serialization("CreateMultithreadedCalculationStrategy", CreateMultithreadedCalculationStrategy_args);
		}

		// <summary>
		// Create a multivariate normal random number generator.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="UnderlyingGenerator">Underlying unit interval uniform random number generator. Default value: MersenneTwister.</param>
		// <param name="Means">Means of the random numbers. Default value: 0.</param>
		// <param name="StandardDeviations">Standard deviations of the random numbers. Default value: 1.</param>
		// <param name="CorrelationMatrix">Correlation matrix. Default value: default-constructed instance of type ragged_matrix.</param>
		// <param name="MeansParameterTag">Tag to use for the means. Default value: default-constructed instance of type parameter_tag.</param>
		// <param name="StandardDeviationsParameterTag">Tag to use for the standard deviations. Default value: default-constructed instance of type parameter_tag.</param>
		// <param name="CorrelationsParameterTag">Tag to use for the correlations. Default value: default-constructed instance of type parameter_tag.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreateMultivariateNormalGenerator(object GeneratorName, object UnderlyingGenerator, object Means, object StandardDeviations, object CorrelationMatrix, object MeansParameterTag, object StandardDeviationsParameterTag, object CorrelationsParameterTag)
		{

			Hashtable CreateMultivariateNormalGenerator_args = new Hashtable();
			CreateMultivariateNormalGenerator_args.Add("GeneratorName", GeneratorName);
			CreateMultivariateNormalGenerator_args.Add("UnderlyingGenerator", UnderlyingGenerator);
			CreateMultivariateNormalGenerator_args.Add("Means", Means);
			CreateMultivariateNormalGenerator_args.Add("StandardDeviations", StandardDeviations);
			CreateMultivariateNormalGenerator_args.Add("CorrelationMatrix", CorrelationMatrix);
			CreateMultivariateNormalGenerator_args.Add("MeansParameterTag", MeansParameterTag);
			CreateMultivariateNormalGenerator_args.Add("StandardDeviationsParameterTag", StandardDeviationsParameterTag);
			CreateMultivariateNormalGenerator_args.Add("CorrelationsParameterTag", CorrelationsParameterTag);
			return F3Formatter.f3_style_serialization("CreateMultivariateNormalGenerator", CreateMultivariateNormalGenerator_args);
		}

		// <summary>
		// Create a wrapper object representing a registered HTTP server object.
		// </summary>
		// <param name="ServerName">Name of the wrapper object.</param>
		// <param name="HTTPServer">An HTTP server to register.</param>
		// <param name="SuggestedName">The suggested registration name for an F3 instance.</param>
		// <param name="NameServerAddress">Address of the name server.</param>
		// <returns>Retuns the name of the constructed object of type Server.</returns>
		public object CreateNameServiceRegistration(object ServerName, object HTTPServer, object SuggestedName, object NameServerAddress)
		{

			Hashtable CreateNameServiceRegistration_args = new Hashtable();
			CreateNameServiceRegistration_args.Add("ServerName", ServerName);
			CreateNameServiceRegistration_args.Add("HTTPServer", HTTPServer);
			CreateNameServiceRegistration_args.Add("SuggestedName", SuggestedName);
			CreateNameServiceRegistration_args.Add("NameServerAddress", NameServerAddress);
			return F3Formatter.f3_style_serialization("CreateNameServiceRegistration", CreateNameServiceRegistration_args);
		}

		// <summary>
		// Create a market data set containing a set of implied Black volatility quotes in a non-sparse matrix for vanilla options.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of option expiries.</param>
		// <param name="Strikes">Vector of option strikes.</param>
		// <param name="ImpliedVolatilities">Matrix of option-implied volatilities.</param>
		// <param name="DataName">Name of market data.</param>
		// <param name="DataType">Type of market data.</param>
		// <param name="Payoff">Payoff specification.</param>
		// <param name="MarketConventions">Market conventions for the options.</param>
		// <param name="UnderlyingIndex">Index describing the option underlying.</param>
		// <param name="QuoteDate">Day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateNonSparseVanillaOptionMarketData(object MarketDataSetName, object Expiries, object Strikes, object ImpliedVolatilities, object DataName, object DataType, object Payoff, object MarketConventions, object UnderlyingIndex, object QuoteDate)
		{

			Hashtable CreateNonSparseVanillaOptionMarketData_args = new Hashtable();
			CreateNonSparseVanillaOptionMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateNonSparseVanillaOptionMarketData_args.Add("Expiries", Expiries);
			CreateNonSparseVanillaOptionMarketData_args.Add("Strikes", Strikes);
			CreateNonSparseVanillaOptionMarketData_args.Add("ImpliedVolatilities", ImpliedVolatilities);
			CreateNonSparseVanillaOptionMarketData_args.Add("DataName", DataName);
			CreateNonSparseVanillaOptionMarketData_args.Add("DataType", DataType);
			CreateNonSparseVanillaOptionMarketData_args.Add("Payoff", Payoff);
			CreateNonSparseVanillaOptionMarketData_args.Add("MarketConventions", MarketConventions);
			CreateNonSparseVanillaOptionMarketData_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateNonSparseVanillaOptionMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateNonSparseVanillaOptionMarketData", CreateNonSparseVanillaOptionMarketData_args);
		}

		// <summary>
		// Create a non-parametric function modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="ValueFunction">One-dimensional real function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateNonparametricFunctionModifier(object ModifierName, object ValueFunction)
		{

			Hashtable CreateNonparametricFunctionModifier_args = new Hashtable();
			CreateNonparametricFunctionModifier_args.Add("ModifierName", ModifierName);
			CreateNonparametricFunctionModifier_args.Add("ValueFunction", ValueFunction);
			return F3Formatter.f3_style_serialization("CreateNonparametricFunctionModifier", CreateNonparametricFunctionModifier_args);
		}

		// <summary>
		// Create a non-parametric function modifier from a list of functions.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="ValueFunctions">List of one-dimensional real function objects.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateNonparametricFunctionSetModifier(object ModifierName, object ValueFunctions)
		{

			Hashtable CreateNonparametricFunctionSetModifier_args = new Hashtable();
			CreateNonparametricFunctionSetModifier_args.Add("ModifierName", ModifierName);
			CreateNonparametricFunctionSetModifier_args.Add("ValueFunctions", ValueFunctions);
			return F3Formatter.f3_style_serialization("CreateNonparametricFunctionSetModifier", CreateNonparametricFunctionSetModifier_args);
		}

		// <summary>
		// Create the characteristic function for the normal distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="MuValue">Value of the mean.</param>
		// <param name="SigmaValue">Value of the standard deviation.</param>
		// <param name="MuParameterTag">Tag to use for the mean.</param>
		// <param name="SigmaParameterTag">Tag to use for the standard deviation.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalComplexFunction.</returns>
		public object CreateNormalCharacteristicFunction(object FunctionName, object MuValue, object SigmaValue, object MuParameterTag, object SigmaParameterTag)
		{

			Hashtable CreateNormalCharacteristicFunction_args = new Hashtable();
			CreateNormalCharacteristicFunction_args.Add("FunctionName", FunctionName);
			CreateNormalCharacteristicFunction_args.Add("MuValue", MuValue);
			CreateNormalCharacteristicFunction_args.Add("SigmaValue", SigmaValue);
			CreateNormalCharacteristicFunction_args.Add("MuParameterTag", MuParameterTag);
			CreateNormalCharacteristicFunction_args.Add("SigmaParameterTag", SigmaParameterTag);
			return F3Formatter.f3_style_serialization("CreateNormalCharacteristicFunction", CreateNormalCharacteristicFunction_args);
		}

		// <summary>
		// Create a normal modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateNormalModifier(object ModifierName, object TimePoints, object ForwardFunction, object VolatilityFunction)
		{

			Hashtable CreateNormalModifier_args = new Hashtable();
			CreateNormalModifier_args.Add("ModifierName", ModifierName);
			CreateNormalModifier_args.Add("TimePoints", TimePoints);
			CreateNormalModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateNormalModifier_args.Add("VolatilityFunction", VolatilityFunction);
			return F3Formatter.f3_style_serialization("CreateNormalModifier", CreateNormalModifier_args);
		}

		// <summary>
		// Create a market convention that generates schedules with accrual factors in the stub calculated using the specified day count convention incorporating notional periods.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="StubDayCountConvention">Day count convention for calculating accrual factors of stub rolls. Default value: act/360.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateNotionalStubScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object StubDayCountConvention)
		{

			Hashtable CreateNotionalStubScheduleMarketConvention_args = new Hashtable();
			CreateNotionalStubScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateNotionalStubScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateNotionalStubScheduleMarketConvention_args.Add("StubDayCountConvention", StubDayCountConvention);
			return F3Formatter.f3_style_serialization("CreateNotionalStubScheduleMarketConvention", CreateNotionalStubScheduleMarketConvention_args);
		}

		// <summary>
		// Create a date modifier which finds the Nth occurrence of a specific day of the week from the first or the last day of the month.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="OccurrenceOfDay">An integer from one to five, representing the Nth occurrence of the specified day.</param>
		// <param name="DayOfWeek">A string representing the day of the week.</param>
		// <param name="WeekIsFromMonthEnd">Set this flag to true if the week is from the end of the month. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateNthDayOfWeekDateModifier(object DateModifierName, object OccurrenceOfDay, object DayOfWeek, object WeekIsFromMonthEnd)
		{

			Hashtable CreateNthDayOfWeekDateModifier_args = new Hashtable();
			CreateNthDayOfWeekDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateNthDayOfWeekDateModifier_args.Add("OccurrenceOfDay", OccurrenceOfDay);
			CreateNthDayOfWeekDateModifier_args.Add("DayOfWeek", DayOfWeek);
			CreateNthDayOfWeekDateModifier_args.Add("WeekIsFromMonthEnd", WeekIsFromMonthEnd);
			return F3Formatter.f3_style_serialization("CreateNthDayOfWeekDateModifier", CreateNthDayOfWeekDateModifier_args);
		}

		// <summary>
		// Define a contract written on a basket of credit entities.
		// </summary>
		// <param name="Name">Name to use for the Nth-to-default contract.</param>
		// <param name="CreditPortfolio">The underlying portfolio of credit entities.</param>
		// <param name="NumberOfDefaults">The number of defaults in the portfolio defining a default event.</param>
		// <param name="PayRecoveryOnDefault">Switch for whether the recovery amount or the principal is paid on default. Default value: True.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateNthToDefaultContract(object Name, object CreditPortfolio, object NumberOfDefaults, object PayRecoveryOnDefault)
		{

			Hashtable CreateNthToDefaultContract_args = new Hashtable();
			CreateNthToDefaultContract_args.Add("Name", Name);
			CreateNthToDefaultContract_args.Add("CreditPortfolio", CreditPortfolio);
			CreateNthToDefaultContract_args.Add("NumberOfDefaults", NumberOfDefaults);
			CreateNthToDefaultContract_args.Add("PayRecoveryOnDefault", PayRecoveryOnDefault);
			return F3Formatter.f3_style_serialization("CreateNthToDefaultContract", CreateNthToDefaultContract_args);
		}

		// <summary>
		// Create a single-currency product with no value.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Notional">Notional amount of the product.</param>
		// <param name="PayRec">Pay/Receive or Buy/Sell specification.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateNullSingleCurrencyProduct(object ProductName, object Currency, object Notional, object PayRec)
		{

			Hashtable CreateNullSingleCurrencyProduct_args = new Hashtable();
			CreateNullSingleCurrencyProduct_args.Add("ProductName", ProductName);
			CreateNullSingleCurrencyProduct_args.Add("Currency", Currency);
			CreateNullSingleCurrencyProduct_args.Add("Notional", Notional);
			CreateNullSingleCurrencyProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateNullSingleCurrencyProduct", CreateNullSingleCurrencyProduct_args);
		}

		// <summary>
		// Form a valuation specification that specifies a single valuation currency.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Specification of the numeraire.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateNumeraireCurrencyValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency)
		{

			Hashtable CreateNumeraireCurrencyValuationSpecification_args = new Hashtable();
			CreateNumeraireCurrencyValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateNumeraireCurrencyValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateNumeraireCurrencyValuationSpecification_args.Add("Currency", Currency);
			return F3Formatter.f3_style_serialization("CreateNumeraireCurrencyValuationSpecification", CreateNumeraireCurrencyValuationSpecification_args);
		}

		// <summary>
		// Create a named object containing an arbitrary value.
		// </summary>
		// <param name="ObjectName">Name to associate with object.</param>
		// <param name="ObjectValue">Object value to be stored.</param>
		// <returns>Retuns the name of the constructed object of type ObjectValue.</returns>
		public object CreateObjectValue(object ObjectName, object ObjectValue)
		{

			Hashtable CreateObjectValue_args = new Hashtable();
			CreateObjectValue_args.Add("ObjectName", ObjectName);
			CreateObjectValue_args.Add("ObjectValue", ObjectValue);
			return F3Formatter.f3_style_serialization("CreateObjectValue", CreateObjectValue_args);
		}

		// <summary>
		// Create a one-dimensional slice of a three-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ThreeDimFunction">Three-dimensional function to slice.</param>
		// <param name="ConstantArguments">Values of the two fixed arguments.</param>
		// <param name="ConstantParametersTag">Tag for the two constant parameters.</param>
		// <param name="VariableIndex">Index of the non-constant variable.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateOneDimSliceOf3dFunction(object FunctionName, object ThreeDimFunction, object ConstantArguments, object ConstantParametersTag, object VariableIndex)
		{

			Hashtable CreateOneDimSliceOf3dFunction_args = new Hashtable();
			CreateOneDimSliceOf3dFunction_args.Add("FunctionName", FunctionName);
			CreateOneDimSliceOf3dFunction_args.Add("ThreeDimFunction", ThreeDimFunction);
			CreateOneDimSliceOf3dFunction_args.Add("ConstantArguments", ConstantArguments);
			CreateOneDimSliceOf3dFunction_args.Add("ConstantParametersTag", ConstantParametersTag);
			CreateOneDimSliceOf3dFunction_args.Add("VariableIndex", VariableIndex);
			return F3Formatter.f3_style_serialization("CreateOneDimSliceOf3dFunction", CreateOneDimSliceOf3dFunction_args);
		}

		// <summary>
		// Create a calibration target for one or more one-dimensional curves.
		// </summary>
		// <param name="CalibrationTargetName">Name to use for calibration target.</param>
		// <param name="CurveTags">Target curve tags.</param>
		// <param name="InterpolationTypes">Interpolation methodologies, one per target curve.</param>
		// <param name="InitialValueCurves">Initial values, one per target curve.</param>
		// <param name="BoundConstraints">Bound constraints for curve values. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="OptimizationObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <param name="EliminateIndices">Indices indicating which curves not to calibrate. Default value: default-constructed instance of type unsigned_small_integers.</param>
		// <param name="TimePointMethod">Method for determining the curve time points for calibration. Default value: DropIfNotIncreasing.</param>
		// <param name="UseGhosts">Flag indicating whether to use ghost curves. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationTarget.</returns>
		public object CreateOneDimensionalCalibrationTarget(object CalibrationTargetName, object CurveTags, object InterpolationTypes, object InitialValueCurves, object BoundConstraints, object OptimizationObjective, object EliminateIndices, object TimePointMethod, object UseGhosts)
		{

			Hashtable CreateOneDimensionalCalibrationTarget_args = new Hashtable();
			CreateOneDimensionalCalibrationTarget_args.Add("CalibrationTargetName", CalibrationTargetName);
			CreateOneDimensionalCalibrationTarget_args.Add("CurveTags", CurveTags);
			CreateOneDimensionalCalibrationTarget_args.Add("InterpolationTypes", InterpolationTypes);
			CreateOneDimensionalCalibrationTarget_args.Add("InitialValueCurves", InitialValueCurves);
			CreateOneDimensionalCalibrationTarget_args.Add("BoundConstraints", BoundConstraints);
			CreateOneDimensionalCalibrationTarget_args.Add("OptimizationObjective", OptimizationObjective);
			CreateOneDimensionalCalibrationTarget_args.Add("EliminateIndices", EliminateIndices);
			CreateOneDimensionalCalibrationTarget_args.Add("TimePointMethod", TimePointMethod);
			CreateOneDimensionalCalibrationTarget_args.Add("UseGhosts", UseGhosts);
			return F3Formatter.f3_style_serialization("CreateOneDimensionalCalibrationTarget", CreateOneDimensionalCalibrationTarget_args);
		}

		// <summary>
		// Create an entire curve calibration target for a one-dimensional curve.
		// </summary>
		// <param name="CalibrationTargetName">Name to use for calibration target.</param>
		// <param name="CurveTag">Target curve tag.</param>
		// <param name="InterpolationType">Interpolation methodology for the target curve. Default value: MonotoneConvexExponentialDecay.</param>
		// <param name="InitialValueCurve">Initial value for the target curve.</param>
		// <param name="BoundConstraint">Bound constraint for curve values. Default value: NoBoundConstraint.</param>
		// <param name="OptimizationObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <param name="UseGhosts">Flag indicating whether to use ghost curves. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationTarget.</returns>
		public object CreateOneDimensionalEntireCurveCalibrationTarget(object CalibrationTargetName, object CurveTag, object InterpolationType, object InitialValueCurve, object BoundConstraint, object OptimizationObjective, object UseGhosts)
		{

			Hashtable CreateOneDimensionalEntireCurveCalibrationTarget_args = new Hashtable();
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("CalibrationTargetName", CalibrationTargetName);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("CurveTag", CurveTag);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("InterpolationType", InterpolationType);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("InitialValueCurve", InitialValueCurve);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("BoundConstraint", BoundConstraint);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("OptimizationObjective", OptimizationObjective);
			CreateOneDimensionalEntireCurveCalibrationTarget_args.Add("UseGhosts", UseGhosts);
			return F3Formatter.f3_style_serialization("CreateOneDimensionalEntireCurveCalibrationTarget", CreateOneDimensionalEntireCurveCalibrationTarget_args);
		}

		// <summary>
		// Create a one-dimensional interpolation function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="XValues">Array of X points.</param>
		// <param name="YValues">Array of Y points.</param>
		// <param name="XParameterTag">Tag to use for the X parameters.</param>
		// <param name="YParameterTag">Tag to use for the Y parameters.</param>
		// <param name="InterpolationMethod">Interpolation method.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateOneDimensionalInterpolationFunction(object FunctionName, object XValues, object YValues, object XParameterTag, object YParameterTag, object InterpolationMethod)
		{

			Hashtable CreateOneDimensionalInterpolationFunction_args = new Hashtable();
			CreateOneDimensionalInterpolationFunction_args.Add("FunctionName", FunctionName);
			CreateOneDimensionalInterpolationFunction_args.Add("XValues", XValues);
			CreateOneDimensionalInterpolationFunction_args.Add("YValues", YValues);
			CreateOneDimensionalInterpolationFunction_args.Add("XParameterTag", XParameterTag);
			CreateOneDimensionalInterpolationFunction_args.Add("YParameterTag", YParameterTag);
			CreateOneDimensionalInterpolationFunction_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("CreateOneDimensionalInterpolationFunction", CreateOneDimensionalInterpolationFunction_args);
		}

		// <summary>
		// Create a one-dimensional interpolation function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="XValues">Array of X points.</param>
		// <param name="YValues">Array of Y points.</param>
		// <param name="XParameterTag">Tag to use for the X parameters.</param>
		// <param name="YParameterTag">Tag to use for the Y parameters.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateOneDimensionalLinearInterpolationFunction(object FunctionName, object XValues, object YValues, object XParameterTag, object YParameterTag)
		{

			Hashtable CreateOneDimensionalLinearInterpolationFunction_args = new Hashtable();
			CreateOneDimensionalLinearInterpolationFunction_args.Add("FunctionName", FunctionName);
			CreateOneDimensionalLinearInterpolationFunction_args.Add("XValues", XValues);
			CreateOneDimensionalLinearInterpolationFunction_args.Add("YValues", YValues);
			CreateOneDimensionalLinearInterpolationFunction_args.Add("XParameterTag", XParameterTag);
			CreateOneDimensionalLinearInterpolationFunction_args.Add("YParameterTag", YParameterTag);
			return F3Formatter.f3_style_serialization("CreateOneDimensionalLinearInterpolationFunction", CreateOneDimensionalLinearInterpolationFunction_args);
		}

		// <summary>
		// Create an index whose value is the option numeraire function of an underlying index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="OptionNumeraire">Option numeraire function. Default value: default-constructed instance of type option_numeraire.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateOptionNumeraireIndex(object IndexName, object UnderlyingIndex, object OptionNumeraire)
		{

			Hashtable CreateOptionNumeraireIndex_args = new Hashtable();
			CreateOptionNumeraireIndex_args.Add("IndexName", IndexName);
			CreateOptionNumeraireIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateOptionNumeraireIndex_args.Add("OptionNumeraire", OptionNumeraire);
			return F3Formatter.f3_style_serialization("CreateOptionNumeraireIndex", CreateOptionNumeraireIndex_args);
		}

		// <summary>
		// Create an Ornstein-Uhlenbeck modifier with constant mean reversion coefficient and volatility.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Tag to use for the mean reversion coefficient.</param>
		// <param name="Volatility">Volatility (constant).</param>
		// <param name="VolatilityTag">Tag to use for the volatility.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object Volatility, object VolatilityTag, object ForwardMeasureIndex)
		{

			Hashtable CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args = new Hashtable();
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("MeanReversion", MeanReversion);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("Volatility", Volatility);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("VolatilityTag", VolatilityTag);
			CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			return F3Formatter.f3_style_serialization("CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier", CreateOrnsteinUhlenbeckWithConstantMeanReversionAndVolatilityModifier_args);
		}

		// <summary>
		// Create an Ornstein-Uhlenbeck modifier with a time-varying volatility function and a constant mean reversion coefficient. Integrals are done numerically.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="VolatilityFunction">Short rate volatility function.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="IntegrationMethod">The numerical method to evaluate integrals of the short rate volatility function with exponential factor.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object VolatilityFunction, object ForwardMeasureIndex, object IntegrationMethod)
		{

			Hashtable CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args = new Hashtable();
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("ModifierName", ModifierName);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("TimePoints", TimePoints);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("MeanReversion", MeanReversion);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier", CreateOrnsteinUhlenbeckWithNumericalIntegrationModifier_args);
		}

		// <summary>
		// Create an Ornstein-Uhlenbeck modifier with a time-varying volatility function and a constant mean reversion coefficient. Integrals are done analytically assuming piecewise-constant instantaneous volatility.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="MeanReversion">Mean reversion coefficient (constant).</param>
		// <param name="MeanReversionTag">Mean reversion tag.</param>
		// <param name="VolatilityFunction">Short rate volatility function.</param>
		// <param name="ForwardMeasureIndex">T-forward measure index in TimePoints.</param>
		// <param name="TimePointsForVolatilityFunction">Time points defining the piecewise-constant volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier(object ModifierName, object TimePoints, object MeanReversion, object MeanReversionTag, object VolatilityFunction, object ForwardMeasureIndex, object TimePointsForVolatilityFunction)
		{

			Hashtable CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args = new Hashtable();
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("ModifierName", ModifierName);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("TimePoints", TimePoints);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("MeanReversion", MeanReversion);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("MeanReversionTag", MeanReversionTag);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("ForwardMeasureIndex", ForwardMeasureIndex);
			CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args.Add("TimePointsForVolatilityFunction", TimePointsForVolatilityFunction);
			return F3Formatter.f3_style_serialization("CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier", CreateOrnsteinUhlenbeckWithPiecewiseConstantInstantaneousVolatilityModifier_args);
		}

		// <summary>
		// Create a client for a TCP connection to another instance of F3.
		// </summary>
		// <param name="ConnectionName">Name to use for outbound connection.</param>
		// <param name="Address">Name of network host.</param>
		// <param name="Port">Host port number.</param>
		// <param name="Cookie">Secret cookie for the connection validation.</param>
		// <param name="Timeout">Timeout in milliseconds for socket communication. Default value: 300000.</param>
		// <returns>Retuns the name of the constructed object of type OutboundConnection.</returns>
		public object CreateOutboundTCPConnection(object ConnectionName, object Address, object Port, object Cookie, object Timeout)
		{

			Hashtable CreateOutboundTCPConnection_args = new Hashtable();
			CreateOutboundTCPConnection_args.Add("ConnectionName", ConnectionName);
			CreateOutboundTCPConnection_args.Add("Address", Address);
			CreateOutboundTCPConnection_args.Add("Port", Port);
			CreateOutboundTCPConnection_args.Add("Cookie", Cookie);
			CreateOutboundTCPConnection_args.Add("Timeout", Timeout);
			return F3Formatter.f3_style_serialization("CreateOutboundTCPConnection", CreateOutboundTCPConnection_args);
		}

		// <summary>
		// Create an overnight index swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure of the swap.</param>
		// <param name="FixedCoupon">The fixed coupon paid on each roll of the fixed leg.</param>
		// <param name="FixedLegMarketConvention">Schedule generator for the fixed leg.</param>
		// <param name="OvernightRateIndex">Index describing the overnight rate to be compounded.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateOvernightIndexSwap(object ProductName, object StartDate, object Maturity, object Notional, object FixedCoupon, object FixedLegMarketConvention, object OvernightRateIndex, object Margin, object FloatingLegMarketConvention, object PayRec)
		{

			Hashtable CreateOvernightIndexSwap_args = new Hashtable();
			CreateOvernightIndexSwap_args.Add("ProductName", ProductName);
			CreateOvernightIndexSwap_args.Add("StartDate", StartDate);
			CreateOvernightIndexSwap_args.Add("Maturity", Maturity);
			CreateOvernightIndexSwap_args.Add("Notional", Notional);
			CreateOvernightIndexSwap_args.Add("FixedCoupon", FixedCoupon);
			CreateOvernightIndexSwap_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateOvernightIndexSwap_args.Add("OvernightRateIndex", OvernightRateIndex);
			CreateOvernightIndexSwap_args.Add("Margin", Margin);
			CreateOvernightIndexSwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateOvernightIndexSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateOvernightIndexSwap", CreateOvernightIndexSwap_args);
		}

		// <summary>
		// Create a simple overnight interest rate index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Currency">Currency underlying rate.</param>
		// <param name="MarketConventions">Market conventions for the rate.</param>
		// <param name="FixingReferencer">Index referencer. Default value: default-constructed instance of type referencer.</param>
		// <param name="OptionalFixingTableName">Optional name for the fixings table associated with the index. Default value: default-constructed instance of type fixings_name.</param>
		// <param name="OptionalCurveReferenceName">Optional name for the curve associated with the index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateOvernightRateIndex(object IndexName, object Currency, object MarketConventions, object FixingReferencer, object OptionalFixingTableName, object OptionalCurveReferenceName)
		{

			Hashtable CreateOvernightRateIndex_args = new Hashtable();
			CreateOvernightRateIndex_args.Add("IndexName", IndexName);
			CreateOvernightRateIndex_args.Add("Currency", Currency);
			CreateOvernightRateIndex_args.Add("MarketConventions", MarketConventions);
			CreateOvernightRateIndex_args.Add("FixingReferencer", FixingReferencer);
			CreateOvernightRateIndex_args.Add("OptionalFixingTableName", OptionalFixingTableName);
			CreateOvernightRateIndex_args.Add("OptionalCurveReferenceName", OptionalCurveReferenceName);
			return F3Formatter.f3_style_serialization("CreateOvernightRateIndex", CreateOvernightRateIndex_args);
		}

		// <summary>
		// Create a single currency par yield curve cash settled interest rate swaption.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Expiry">Expiry date of the swaption.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">Notional for the swap.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Strike">Strike of the swaption.</param>
		// <param name="Payoff">Payer or receiver swaption.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="BuySell">Flag indicating buying or selling the swaption.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateParYieldCashSettledSwaption(object ProductName, object Expiry, object Maturity, object Notional, object Currency, object Strike, object Payoff, object FixedLegMarketConvention, object FloatingRateIndex, object BuySell,
		object FloatingLegMarketConvention)
		{

			Hashtable CreateParYieldCashSettledSwaption_args = new Hashtable();
			CreateParYieldCashSettledSwaption_args.Add("ProductName", ProductName);
			CreateParYieldCashSettledSwaption_args.Add("Expiry", Expiry);
			CreateParYieldCashSettledSwaption_args.Add("Maturity", Maturity);
			CreateParYieldCashSettledSwaption_args.Add("Notional", Notional);
			CreateParYieldCashSettledSwaption_args.Add("Currency", Currency);
			CreateParYieldCashSettledSwaption_args.Add("Strike", Strike);
			CreateParYieldCashSettledSwaption_args.Add("Payoff", Payoff);
			CreateParYieldCashSettledSwaption_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateParYieldCashSettledSwaption_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateParYieldCashSettledSwaption_args.Add("BuySell", BuySell);
			CreateParYieldCashSettledSwaption_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			return F3Formatter.f3_style_serialization("CreateParYieldCashSettledSwaption", CreateParYieldCashSettledSwaption_args);
		}

		// <summary>
		// Create an instrument type for par yield cash-settled swaptions.
		// </summary>
		// <param name="InstrumentTypeName">Name       of the instrument type.</param>
		// <param name="FixedLegMarketConventions">Market conventions for       the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <param name="Payoff">Payoff for the option. Default value: straddle.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateParYieldCashSettledSwaptionInstrumentType(object InstrumentTypeName, object FixedLegMarketConventions, object FloatingRateIndex, object FloatingLegMarketConventions, object Payoff)
		{

			Hashtable CreateParYieldCashSettledSwaptionInstrumentType_args = new Hashtable();
			CreateParYieldCashSettledSwaptionInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateParYieldCashSettledSwaptionInstrumentType_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateParYieldCashSettledSwaptionInstrumentType_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateParYieldCashSettledSwaptionInstrumentType_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			CreateParYieldCashSettledSwaptionInstrumentType_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateParYieldCashSettledSwaptionInstrumentType", CreateParYieldCashSettledSwaptionInstrumentType_args);
		}

		// <summary>
		// Create a market data set from a vector of numbers.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Values">Vector of values.</param>
		// <param name="ParameterName">Name to use for the parameter market data.</param>
		// <param name="ParameterType">Type to use for the parameter market data.</param>
		// <param name="ExposureLabels">Labels to use as the quote specifications in a risk report. Default value: default-constructed instance of type strings.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateParameterMarketData(object MarketDataSetName, object Values, object ParameterName, object ParameterType, object ExposureLabels)
		{

			Hashtable CreateParameterMarketData_args = new Hashtable();
			CreateParameterMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateParameterMarketData_args.Add("Values", Values);
			CreateParameterMarketData_args.Add("ParameterName", ParameterName);
			CreateParameterMarketData_args.Add("ParameterType", ParameterType);
			CreateParameterMarketData_args.Add("ExposureLabels", ExposureLabels);
			return F3Formatter.f3_style_serialization("CreateParameterMarketData", CreateParameterMarketData_args);
		}

		// <summary>
		// Create a parameter value modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="ParameterValues">Vector of parameter values.</param>
		// <param name="ParameterTag">Tag to use for the parameter values.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateParameterValueModifier(object ModifierName, object ParameterValues, object ParameterTag)
		{

			Hashtable CreateParameterValueModifier_args = new Hashtable();
			CreateParameterValueModifier_args.Add("ModifierName", ModifierName);
			CreateParameterValueModifier_args.Add("ParameterValues", ParameterValues);
			CreateParameterValueModifier_args.Add("ParameterTag", ParameterTag);
			return F3Formatter.f3_style_serialization("CreateParameterValueModifier", CreateParameterValueModifier_args);
		}

		// <summary>
		// Create an accumulator that returns paths.
		// </summary>
		// <param name="Name">Name to use for new accumulator.</param>
		// <param name="PathLimit">Maximum number of paths to store and return. Default value: 2500.</param>
		// <returns>Retuns the name of the constructed object of type AccumulatorSource.</returns>
		public object CreatePathAccumulator(object Name, object PathLimit)
		{

			Hashtable CreatePathAccumulator_args = new Hashtable();
			CreatePathAccumulator_args.Add("Name", Name);
			CreatePathAccumulator_args.Add("PathLimit", PathLimit);
			return F3Formatter.f3_style_serialization("CreatePathAccumulator", CreatePathAccumulator_args);
		}

		// <summary>
		// Create a valuation specification that provides a means of capturing per-iteration values during a simulation.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="PathAccumulator">Accumulator to collect samples from the distribution.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreatePathAccumulatorValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object PathAccumulator)
		{

			Hashtable CreatePathAccumulatorValuationSpecification_args = new Hashtable();
			CreatePathAccumulatorValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreatePathAccumulatorValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreatePathAccumulatorValuationSpecification_args.Add("PathAccumulator", PathAccumulator);
			return F3Formatter.f3_style_serialization("CreatePathAccumulatorValuationSpecification", CreatePathAccumulatorValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification for payoff replication using a portfolio of vanilla European options.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="ReplicationStrategies">Payoff replication strategies for different underlying indices.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreatePayoffReplicationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object ReplicationStrategies)
		{

			Hashtable CreatePayoffReplicationValuationSpecification_args = new Hashtable();
			CreatePayoffReplicationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreatePayoffReplicationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreatePayoffReplicationValuationSpecification_args.Add("ReplicationStrategies", ReplicationStrategies);
			return F3Formatter.f3_style_serialization("CreatePayoffReplicationValuationSpecification", CreatePayoffReplicationValuationSpecification_args);
		}

		// <summary>
		// Create a percentile function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="HistogramSource">Histogram source.</param>
		// <param name="Values">Values to bin.</param>
		// <param name="Weights">Weights of values. Default value: default-constructed instance of type vector.</param>
		// <param name="InterpolationMethod">Method for interpolating the binned values in the histogram. Default value: LinearWithLinearExtrapolation.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreatePercentileFunction(object FunctionName, object HistogramSource, object Values, object Weights, object InterpolationMethod)
		{

			Hashtable CreatePercentileFunction_args = new Hashtable();
			CreatePercentileFunction_args.Add("FunctionName", FunctionName);
			CreatePercentileFunction_args.Add("HistogramSource", HistogramSource);
			CreatePercentileFunction_args.Add("Values", Values);
			CreatePercentileFunction_args.Add("Weights", Weights);
			CreatePercentileFunction_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("CreatePercentileFunction", CreatePercentileFunction_args);
		}

		// <summary>
		// Define a futures contract type for a futures contract whose underlying is a swap.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">Principal notional of the underlying swap. Default value: 100000.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreatePhysicallyDeliverableSwapFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreatePhysicallyDeliverableSwapFuturesContractType_args = new Hashtable();
			CreatePhysicallyDeliverableSwapFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreatePhysicallyDeliverableSwapFuturesContractType_args.Add("ContractSize", ContractSize);
			CreatePhysicallyDeliverableSwapFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreatePhysicallyDeliverableSwapFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreatePhysicallyDeliverableSwapFuturesContractType", CreatePhysicallyDeliverableSwapFuturesContractType_args);
		}

		// <summary>
		// Create a modifier that picks values from an underlying generator.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Indices">Vector of indices into the underlying generator.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreatePickModifier(object ModifierName, object Indices)
		{

			Hashtable CreatePickModifier_args = new Hashtable();
			CreatePickModifier_args.Add("ModifierName", ModifierName);
			CreatePickModifier_args.Add("Indices", Indices);
			return F3Formatter.f3_style_serialization("CreatePickModifier", CreatePickModifier_args);
		}

		// <summary>
		// Create a Poisson distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="LambdaValue">Expected number of occurances in interval.</param>
		// <param name="LambdaParameterTag">Tag to use for the lambda value.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreatePoissonDistributionFunction(object FunctionName, object LambdaValue, object LambdaParameterTag)
		{

			Hashtable CreatePoissonDistributionFunction_args = new Hashtable();
			CreatePoissonDistributionFunction_args.Add("FunctionName", FunctionName);
			CreatePoissonDistributionFunction_args.Add("LambdaValue", LambdaValue);
			CreatePoissonDistributionFunction_args.Add("LambdaParameterTag", LambdaParameterTag);
			return F3Formatter.f3_style_serialization("CreatePoissonDistributionFunction", CreatePoissonDistributionFunction_args);
		}

		// <summary>
		// Create a polynomial of degree three or less.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Coefficients">Vector of coefficients.</param>
		// <param name="CoefficientsTag">Tag to use for the coefficients.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreatePolynomialOfDegreeThreeOrLessFunction(object FunctionName, object Coefficients, object CoefficientsTag)
		{

			Hashtable CreatePolynomialOfDegreeThreeOrLessFunction_args = new Hashtable();
			CreatePolynomialOfDegreeThreeOrLessFunction_args.Add("FunctionName", FunctionName);
			CreatePolynomialOfDegreeThreeOrLessFunction_args.Add("Coefficients", Coefficients);
			CreatePolynomialOfDegreeThreeOrLessFunction_args.Add("CoefficientsTag", CoefficientsTag);
			return F3Formatter.f3_style_serialization("CreatePolynomialOfDegreeThreeOrLessFunction", CreatePolynomialOfDegreeThreeOrLessFunction_args);
		}

		// <summary>
		// Create a trigger explanatory strategy consisting of a basis function set of nth order polynomials.
		// </summary>
		// <param name="StrategyName">Name to use for the trigger explanatory strategy.</param>
		// <param name="Order">Order of the polynomials.</param>
		// <returns>Retuns the name of the constructed object of type TriggerExplanatoryStrategy.</returns>
		public object CreatePolynomialTriggerExplanatoryStrategy(object StrategyName, object Order)
		{

			Hashtable CreatePolynomialTriggerExplanatoryStrategy_args = new Hashtable();
			CreatePolynomialTriggerExplanatoryStrategy_args.Add("StrategyName", StrategyName);
			CreatePolynomialTriggerExplanatoryStrategy_args.Add("Order", Order);
			return F3Formatter.f3_style_serialization("CreatePolynomialTriggerExplanatoryStrategy", CreatePolynomialTriggerExplanatoryStrategy_args);
		}

		// <summary>
		// Create a portfolio product from a set of underlying products.
		// </summary>
		// <param name="ProductName">Name to use for the created portfolio product.</param>
		// <param name="WeightedConstituents">Array of products for the portfolio, each with relative weight.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreatePortfolioProduct(object ProductName, object WeightedConstituents)
		{

			Hashtable CreatePortfolioProduct_args = new Hashtable();
			CreatePortfolioProduct_args.Add("ProductName", ProductName);
			CreatePortfolioProduct_args.Add("WeightedConstituents", WeightedConstituents);
			return F3Formatter.f3_style_serialization("CreatePortfolioProduct", CreatePortfolioProduct_args);
		}

		// <summary>
		// Create a valuation specification for portfolio replication.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="ReplicationMethod">Method to replicate an option portfolio.</param>
		// <param name="StrikeSpec">Strike of the CDS rate.</param>
		// <param name="StrikeSeparation">Separation in strike between options in the portfolio. Default value: 0.001.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreatePortfolioReplicationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object ReplicationMethod, object StrikeSpec, object StrikeSeparation)
		{

			Hashtable CreatePortfolioReplicationValuationSpecification_args = new Hashtable();
			CreatePortfolioReplicationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreatePortfolioReplicationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreatePortfolioReplicationValuationSpecification_args.Add("ReplicationMethod", ReplicationMethod);
			CreatePortfolioReplicationValuationSpecification_args.Add("StrikeSpec", StrikeSpec);
			CreatePortfolioReplicationValuationSpecification_args.Add("StrikeSeparation", StrikeSeparation);
			return F3Formatter.f3_style_serialization("CreatePortfolioReplicationValuationSpecification", CreatePortfolioReplicationValuationSpecification_args);
		}

		// <summary>
		// Create a smooth one-dimensional function that returns the positive part of its argument.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SmoothingParameter">The value of the smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreatePositivePartFunction(object FunctionName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable CreatePositivePartFunction_args = new Hashtable();
			CreatePositivePartFunction_args.Add("FunctionName", FunctionName);
			CreatePositivePartFunction_args.Add("SmoothingParameter", SmoothingParameter);
			CreatePositivePartFunction_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreatePositivePartFunction", CreatePositivePartFunction_args);
		}

		// <summary>
		// Create an analytic function that returns the maximum of zero and its argument,                                                             with smoothing around 0.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SmoothingParameter">Smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreatePositiveValueFunction(object FunctionName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable CreatePositiveValueFunction_args = new Hashtable();
			CreatePositiveValueFunction_args.Add("FunctionName", FunctionName);
			CreatePositiveValueFunction_args.Add("SmoothingParameter", SmoothingParameter);
			CreatePositiveValueFunction_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreatePositiveValueFunction", CreatePositiveValueFunction_args);
		}

		// <summary>
		// Create a modifier whose outputs are the maximum of zero or the underlying value.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="InterpolationBounds">Distance from the origin to use for interpolation of the positive value.</param>
		// <param name="BoundsParameterTag">Tag to use for interpolation bounds parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreatePositiveValueModifier(object ModifierName, object InterpolationBounds, object BoundsParameterTag)
		{

			Hashtable CreatePositiveValueModifier_args = new Hashtable();
			CreatePositiveValueModifier_args.Add("ModifierName", ModifierName);
			CreatePositiveValueModifier_args.Add("InterpolationBounds", InterpolationBounds);
			CreatePositiveValueModifier_args.Add("BoundsParameterTag", BoundsParameterTag);
			return F3Formatter.f3_style_serialization("CreatePositiveValueModifier", CreatePositiveValueModifier_args);
		}

		// <summary>
		// Create a preceding (PREC) or modified preceding (MOD PREC) date modifier.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="UnderlyingDM">An underlying date modifier that will be applied before PREC or MOD PREC.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		// <param name="AllowMonthChange">Set this flag to false to get MOD PREC modifier. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreatePrecedingDateModifier(object DateModifierName, object UnderlyingDM, object HolidayConventions, object AllowMonthChange)
		{

			Hashtable CreatePrecedingDateModifier_args = new Hashtable();
			CreatePrecedingDateModifier_args.Add("DateModifierName", DateModifierName);
			CreatePrecedingDateModifier_args.Add("UnderlyingDM", UnderlyingDM);
			CreatePrecedingDateModifier_args.Add("HolidayConventions", HolidayConventions);
			CreatePrecedingDateModifier_args.Add("AllowMonthChange", AllowMonthChange);
			return F3Formatter.f3_style_serialization("CreatePrecedingDateModifier", CreatePrecedingDateModifier_args);
		}

		// <summary>
		// Create a method for the decomposition of a matrix into principal components.
		// </summary>
		// <param name="MethodName">Name to use for the matrix decomposition method.</param>
		// <param name="NumberOfReducedComponents">Maximal Number of principal components.</param>
		// <param name="Tolerance">Tolerance of eigenvalues to be kept in the principal components.</param>
		// <returns>Retuns the name of the constructed object of type MatrixDecomposition.</returns>
		public object CreatePrincipalComponentDecomposition(object MethodName, object NumberOfReducedComponents, object Tolerance)
		{

			Hashtable CreatePrincipalComponentDecomposition_args = new Hashtable();
			CreatePrincipalComponentDecomposition_args.Add("MethodName", MethodName);
			CreatePrincipalComponentDecomposition_args.Add("NumberOfReducedComponents", NumberOfReducedComponents);
			CreatePrincipalComponentDecomposition_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("CreatePrincipalComponentDecomposition", CreatePrincipalComponentDecomposition_args);
		}

		// <summary>
		// Create a product from a FITR specification.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="FITRSpecification">Input file, or other stream-based resource, containing FITR representation of product.</param>
		// <param name="Notionals">The notional structure for the product.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the product.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateProductFromFITR(object ProductName, object FITRSpecification, object Notionals, object PayRec)
		{

			Hashtable CreateProductFromFITR_args = new Hashtable();
			CreateProductFromFITR_args.Add("ProductName", ProductName);
			CreateProductFromFITR_args.Add("FITRSpecification", FITRSpecification);
			CreateProductFromFITR_args.Add("Notionals", Notionals);
			CreateProductFromFITR_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateProductFromFITR", CreateProductFromFITR_args);
		}

		// <summary>
		// Create a product from a FITR specification in text form.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="FITRSpecification">FITR representation of product, as a string or array of strings.</param>
		// <param name="Notionals">The notional structure for the product.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the product.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateProductFromFITRText(object ProductName, object FITRSpecification, object Notionals, object PayRec)
		{

			Hashtable CreateProductFromFITRText_args = new Hashtable();
			CreateProductFromFITRText_args.Add("ProductName", ProductName);
			CreateProductFromFITRText_args.Add("FITRSpecification", FITRSpecification);
			CreateProductFromFITRText_args.Add("Notionals", Notionals);
			CreateProductFromFITRText_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateProductFromFITRText", CreateProductFromFITRText_args);
		}

		// <summary>
		// Create a two-dimensional function as the product of two one-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="XFunction">One-dimensional function for the first variable.</param>
		// <param name="YFunction">One-dimensional function for the second variable.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateProductFunctionSurface(object FunctionName, object XFunction, object YFunction)
		{

			Hashtable CreateProductFunctionSurface_args = new Hashtable();
			CreateProductFunctionSurface_args.Add("FunctionName", FunctionName);
			CreateProductFunctionSurface_args.Add("XFunction", XFunction);
			CreateProductFunctionSurface_args.Add("YFunction", YFunction);
			return F3Formatter.f3_style_serialization("CreateProductFunctionSurface", CreateProductFunctionSurface_args);
		}

		// <summary>
		// Create a two-dimensional function as the product of a one-dimensional function by a two-dimensional function, holding one argument constant.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="OneDimFunction">One-dimensional function.</param>
		// <param name="TwoDimFunction">Two-dimensional function.</param>
		// <param name="UseFirstArg">Switch to indicate whether or not the first argument of the two-dimensional function is the same as the argument of the one-dimensional function.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction(object FunctionName, object OneDimFunction, object TwoDimFunction, object UseFirstArg)
		{

			Hashtable CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args = new Hashtable();
			CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args.Add("FunctionName", FunctionName);
			CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args.Add("OneDimFunction", OneDimFunction);
			CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args.Add("TwoDimFunction", TwoDimFunction);
			CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args.Add("UseFirstArg", UseFirstArg);
			return F3Formatter.f3_style_serialization("CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction", CreateProductFunctionSurfaceFromOneDimFunctionByTwoDimFunction_args);
		}

		// <summary>
		// Create an index whose value is the product of underlying indices.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="ConstituentIndices">Vector of indices.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateProductIndex(object IndexName, object ConstituentIndices)
		{

			Hashtable CreateProductIndex_args = new Hashtable();
			CreateProductIndex_args.Add("IndexName", IndexName);
			CreateProductIndex_args.Add("ConstituentIndices", ConstituentIndices);
			return F3Formatter.f3_style_serialization("CreateProductIndex", CreateProductIndex_args);
		}

		// <summary>
		// Create an instrument strategy based on pre-built products.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="Products">Collection of pre-built products.</param>
		// <param name="ExposureTagName">Name-part of the tag labeling exposure to the (perhaps intrinsic) quote for the product. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="ExposureTagType">Type-part of the tag labeling exposure to the (perhaps intrinsic) quote for the product. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="QuoteSpecs">Collection of descriptions of the quote. Default value: default-constructed instance of type quote_specifications.</param>
		// <param name="ExposureIndices">Indices to be assigned to the supplied products in cases where exposure name and type are not unique to these products. Default value: default-constructed instance of type unsigned_small_integers.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateProductInstrumentStrategy(object StrategyName, object Products, object ExposureTagName, object ExposureTagType, object QuoteSpecs, object ExposureIndices)
		{

			Hashtable CreateProductInstrumentStrategy_args = new Hashtable();
			CreateProductInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateProductInstrumentStrategy_args.Add("Products", Products);
			CreateProductInstrumentStrategy_args.Add("ExposureTagName", ExposureTagName);
			CreateProductInstrumentStrategy_args.Add("ExposureTagType", ExposureTagType);
			CreateProductInstrumentStrategy_args.Add("QuoteSpecs", QuoteSpecs);
			CreateProductInstrumentStrategy_args.Add("ExposureIndices", ExposureIndices);
			return F3Formatter.f3_style_serialization("CreateProductInstrumentStrategy", CreateProductInstrumentStrategy_args);
		}

		// <summary>
		// Create a generator that returns the results of product valuation given a scenario generator.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="BaseModel">Base model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ScenarioGenerator">Scenario generator.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreateProductValueGenerator(object GeneratorName, object BaseModel, object Product, object ValuationMethod, object ScenarioGenerator)
		{

			Hashtable CreateProductValueGenerator_args = new Hashtable();
			CreateProductValueGenerator_args.Add("GeneratorName", GeneratorName);
			CreateProductValueGenerator_args.Add("BaseModel", BaseModel);
			CreateProductValueGenerator_args.Add("Product", Product);
			CreateProductValueGenerator_args.Add("ValuationMethod", ValuationMethod);
			CreateProductValueGenerator_args.Add("ScenarioGenerator", ScenarioGenerator);
			return F3Formatter.f3_style_serialization("CreateProductValueGenerator", CreateProductValueGenerator_args);
		}

		// <summary>
		// Create a new model by applying a profit-and-loss attribution operation to a source model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="Operation">Profit-and-loss operation to apply.</param>
		// <param name="LeftModel">Base model to which the profit-and-loss operation is applied.</param>
		// <param name="RightModel">Model that holds the information relevant to the profit-and-loss operation being applied.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object CreateProfitLossModel(object ModelName, object Operation, object LeftModel, object RightModel)
		{

			Hashtable CreateProfitLossModel_args = new Hashtable();
			CreateProfitLossModel_args.Add("ModelName", ModelName);
			CreateProfitLossModel_args.Add("Operation", Operation);
			CreateProfitLossModel_args.Add("LeftModel", LeftModel);
			CreateProfitLossModel_args.Add("RightModel", RightModel);
			return F3Formatter.f3_style_serialization("CreateProfitLossModel", CreateProfitLossModel_args);
		}

		// <summary>
		// Create a new product by applying a profit-and-loss attribution operation to a source product.
		// </summary>
		// <param name="ProductName">Name to use for the new product.</param>
		// <param name="Operation">Profit-and-loss operation to apply.</param>
		// <param name="LeftProduct">Base product to which the profit-and-loss operation is applied.</param>
		// <param name="RightProduct">Product that holds the information relevant to the profit-and-loss operation being applied.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateProfitLossProduct(object ProductName, object Operation, object LeftProduct, object RightProduct)
		{

			Hashtable CreateProfitLossProduct_args = new Hashtable();
			CreateProfitLossProduct_args.Add("ProductName", ProductName);
			CreateProfitLossProduct_args.Add("Operation", Operation);
			CreateProfitLossProduct_args.Add("LeftProduct", LeftProduct);
			CreateProfitLossProduct_args.Add("RightProduct", RightProduct);
			return F3Formatter.f3_style_serialization("CreateProfitLossProduct", CreateProfitLossProduct_args);
		}

		// <summary>
		// Create a new valuation specification by applying a profit-and-loss attribution operation to a source valuation specification.
		// </summary>
		// <param name="ValSpecName">Name to use for the new valuation specification.</param>
		// <param name="Operation">Profit-and-loss operation to apply.</param>
		// <param name="LeftValSpec">Base valuation specification to which the profit-and-loss operation is applied.</param>
		// <param name="RightValSpec">Valuation specification that holds the information relevant to the profit-and-loss operation being applied.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateProfitLossValuationSpecification(object ValSpecName, object Operation, object LeftValSpec, object RightValSpec)
		{

			Hashtable CreateProfitLossValuationSpecification_args = new Hashtable();
			CreateProfitLossValuationSpecification_args.Add("ValSpecName", ValSpecName);
			CreateProfitLossValuationSpecification_args.Add("Operation", Operation);
			CreateProfitLossValuationSpecification_args.Add("LeftValSpec", LeftValSpec);
			CreateProfitLossValuationSpecification_args.Add("RightValSpec", RightValSpec);
			return F3Formatter.f3_style_serialization("CreateProfitLossValuationSpecification", CreateProfitLossValuationSpecification_args);
		}

		// <summary>
		// Create a Sobol generator given a specific seed for dimensions greater than 40.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="Seed">Initial seed to use for generator.</param>
		// <returns>Retuns the name of the constructed object of type GeneratorSource.</returns>
		public object CreatePseudoRandomlyExtendedSobolGenerator(object GeneratorName, object Seed)
		{

			Hashtable CreatePseudoRandomlyExtendedSobolGenerator_args = new Hashtable();
			CreatePseudoRandomlyExtendedSobolGenerator_args.Add("GeneratorName", GeneratorName);
			CreatePseudoRandomlyExtendedSobolGenerator_args.Add("Seed", Seed);
			return F3Formatter.f3_style_serialization("CreatePseudoRandomlyExtendedSobolGenerator", CreatePseudoRandomlyExtendedSobolGenerator_args);
		}

		// <summary>
		// Create a two-dimensional volatility surface using a quadratic function at each point in time.
		// </summary>
		// <param name="Function">Name to use for the function.</param>
		// <param name="Delta50VolCurve">One-dimensional function specifying volatility at a delta of 50 as a function of time.</param>
		// <param name="SkewCurve">One-dimensional function specifying volatility skew as a function of time.</param>
		// <param name="ConvexityCurve">One-dimensional function specifying volatility convexity as a function of time.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateQuadraticVolatilitySurfaceFunction(object Function_name, object Delta50VolCurve, object SkewCurve, object ConvexityCurve)
		{

			Hashtable CreateQuadraticVolatilitySurfaceFunction_args = new Hashtable();
			CreateQuadraticVolatilitySurfaceFunction_args.Add("Function", Function_name);
			CreateQuadraticVolatilitySurfaceFunction_args.Add("Delta50VolCurve", Delta50VolCurve);
			CreateQuadraticVolatilitySurfaceFunction_args.Add("SkewCurve", SkewCurve);
			CreateQuadraticVolatilitySurfaceFunction_args.Add("ConvexityCurve", ConvexityCurve);
			return F3Formatter.f3_style_serialization("CreateQuadraticVolatilitySurfaceFunction", CreateQuadraticVolatilitySurfaceFunction_args);
		}

		// <summary>
		// Create a market data set containing quarterly index fixings.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="QuarterValueName">Name of fixing market data.</param>
		// <param name="QuarterValueType">Type of fixing market data.</param>
		// <param name="QuarterlyFixings">Quarterly fixing data.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateQuarterlyFixingsMarketData(object MarketDataSetName, object QuarterValueName, object QuarterValueType, object QuarterlyFixings)
		{

			Hashtable CreateQuarterlyFixingsMarketData_args = new Hashtable();
			CreateQuarterlyFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateQuarterlyFixingsMarketData_args.Add("QuarterValueName", QuarterValueName);
			CreateQuarterlyFixingsMarketData_args.Add("QuarterValueType", QuarterValueType);
			CreateQuarterlyFixingsMarketData_args.Add("QuarterlyFixings", QuarterlyFixings);
			return F3Formatter.f3_style_serialization("CreateQuarterlyFixingsMarketData", CreateQuarterlyFixingsMarketData_args);
		}

		// <summary>
		// Create a market data set containing quarterly fixings information for a specified index.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="QuarterlyFixings">Quarterly fixing data to store within market data set.</param>
		// <param name="FixingsIndex">The index for which fixings will be provided.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateQuarterlyIndexFixingsMarketData(object MarketDataSetName, object QuarterlyFixings, object FixingsIndex)
		{

			Hashtable CreateQuarterlyIndexFixingsMarketData_args = new Hashtable();
			CreateQuarterlyIndexFixingsMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateQuarterlyIndexFixingsMarketData_args.Add("QuarterlyFixings", QuarterlyFixings);
			CreateQuarterlyIndexFixingsMarketData_args.Add("FixingsIndex", FixingsIndex);
			return F3Formatter.f3_style_serialization("CreateQuarterlyIndexFixingsMarketData", CreateQuarterlyIndexFixingsMarketData_args);
		}

		// <summary>
		// Create an index which is lagged by a certain number of quarters..
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Name of the underlying index.</param>
		// <param name="LagInQuarters">Number of quarters to look back.</param>
		// <param name="HolidayConvention">Holiday convention for date adjustment. Default value: NoHolidays.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateQuarterlyLaggedIndex(object IndexName, object UnderlyingIndex, object LagInQuarters, object HolidayConvention)
		{

			Hashtable CreateQuarterlyLaggedIndex_args = new Hashtable();
			CreateQuarterlyLaggedIndex_args.Add("IndexName", IndexName);
			CreateQuarterlyLaggedIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateQuarterlyLaggedIndex_args.Add("LagInQuarters", LagInQuarters);
			CreateQuarterlyLaggedIndex_args.Add("HolidayConvention", HolidayConvention);
			return F3Formatter.f3_style_serialization("CreateQuarterlyLaggedIndex", CreateQuarterlyLaggedIndex_args);
		}

		// <summary>
		// Create an inflation index.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="SettlementConventions">Market conventions for transaction settlement.</param>
		// <param name="Referencer">Index referencer. Default value: MonthEndEndDate.</param>
		// <param name="OptionalCurveReferenceName">Optional name for the curve associated with the index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateRPIInflationIndex(object IndexName, object Currency, object SettlementConventions, object Referencer, object OptionalCurveReferenceName)
		{

			Hashtable CreateRPIInflationIndex_args = new Hashtable();
			CreateRPIInflationIndex_args.Add("IndexName", IndexName);
			CreateRPIInflationIndex_args.Add("Currency", Currency);
			CreateRPIInflationIndex_args.Add("SettlementConventions", SettlementConventions);
			CreateRPIInflationIndex_args.Add("Referencer", Referencer);
			CreateRPIInflationIndex_args.Add("OptionalCurveReferenceName", OptionalCurveReferenceName);
			return F3Formatter.f3_style_serialization("CreateRPIInflationIndex", CreateRPIInflationIndex_args);
		}

		// <summary>
		// Create an instrument strategy from a range of quote specifications.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="MarketDataTag">Tag for the market data.</param>
		// <param name="From">Start of instrument range. Default value: default-constructed instance of type quote_specification.</param>
		// <param name="To_">End of instrument range. Default value: default-constructed instance of type quote_specification.</param>
		// <param name="QuoteSpecOrdering">Quote ordering source. Default value: SingleMaturity.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateRangeInstrumentStrategy(object StrategyName, object MarketDataTag, object From, object To_, object QuoteSpecOrdering)
		{

			Hashtable CreateRangeInstrumentStrategy_args = new Hashtable();
			CreateRangeInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateRangeInstrumentStrategy_args.Add("MarketDataTag", MarketDataTag);
			CreateRangeInstrumentStrategy_args.Add("From", From);
			CreateRangeInstrumentStrategy_args.Add("To", To_);
			CreateRangeInstrumentStrategy_args.Add("QuoteSpecOrdering", QuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("CreateRangeInstrumentStrategy", CreateRangeInstrumentStrategy_args);
		}

		// <summary>
		// Create a single currency interest rate basis swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the basis swap.</param>
		// <param name="Maturity">Basis swap maturity.</param>
		// <param name="Notional">Notional structure.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Margin">Margin over the floating rate for each margin leg payment.</param>
		// <param name="MarginFloatingRateIndex">Index describing the floating rate for the margin leg.</param>
		// <param name="OpposingFloatingRateIndex">Index describing the floating rate for the opposing leg.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the margin leg.</param>
		// <param name="MarginLegMarketConventions">Market conventions for the margin leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="OpposingLegMarketConventions">Market conventions for the opposing leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateRateBasisSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object Margin, object MarginFloatingRateIndex, object OpposingFloatingRateIndex, object PayRec, object MarginLegMarketConventions,
		object OpposingLegMarketConventions)
		{

			Hashtable CreateRateBasisSwap_args = new Hashtable();
			CreateRateBasisSwap_args.Add("ProductName", ProductName);
			CreateRateBasisSwap_args.Add("StartDate", StartDate);
			CreateRateBasisSwap_args.Add("Maturity", Maturity);
			CreateRateBasisSwap_args.Add("Notional", Notional);
			CreateRateBasisSwap_args.Add("Currency", Currency);
			CreateRateBasisSwap_args.Add("Margin", Margin);
			CreateRateBasisSwap_args.Add("MarginFloatingRateIndex", MarginFloatingRateIndex);
			CreateRateBasisSwap_args.Add("OpposingFloatingRateIndex", OpposingFloatingRateIndex);
			CreateRateBasisSwap_args.Add("PayRec", PayRec);
			CreateRateBasisSwap_args.Add("MarginLegMarketConventions", MarginLegMarketConventions);
			CreateRateBasisSwap_args.Add("OpposingLegMarketConventions", OpposingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateRateBasisSwap", CreateRateBasisSwap_args);
		}

		// <summary>
		// Create an instrument type for a rate basis swap.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="SettlementMarketConventions">Settlement market conventions.</param>
		// <param name="MarginFloatingIndex">Floating rate index of the margin leg.</param>
		// <param name="OpposingFloatingIndex">Floating rate index of the opposing leg.</param>
		// <param name="MarginLegMarketConventions">Market conventions for the margin leg.</param>
		// <param name="OpposingLegMarketConventions">Market conventions for the opposing leg.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateRateBasisSwapInstrumentType(object InstrumentTypeName, object SettlementMarketConventions, object MarginFloatingIndex, object OpposingFloatingIndex, object MarginLegMarketConventions, object OpposingLegMarketConventions)
		{

			Hashtable CreateRateBasisSwapInstrumentType_args = new Hashtable();
			CreateRateBasisSwapInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateRateBasisSwapInstrumentType_args.Add("SettlementMarketConventions", SettlementMarketConventions);
			CreateRateBasisSwapInstrumentType_args.Add("MarginFloatingIndex", MarginFloatingIndex);
			CreateRateBasisSwapInstrumentType_args.Add("OpposingFloatingIndex", OpposingFloatingIndex);
			CreateRateBasisSwapInstrumentType_args.Add("MarginLegMarketConventions", MarginLegMarketConventions);
			CreateRateBasisSwapInstrumentType_args.Add("OpposingLegMarketConventions", OpposingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateRateBasisSwapInstrumentType", CreateRateBasisSwapInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of rate basis swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="BasisSpreads">Vector of basis spreads.</param>
		// <param name="Currency">Currency of swaps.</param>
		// <param name="BasisSwapName">Name of basis swap market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="BasisSwapType">Type of basis swap market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="SettlementMarketConventions">Settlement market conventions.</param>
		// <param name="MarginFloatingIndex">Floating rate index of the margin leg.</param>
		// <param name="OpposingFloatingIndex">Floating rate index of the opposing leg.</param>
		// <param name="MarginLegMarketConventions">Market conventions for margin leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="OpposingLegMarketConventions">Market conventions for opposing leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateRateBasisSwapMarketData(object MarketDataSetName, object Maturities, object BasisSpreads, object Currency, object BasisSwapName, object BasisSwapType, object SettlementMarketConventions, object MarginFloatingIndex, object OpposingFloatingIndex, object MarginLegMarketConventions,
		object OpposingLegMarketConventions)
		{

			Hashtable CreateRateBasisSwapMarketData_args = new Hashtable();
			CreateRateBasisSwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateRateBasisSwapMarketData_args.Add("Maturities", Maturities);
			CreateRateBasisSwapMarketData_args.Add("BasisSpreads", BasisSpreads);
			CreateRateBasisSwapMarketData_args.Add("Currency", Currency);
			CreateRateBasisSwapMarketData_args.Add("BasisSwapName", BasisSwapName);
			CreateRateBasisSwapMarketData_args.Add("BasisSwapType", BasisSwapType);
			CreateRateBasisSwapMarketData_args.Add("SettlementMarketConventions", SettlementMarketConventions);
			CreateRateBasisSwapMarketData_args.Add("MarginFloatingIndex", MarginFloatingIndex);
			CreateRateBasisSwapMarketData_args.Add("OpposingFloatingIndex", OpposingFloatingIndex);
			CreateRateBasisSwapMarketData_args.Add("MarginLegMarketConventions", MarginLegMarketConventions);
			CreateRateBasisSwapMarketData_args.Add("OpposingLegMarketConventions", OpposingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateRateBasisSwapMarketData", CreateRateBasisSwapMarketData_args);
		}

		// <summary>
		// Create a ratio accrual convention.
		// </summary>
		// <param name="AccrualConventionName">Name to use for the Accrual Convention.</param>
		// <param name="DayCountType">Day count convention to use.</param>
		// <param name="RequireSettlementDateInPeriod">If true and the settlement date is not in the period, the accrual fraction is zero. Default value: true.</param>
		// <param name="RequireTradeDateInPeriod">If true and the trade date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="EndOnSettlementNotTrade">If true accrue to the settlement date, otherwise to the trade date. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type AccrualConvention.</returns>
		public object CreateRatioAccrualConvention(object AccrualConventionName, object DayCountType, object RequireSettlementDateInPeriod, object RequireTradeDateInPeriod, object EndOnSettlementNotTrade)
		{

			Hashtable CreateRatioAccrualConvention_args = new Hashtable();
			CreateRatioAccrualConvention_args.Add("AccrualConventionName", AccrualConventionName);
			CreateRatioAccrualConvention_args.Add("DayCountType", DayCountType);
			CreateRatioAccrualConvention_args.Add("RequireSettlementDateInPeriod", RequireSettlementDateInPeriod);
			CreateRatioAccrualConvention_args.Add("RequireTradeDateInPeriod", RequireTradeDateInPeriod);
			CreateRatioAccrualConvention_args.Add("EndOnSettlementNotTrade", EndOnSettlementNotTrade);
			return F3Formatter.f3_style_serialization("CreateRatioAccrualConvention", CreateRatioAccrualConvention_args);
		}

		// <summary>
		// Create an index whose value is the ratio of two underlying indices.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Numerator">Numerator index.</param>
		// <param name="Denominator">Denominator index.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateRatioIndex(object IndexName, object Numerator, object Denominator)
		{

			Hashtable CreateRatioIndex_args = new Hashtable();
			CreateRatioIndex_args.Add("IndexName", IndexName);
			CreateRatioIndex_args.Add("Numerator", Numerator);
			CreateRatioIndex_args.Add("Denominator", Denominator);
			return F3Formatter.f3_style_serialization("CreateRatioIndex", CreateRatioIndex_args);
		}

		// <summary>
		// Create a ratio yield accrual convention.
		// </summary>
		// <param name="AccrualConventionName">Name to use for the Accrual Convention.</param>
		// <param name="DayCountType">Day Count convention to use.</param>
		// <param name="RequireSettlementDateInPeriod">If true and the settlement date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="RequireTradeDateInPeriod">If true and the trade date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="EndOnSettlementNotTrade">If true accrue to the settlement date, otherwise to the trade date. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type AccrualConvention.</returns>
		public object CreateRatioYieldAccrualConvention(object AccrualConventionName, object DayCountType, object RequireSettlementDateInPeriod, object RequireTradeDateInPeriod, object EndOnSettlementNotTrade)
		{

			Hashtable CreateRatioYieldAccrualConvention_args = new Hashtable();
			CreateRatioYieldAccrualConvention_args.Add("AccrualConventionName", AccrualConventionName);
			CreateRatioYieldAccrualConvention_args.Add("DayCountType", DayCountType);
			CreateRatioYieldAccrualConvention_args.Add("RequireSettlementDateInPeriod", RequireSettlementDateInPeriod);
			CreateRatioYieldAccrualConvention_args.Add("RequireTradeDateInPeriod", RequireTradeDateInPeriod);
			CreateRatioYieldAccrualConvention_args.Add("EndOnSettlementNotTrade", EndOnSettlementNotTrade);
			return F3Formatter.f3_style_serialization("CreateRatioYieldAccrualConvention", CreateRatioYieldAccrualConvention_args);
		}

		// <summary>
		// Form an index that represents a realized variance index on another underlying index.
		// </summary>
		// <param name="IndexName">Name to use for index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="ObservationConventions">Market conventions of realized variance observation dates.</param>
		// <param name="MeanAdjusted">True if the variance is mean-adjusted. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateRealisedVarianceIndex(object IndexName, object UnderlyingIndex, object ObservationConventions, object MeanAdjusted)
		{

			Hashtable CreateRealisedVarianceIndex_args = new Hashtable();
			CreateRealisedVarianceIndex_args.Add("IndexName", IndexName);
			CreateRealisedVarianceIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateRealisedVarianceIndex_args.Add("ObservationConventions", ObservationConventions);
			CreateRealisedVarianceIndex_args.Add("MeanAdjusted", MeanAdjusted);
			return F3Formatter.f3_style_serialization("CreateRealisedVarianceIndex", CreateRealisedVarianceIndex_args);
		}

		// <summary>
		// Create a regression product modifier that handles multiple data sets.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="NumberOfYDatasets">Number of Y datasets in the regression.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateRegressionProductForMultipleDatasetsModifier(object ModifierName, object NumberOfYDatasets)
		{

			Hashtable CreateRegressionProductForMultipleDatasetsModifier_args = new Hashtable();
			CreateRegressionProductForMultipleDatasetsModifier_args.Add("ModifierName", ModifierName);
			CreateRegressionProductForMultipleDatasetsModifier_args.Add("NumberOfYDatasets", NumberOfYDatasets);
			return F3Formatter.f3_style_serialization("CreateRegressionProductForMultipleDatasetsModifier", CreateRegressionProductForMultipleDatasetsModifier_args);
		}

		// <summary>
		// Create a time-major state variable ordering where the number of factors is time dependent.
		// </summary>
		// <param name="OrderingName">Name to use for the ordering.</param>
		// <param name="NumberOfFactors">Number of factors at each time point.</param>
		// <returns>Retuns the name of the constructed object of type StateVariableOrdering.</returns>
		public object CreateRemainingRatesStateVariableOrdering(object OrderingName, object NumberOfFactors)
		{

			Hashtable CreateRemainingRatesStateVariableOrdering_args = new Hashtable();
			CreateRemainingRatesStateVariableOrdering_args.Add("OrderingName", OrderingName);
			CreateRemainingRatesStateVariableOrdering_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateRemainingRatesStateVariableOrdering", CreateRemainingRatesStateVariableOrdering_args);
		}

		// <summary>
		// Create a valuation specification that controls the use of remote workers and a cache.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="ReadMode">Permit checking of cache, or a local cache only, for precalculated values. Default value: Full.</param>
		// <param name="SaveResults">TRUE to indicate if valuation results should be cached once calculated. Default value: true.</param>
		// <param name="AllowLocalCalculation">TRUE to indicate if a local valuation should be performed for results not in the cache. Default value: true.</param>
		// <param name="AsynchronousValuation">TRUE to allow valuations to proceed and complete asynchronously. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateRemoteCachedValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object ReadMode, object SaveResults, object AllowLocalCalculation, object AsynchronousValuation)
		{

			Hashtable CreateRemoteCachedValuationSpecification_args = new Hashtable();
			CreateRemoteCachedValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateRemoteCachedValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateRemoteCachedValuationSpecification_args.Add("ReadMode", ReadMode);
			CreateRemoteCachedValuationSpecification_args.Add("SaveResults", SaveResults);
			CreateRemoteCachedValuationSpecification_args.Add("AllowLocalCalculation", AllowLocalCalculation);
			CreateRemoteCachedValuationSpecification_args.Add("AsynchronousValuation", AsynchronousValuation);
			return F3Formatter.f3_style_serialization("CreateRemoteCachedValuationSpecification", CreateRemoteCachedValuationSpecification_args);
		}

		// <summary>
		// Create a cache processor that uses a network call to an external F3 instance.
		// </summary>
		// <param name="CacheProcessorName">Name to use for cache processor.</param>
		// <param name="Connection">External F3 connection.</param>
		// <returns>Retuns the name of the constructed object of type CacheProcessor.</returns>
		public object CreateRemoteF3CacheProcessor(object CacheProcessorName, object Connection)
		{

			Hashtable CreateRemoteF3CacheProcessor_args = new Hashtable();
			CreateRemoteF3CacheProcessor_args.Add("CacheProcessorName", CacheProcessorName);
			CreateRemoteF3CacheProcessor_args.Add("Connection", Connection);
			return F3Formatter.f3_style_serialization("CreateRemoteF3CacheProcessor", CreateRemoteF3CacheProcessor_args);
		}

		// <summary>
		// Create a valuation specification builder capable of replacing the root underlying in a given valuation specification.
		// </summary>
		// <param name="BuilderName">Name to use for the valuation specification builder.</param>
		// <param name="ValuationMethod">Target valuation specification.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecificationBuilder.</returns>
		public object CreateReplacedUnderlyingValuationSpecificationBuilder(object BuilderName, object ValuationMethod)
		{

			Hashtable CreateReplacedUnderlyingValuationSpecificationBuilder_args = new Hashtable();
			CreateReplacedUnderlyingValuationSpecificationBuilder_args.Add("BuilderName", BuilderName);
			CreateReplacedUnderlyingValuationSpecificationBuilder_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("CreateReplacedUnderlyingValuationSpecificationBuilder", CreateReplacedUnderlyingValuationSpecificationBuilder_args);
		}

		// <summary>
		// Create a one-dimensional function from a set of replicating weights.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ReplicatingWeights">Replicating weights and associated options.</param>
		// <param name="NumerarireFunction">Optional option payoff weighting function. Default value: 1.0.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateReplicatingFunction(object FunctionName, object ReplicatingWeights, object NumerarireFunction)
		{

			Hashtable CreateReplicatingFunction_args = new Hashtable();
			CreateReplicatingFunction_args.Add("FunctionName", FunctionName);
			CreateReplicatingFunction_args.Add("ReplicatingWeights", ReplicatingWeights);
			CreateReplicatingFunction_args.Add("NumerarireFunction", NumerarireFunction);
			return F3Formatter.f3_style_serialization("CreateReplicatingFunction", CreateReplicatingFunction_args);
		}

		// <summary>
		// Create a model from an existing model that reprojects risks from a set of original instruments                                                            to a set of new instruments.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="OriginalInstruments">The instruments used to build the original model that are to be replaced by new instruments in the risk report.</param>
		// <param name="NewInstruments">The instruments that will replace the original instruments in the risk report.</param>
		// <param name="MarketDataName">Name part of market data tags to identify new instruments in risk report. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type part of market data tags to identify new instruments in risk report. Default value: default-constructed instance of type marketdata_type.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object CreateReprojectedRiskModel(object ModelName, object BaseModel, object OriginalInstruments, object NewInstruments, object MarketDataName, object MarketDataType)
		{

			Hashtable CreateReprojectedRiskModel_args = new Hashtable();
			CreateReprojectedRiskModel_args.Add("ModelName", ModelName);
			CreateReprojectedRiskModel_args.Add("BaseModel", BaseModel);
			CreateReprojectedRiskModel_args.Add("OriginalInstruments", OriginalInstruments);
			CreateReprojectedRiskModel_args.Add("NewInstruments", NewInstruments);
			CreateReprojectedRiskModel_args.Add("MarketDataName", MarketDataName);
			CreateReprojectedRiskModel_args.Add("MarketDataType", MarketDataType);
			return F3Formatter.f3_style_serialization("CreateReprojectedRiskModel", CreateReprojectedRiskModel_args);
		}

		// <summary>
		// Create a product with all flows weighted by an index.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="Underlying">Name to use for the underlying product.</param>
		// <param name="WeightIndex">Index to use as weight.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateReweightedFlowsProduct(object ProductName, object Underlying, object WeightIndex)
		{

			Hashtable CreateReweightedFlowsProduct_args = new Hashtable();
			CreateReweightedFlowsProduct_args.Add("ProductName", ProductName);
			CreateReweightedFlowsProduct_args.Add("Underlying", Underlying);
			CreateReweightedFlowsProduct_args.Add("WeightIndex", WeightIndex);
			return F3Formatter.f3_style_serialization("CreateReweightedFlowsProduct", CreateReweightedFlowsProduct_args);
		}

		// <summary>
		// Create a market data set containing a set of quotes for risk reversal option strategies at different maturities and delta strikes.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of option expiries.</param>
		// <param name="Deltas">Vector of option delta strikes.</param>
		// <param name="StrategyQuotes">Vector of option strategy quotes.</param>
		// <param name="DataName">Name of market data.</param>
		// <param name="DataType">Type of market data.</param>
		// <param name="UnderlyingIndex">Index describing the option's underlying.</param>
		// <param name="DeltaConvention">Market convention for the delta-based option strike. Default value: ForwardRawDelta.</param>
		// <param name="QuoteDate">Date on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <param name="RiskReversalType">Type of the risk reversal in the option strategy. Default value: Smile.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateRiskReversalMarketData(object MarketDataSetName, object Expiries, object Deltas, object StrategyQuotes, object DataName, object DataType, object UnderlyingIndex, object DeltaConvention, object QuoteDate, object RiskReversalType)
		{

			Hashtable CreateRiskReversalMarketData_args = new Hashtable();
			CreateRiskReversalMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateRiskReversalMarketData_args.Add("Expiries", Expiries);
			CreateRiskReversalMarketData_args.Add("Deltas", Deltas);
			CreateRiskReversalMarketData_args.Add("StrategyQuotes", StrategyQuotes);
			CreateRiskReversalMarketData_args.Add("DataName", DataName);
			CreateRiskReversalMarketData_args.Add("DataType", DataType);
			CreateRiskReversalMarketData_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateRiskReversalMarketData_args.Add("DeltaConvention", DeltaConvention);
			CreateRiskReversalMarketData_args.Add("QuoteDate", QuoteDate);
			CreateRiskReversalMarketData_args.Add("RiskReversalType", RiskReversalType);
			return F3Formatter.f3_style_serialization("CreateRiskReversalMarketData", CreateRiskReversalMarketData_args);
		}

		// <summary>
		// Create an accrual convention with accrued interest rounding.
		// </summary>
		// <param name="AccrualConventionName">Name to use for the Accrual Convention.</param>
		// <param name="Underlying">The underlying accrual convention.</param>
		// <param name="AccruedInterestRounding">Rounding instructions for the accrued       interest. Default value: None.</param>
		// <returns>Retuns the name of the constructed object of type AccrualConvention.</returns>
		public object CreateRoundingAccrualConvention(object AccrualConventionName, object Underlying, object AccruedInterestRounding)
		{

			Hashtable CreateRoundingAccrualConvention_args = new Hashtable();
			CreateRoundingAccrualConvention_args.Add("AccrualConventionName", AccrualConventionName);
			CreateRoundingAccrualConvention_args.Add("Underlying", Underlying);
			CreateRoundingAccrualConvention_args.Add("AccruedInterestRounding", AccruedInterestRounding);
			return F3Formatter.f3_style_serialization("CreateRoundingAccrualConvention", CreateRoundingAccrualConvention_args);
		}

		// <summary>
		// Create a yield to maturity convention which allows the user to specify rounding/truncation conventions.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldConvention">Underlying yield convention. Default value: DefaultYield.</param>
		// <param name="RoundPrice">Rounding instructions for the price.</param>
		// <param name="RoundYield">Rounding instructions for the yield.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateRoundingYieldConvention(object YieldConventionName, object YieldConvention, object RoundPrice, object RoundYield)
		{

			Hashtable CreateRoundingYieldConvention_args = new Hashtable();
			CreateRoundingYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateRoundingYieldConvention_args.Add("YieldConvention", YieldConvention);
			CreateRoundingYieldConvention_args.Add("RoundPrice", RoundPrice);
			CreateRoundingYieldConvention_args.Add("RoundYield", RoundYield);
			return F3Formatter.f3_style_serialization("CreateRoundingYieldConvention", CreateRoundingYieldConvention_args);
		}

		// <summary>
		// Create a scale and shift  modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="ScalingCoefficients">Vector of scaling coefficients, one per output value.</param>
		// <param name="ShiftAmounts">Vector of shift amounts, one per output value.</param>
		// <param name="ScalingParameterTag">Tag to use for scaling parameters.</param>
		// <param name="ShiftParameterTag">Tag to use for shift parameters.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateScaleAndShiftModifier(object ModifierName, object ScalingCoefficients, object ShiftAmounts, object ScalingParameterTag, object ShiftParameterTag)
		{

			Hashtable CreateScaleAndShiftModifier_args = new Hashtable();
			CreateScaleAndShiftModifier_args.Add("ModifierName", ModifierName);
			CreateScaleAndShiftModifier_args.Add("ScalingCoefficients", ScalingCoefficients);
			CreateScaleAndShiftModifier_args.Add("ShiftAmounts", ShiftAmounts);
			CreateScaleAndShiftModifier_args.Add("ScalingParameterTag", ScalingParameterTag);
			CreateScaleAndShiftModifier_args.Add("ShiftParameterTag", ShiftParameterTag);
			return F3Formatter.f3_style_serialization("CreateScaleAndShiftModifier", CreateScaleAndShiftModifier_args);
		}

		// <summary>
		// Create a valuation specification that approximates one compounding rate by scaling another.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="ReplacementConventions">Alternative schedule generators for each compounding rate to be approximated.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateScaledApproximateCompoundingRateValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object ReplacementConventions)
		{

			Hashtable CreateScaledApproximateCompoundingRateValuationSpecification_args = new Hashtable();
			CreateScaledApproximateCompoundingRateValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateScaledApproximateCompoundingRateValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateScaledApproximateCompoundingRateValuationSpecification_args.Add("ReplacementConventions", ReplacementConventions);
			return F3Formatter.f3_style_serialization("CreateScaledApproximateCompoundingRateValuationSpecification", CreateScaledApproximateCompoundingRateValuationSpecification_args);
		}

		// <summary>
		// Create a modifier whose outputs are correlated based on a specified function.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="CorrelationFunction">Two-dimensional volatility function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateSerialCorrelationFunctionModifier(object ModifierName, object TimePoints, object CorrelationFunction)
		{

			Hashtable CreateSerialCorrelationFunctionModifier_args = new Hashtable();
			CreateSerialCorrelationFunctionModifier_args.Add("ModifierName", ModifierName);
			CreateSerialCorrelationFunctionModifier_args.Add("TimePoints", TimePoints);
			CreateSerialCorrelationFunctionModifier_args.Add("CorrelationFunction", CorrelationFunction);
			return F3Formatter.f3_style_serialization("CreateSerialCorrelationFunctionModifier", CreateSerialCorrelationFunctionModifier_args);
		}

		// <summary>
		// Create the manager/repository object for an existing HTTP server.
		// </summary>
		// <param name="ServerConnectionName">Name of the object.</param>
		// <param name="TCPSocket">Socket used to connect to the instance.</param>
		// <param name="HTTPPort">Port the HTTP server is listening on.</param>
		// <returns>Retuns the name of the constructed object of type Server.</returns>
		public object CreateServerConnection(object ServerConnectionName, object TCPSocket, object HTTPPort)
		{

			Hashtable CreateServerConnection_args = new Hashtable();
			CreateServerConnection_args.Add("ServerConnectionName", ServerConnectionName);
			CreateServerConnection_args.Add("TCPSocket", TCPSocket);
			CreateServerConnection_args.Add("HTTPPort", HTTPPort);
			return F3Formatter.f3_style_serialization("CreateServerConnection", CreateServerConnection_args);
		}

		// <summary>
		// Create a market convention encapsulating settlement parameters.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="PaymentHolidays">Holiday conventions for payment dates.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="SettlementMaturityCalculator">Calculator for fixing settlement date given trade date.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateSettlementMarketConvention(object MarketConventionName, object PaymentHolidays, object MaturityCalculator, object SettlementMaturityDescriptor, object SettlementMaturityCalculator)
		{

			Hashtable CreateSettlementMarketConvention_args = new Hashtable();
			CreateSettlementMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateSettlementMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateSettlementMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateSettlementMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateSettlementMarketConvention_args.Add("SettlementMaturityCalculator", SettlementMaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateSettlementMarketConvention", CreateSettlementMarketConvention_args);
		}

		// <summary>
		// Create a shifted Heaviside step function builder.
		// </summary>
		// <param name="FunctionName">Name to use for the function builder.</param>
		// <param name="Shift">Shift amount.</param>
		// <returns>Retuns the name of the constructed object of type SingleParameterFunction.</returns>
		public object CreateShiftedHeavisideFunctionBuilder(object FunctionName, object Shift)
		{

			Hashtable CreateShiftedHeavisideFunctionBuilder_args = new Hashtable();
			CreateShiftedHeavisideFunctionBuilder_args.Add("FunctionName", FunctionName);
			CreateShiftedHeavisideFunctionBuilder_args.Add("Shift", Shift);
			return F3Formatter.f3_style_serialization("CreateShiftedHeavisideFunctionBuilder", CreateShiftedHeavisideFunctionBuilder_args);
		}

		// <summary>
		// Create a shifted lognormal modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="TimePoints">Vector of time points.</param>
		// <param name="ForwardFunction">Forward price function.</param>
		// <param name="VolatilityFunction">Black volatility function.</param>
		// <param name="ShiftFunction">Shift parameter function.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateShiftedLognormalModifier(object ModifierName, object TimePoints, object ForwardFunction, object VolatilityFunction, object ShiftFunction)
		{

			Hashtable CreateShiftedLognormalModifier_args = new Hashtable();
			CreateShiftedLognormalModifier_args.Add("ModifierName", ModifierName);
			CreateShiftedLognormalModifier_args.Add("TimePoints", TimePoints);
			CreateShiftedLognormalModifier_args.Add("ForwardFunction", ForwardFunction);
			CreateShiftedLognormalModifier_args.Add("VolatilityFunction", VolatilityFunction);
			CreateShiftedLognormalModifier_args.Add("ShiftFunction", ShiftFunction);
			return F3Formatter.f3_style_serialization("CreateShiftedLognormalModifier", CreateShiftedLognormalModifier_args);
		}

		// <summary>
		// Create a valuation specification for calibration.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="SilentlyDropCalibrationInstruments">Flag to indicate whether to drop failed instruments during the calibration algorithm.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSilentlyDropCalibrationInstrumentsValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object SilentlyDropCalibrationInstruments)
		{

			Hashtable CreateSilentlyDropCalibrationInstrumentsValuationSpecification_args = new Hashtable();
			CreateSilentlyDropCalibrationInstrumentsValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSilentlyDropCalibrationInstrumentsValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSilentlyDropCalibrationInstrumentsValuationSpecification_args.Add("SilentlyDropCalibrationInstruments", SilentlyDropCalibrationInstruments);
			return F3Formatter.f3_style_serialization("CreateSilentlyDropCalibrationInstrumentsValuationSpecification", CreateSilentlyDropCalibrationInstrumentsValuationSpecification_args);
		}

		// <summary>
		// Create a simple accrual convention.
		// </summary>
		// <param name="AccrualConventionName">Name to use for the Accrual Convention.</param>
		// <param name="DayCountType">Day count convention to use.</param>
		// <param name="RequireSettlementDateInPeriod">If true and the settlement date is not in the period, the accrual fraction is zero. Default value: true.</param>
		// <param name="RequireTradeDateInPeriod">If true and the trade date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="EndOnSettlementNotTrade">If true accrue to the settlement date, otherwise to the trade date. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type AccrualConvention.</returns>
		public object CreateSimpleAccrualConvention(object AccrualConventionName, object DayCountType, object RequireSettlementDateInPeriod, object RequireTradeDateInPeriod, object EndOnSettlementNotTrade)
		{

			Hashtable CreateSimpleAccrualConvention_args = new Hashtable();
			CreateSimpleAccrualConvention_args.Add("AccrualConventionName", AccrualConventionName);
			CreateSimpleAccrualConvention_args.Add("DayCountType", DayCountType);
			CreateSimpleAccrualConvention_args.Add("RequireSettlementDateInPeriod", RequireSettlementDateInPeriod);
			CreateSimpleAccrualConvention_args.Add("RequireTradeDateInPeriod", RequireTradeDateInPeriod);
			CreateSimpleAccrualConvention_args.Add("EndOnSettlementNotTrade", EndOnSettlementNotTrade);
			return F3Formatter.f3_style_serialization("CreateSimpleAccrualConvention", CreateSimpleAccrualConvention_args);
		}

		// <summary>
		// Create an equity asset index representing the value of an equity transaction.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Currency">Trading currency of equity.</param>
		// <param name="MarketConventions">Market conventions for transaction settlement.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSimpleEquityAssetIndex(object IndexName, object Currency, object MarketConventions)
		{

			Hashtable CreateSimpleEquityAssetIndex_args = new Hashtable();
			CreateSimpleEquityAssetIndex_args.Add("IndexName", IndexName);
			CreateSimpleEquityAssetIndex_args.Add("Currency", Currency);
			CreateSimpleEquityAssetIndex_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateSimpleEquityAssetIndex", CreateSimpleEquityAssetIndex_args);
		}

		// <summary>
		// Create a simple yield convention for fixed coupon bonds with level coupon payments.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for measuring the period from the settlement date to the next coupon date.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateSimpleFixedYieldConvention(object YieldConventionName, object AccrualConvention)
		{

			Hashtable CreateSimpleFixedYieldConvention_args = new Hashtable();
			CreateSimpleFixedYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateSimpleFixedYieldConvention_args.Add("AccrualConvention", AccrualConvention);
			return F3Formatter.f3_style_serialization("CreateSimpleFixedYieldConvention", CreateSimpleFixedYieldConvention_args);
		}

		// <summary>
		// Form an interface defaults instance with basic default values.
		// </summary>
		// <param name="InterfaceDefaultsName">Name to use for interface defaults.</param>
		// <param name="Currencies">Ordered list of default currencies.</param>
		// <returns>Retuns the name of the constructed object of type InterfaceDefaults.</returns>
		public object CreateSimpleInterfaceDefaults(object InterfaceDefaultsName, object Currencies)
		{

			Hashtable CreateSimpleInterfaceDefaults_args = new Hashtable();
			CreateSimpleInterfaceDefaults_args.Add("InterfaceDefaultsName", InterfaceDefaultsName);
			CreateSimpleInterfaceDefaults_args.Add("Currencies", Currencies);
			return F3Formatter.f3_style_serialization("CreateSimpleInterfaceDefaults", CreateSimpleInterfaceDefaults_args);
		}

		// <summary>
		// Create a maturity calculator based on a holiday convention.
		// </summary>
		// <param name="MaturityCalculatorName">Name to use for the maturity calculator.</param>
		// <param name="HolidayConventions">Holiday conventions for payment dates.</param>
		// <param name="PreserveMonthEnd">Ensure that end-of-month dates are preserved under month changes. Default value: false.</param>
		// <param name="MoveIntoNextMonth">Allow movement into a following month. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type MaturityCalculator.</returns>
		public object CreateSimpleMaturityCalculator(object MaturityCalculatorName, object HolidayConventions, object PreserveMonthEnd, object MoveIntoNextMonth)
		{

			Hashtable CreateSimpleMaturityCalculator_args = new Hashtable();
			CreateSimpleMaturityCalculator_args.Add("MaturityCalculatorName", MaturityCalculatorName);
			CreateSimpleMaturityCalculator_args.Add("HolidayConventions", HolidayConventions);
			CreateSimpleMaturityCalculator_args.Add("PreserveMonthEnd", PreserveMonthEnd);
			CreateSimpleMaturityCalculator_args.Add("MoveIntoNextMonth", MoveIntoNextMonth);
			return F3Formatter.f3_style_serialization("CreateSimpleMaturityCalculator", CreateSimpleMaturityCalculator_args);
		}

		// <summary>
		// Create a market convention that generates schedules with rolls that are an integer number of months long.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="PaymentHolidays">Holiday conventions for payment dates.</param>
		// <param name="MaturityCalculator">Roll maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="SettlementMaturityCalculator">Calculator for fixing settlement date given trade date.</param>
		// <param name="CouponLength">Length of coupon period in months.</param>
		// <param name="RateDayCountConvention">Rate day count calculation convention.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateSimpleRateMarketConvention(object MarketConventionName, object PaymentHolidays, object MaturityCalculator, object SettlementMaturityDescriptor, object SettlementMaturityCalculator, object CouponLength, object RateDayCountConvention)
		{

			Hashtable CreateSimpleRateMarketConvention_args = new Hashtable();
			CreateSimpleRateMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateSimpleRateMarketConvention_args.Add("PaymentHolidays", PaymentHolidays);
			CreateSimpleRateMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateSimpleRateMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateSimpleRateMarketConvention_args.Add("SettlementMaturityCalculator", SettlementMaturityCalculator);
			CreateSimpleRateMarketConvention_args.Add("CouponLength", CouponLength);
			CreateSimpleRateMarketConvention_args.Add("RateDayCountConvention", RateDayCountConvention);
			return F3Formatter.f3_style_serialization("CreateSimpleRateMarketConvention", CreateSimpleRateMarketConvention_args);
		}

		// <summary>
		// Create an optimizer with a simple root-search algorithm.
		// </summary>
		// <param name="OptimizerName">Name to use for optimizer.</param>
		// <param name="Tolerance">Tolerance for convergence. Default value: 1.0e-7.</param>
		// <param name="MaxIterations">Maximum number of iterations. Default value: 100.</param>
		// <param name="CollectDiagnostics">Flag indicating whether or not to collect diagnostic information on each iteration. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationOptimizer.</returns>
		public object CreateSimpleRootSearchOptimizer(object OptimizerName, object Tolerance, object MaxIterations, object CollectDiagnostics)
		{

			Hashtable CreateSimpleRootSearchOptimizer_args = new Hashtable();
			CreateSimpleRootSearchOptimizer_args.Add("OptimizerName", OptimizerName);
			CreateSimpleRootSearchOptimizer_args.Add("Tolerance", Tolerance);
			CreateSimpleRootSearchOptimizer_args.Add("MaxIterations", MaxIterations);
			CreateSimpleRootSearchOptimizer_args.Add("CollectDiagnostics", CollectDiagnostics);
			return F3Formatter.f3_style_serialization("CreateSimpleRootSearchOptimizer", CreateSimpleRootSearchOptimizer_args);
		}

		// <summary>
		// Create a spread yield convention for bonds, such that a yield spread is added over a benchmark index to form the bond yield.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="UnderlyingIndex">Underlying yield or other index identifying the benchmark yield without spread adjustment.</param>
		// <param name="YieldConvention">Yield convention for spread-adjusted underlying. Default value: DefaultYield.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateSimpleSpreadYieldConvention(object YieldConventionName, object UnderlyingIndex, object YieldConvention)
		{

			Hashtable CreateSimpleSpreadYieldConvention_args = new Hashtable();
			CreateSimpleSpreadYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateSimpleSpreadYieldConvention_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateSimpleSpreadYieldConvention_args.Add("YieldConvention", YieldConvention);
			return F3Formatter.f3_style_serialization("CreateSimpleSpreadYieldConvention", CreateSimpleSpreadYieldConvention_args);
		}

		// <summary>
		// Create a market convention that generates schedules using the specified day count convention for accrual factors in the stub.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="StubDayCountConvention">Day count convention for calculating accrual factors of stub rolls. Default value: 30E/360.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateSimpleStubScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object StubDayCountConvention)
		{

			Hashtable CreateSimpleStubScheduleMarketConvention_args = new Hashtable();
			CreateSimpleStubScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateSimpleStubScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateSimpleStubScheduleMarketConvention_args.Add("StubDayCountConvention", StubDayCountConvention);
			return F3Formatter.f3_style_serialization("CreateSimpleStubScheduleMarketConvention", CreateSimpleStubScheduleMarketConvention_args);
		}

		// <summary>
		// Create a simple yield accrual convention.
		// </summary>
		// <param name="AccrualConventionName">Name to use for the Accrual Convention.</param>
		// <param name="DayCountType">Day Count convention to use.</param>
		// <param name="RequireSettlementDateInPeriod">If true and the settlement date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="RequireTradeDateInPeriod">If true and the trade date is not in the period, the accrual fraction is zero. Default value: false.</param>
		// <param name="EndOnSettlementNotTrade">If true accrue to the settlement date, otherwise to the trade date. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type AccrualConvention.</returns>
		public object CreateSimpleYieldAccrualConvention(object AccrualConventionName, object DayCountType, object RequireSettlementDateInPeriod, object RequireTradeDateInPeriod, object EndOnSettlementNotTrade)
		{

			Hashtable CreateSimpleYieldAccrualConvention_args = new Hashtable();
			CreateSimpleYieldAccrualConvention_args.Add("AccrualConventionName", AccrualConventionName);
			CreateSimpleYieldAccrualConvention_args.Add("DayCountType", DayCountType);
			CreateSimpleYieldAccrualConvention_args.Add("RequireSettlementDateInPeriod", RequireSettlementDateInPeriod);
			CreateSimpleYieldAccrualConvention_args.Add("RequireTradeDateInPeriod", RequireTradeDateInPeriod);
			CreateSimpleYieldAccrualConvention_args.Add("EndOnSettlementNotTrade", EndOnSettlementNotTrade);
			return F3Formatter.f3_style_serialization("CreateSimpleYieldAccrualConvention", CreateSimpleYieldAccrualConvention_args);
		}

		// <summary>
		// Create a function to calculate convexity numerator of a fixed coupon bond, given the yield.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="CouponsPerYear">Number of coupon periods per year.</param>
		// <param name="Delta">Time in years from settlement until first coupon payment.</param>
		// <param name="CouponRate">Coupon rate per year.</param>
		// <param name="NumCoupons">Number of coupons left until bond maturity.</param>
		// <param name="CouponsPerYearTag">Tag for CouponsPerYear parameter.</param>
		// <param name="DeltaTag">Tag for Delta parameter.</param>
		// <param name="CouponRateTag">Tag for CouponRate parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateSimpleYieldToConvexityNumeratorFunction(object FunctionName, object CouponsPerYear, object Delta, object CouponRate, object NumCoupons, object CouponsPerYearTag, object DeltaTag, object CouponRateTag)
		{

			Hashtable CreateSimpleYieldToConvexityNumeratorFunction_args = new Hashtable();
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("FunctionName", FunctionName);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("CouponsPerYear", CouponsPerYear);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("Delta", Delta);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("CouponRate", CouponRate);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("NumCoupons", NumCoupons);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("CouponsPerYearTag", CouponsPerYearTag);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("DeltaTag", DeltaTag);
			CreateSimpleYieldToConvexityNumeratorFunction_args.Add("CouponRateTag", CouponRateTag);
			return F3Formatter.f3_style_serialization("CreateSimpleYieldToConvexityNumeratorFunction", CreateSimpleYieldToConvexityNumeratorFunction_args);
		}

		// <summary>
		// Create a function to calculate duration of a fixed coupon bond, given the yield.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="CouponsPerYear">Number of coupon periods per year.</param>
		// <param name="Delta">Time in years from settlement until first coupon payment.</param>
		// <param name="CouponRate">Coupon rate per year.</param>
		// <param name="NumCoupons">Number of coupons left until bond maturity.</param>
		// <param name="CouponsPerYearTag">Tag for CouponsPerYear parameter.</param>
		// <param name="DeltaTag">Tag for Delta parameter.</param>
		// <param name="CouponRateTag">Tag for CouponRate parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateSimpleYieldToDurationFunction(object FunctionName, object CouponsPerYear, object Delta, object CouponRate, object NumCoupons, object CouponsPerYearTag, object DeltaTag, object CouponRateTag)
		{

			Hashtable CreateSimpleYieldToDurationFunction_args = new Hashtable();
			CreateSimpleYieldToDurationFunction_args.Add("FunctionName", FunctionName);
			CreateSimpleYieldToDurationFunction_args.Add("CouponsPerYear", CouponsPerYear);
			CreateSimpleYieldToDurationFunction_args.Add("Delta", Delta);
			CreateSimpleYieldToDurationFunction_args.Add("CouponRate", CouponRate);
			CreateSimpleYieldToDurationFunction_args.Add("NumCoupons", NumCoupons);
			CreateSimpleYieldToDurationFunction_args.Add("CouponsPerYearTag", CouponsPerYearTag);
			CreateSimpleYieldToDurationFunction_args.Add("DeltaTag", DeltaTag);
			CreateSimpleYieldToDurationFunction_args.Add("CouponRateTag", CouponRateTag);
			return F3Formatter.f3_style_serialization("CreateSimpleYieldToDurationFunction", CreateSimpleYieldToDurationFunction_args);
		}

		// <summary>
		// Create a simple yield to maturity convention for fixed coupon bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldAccrualConvention">Accrual convention for measuring the accrual fraction used in yield calculation.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateSimpleYieldToMaturityConvention(object YieldConventionName, object YieldAccrualConvention)
		{

			Hashtable CreateSimpleYieldToMaturityConvention_args = new Hashtable();
			CreateSimpleYieldToMaturityConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateSimpleYieldToMaturityConvention_args.Add("YieldAccrualConvention", YieldAccrualConvention);
			return F3Formatter.f3_style_serialization("CreateSimpleYieldToMaturityConvention", CreateSimpleYieldToMaturityConvention_args);
		}

		// <summary>
		// Create a Simpson integration method.
		// </summary>
		// <param name="MethodName">Name to use for the method.</param>
		// <param name="NumberOfSteps">Number of steps.</param>
		// <returns>Retuns the name of the constructed object of type IntegrationMethod.</returns>
		public object CreateSimpsonIntegrationMethod(object MethodName, object NumberOfSteps)
		{

			Hashtable CreateSimpsonIntegrationMethod_args = new Hashtable();
			CreateSimpsonIntegrationMethod_args.Add("MethodName", MethodName);
			CreateSimpsonIntegrationMethod_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateSimpsonIntegrationMethod", CreateSimpsonIntegrationMethod_args);
		}

		// <summary>
		// Create a valuation specification for generic Monte Carlo simulations.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Specification of the numeraire to use in simulation.</param>
		// <param name="NamedStateVariableTemplates">Named state variable templates.</param>
		// <param name="Generator">Base generator to use in simulation computations.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="Iterations">Iteration control. Default value: 1023.</param>
		// <param name="SimulationPoints">Number of points to use in the discretization, in addition to the fixing points. Default value: 0.</param>
		// <param name="AuxiliaryIterations">Iteration control for auxiliary simulation. Default value: default-constructed instance of type computation_specification.</param>
		// <param name="NamedSimFuncTemplates">Named simulation function templates. Default value: default-constructed instance of type sim_function_template_map.</param>
		// <param name="NamedIndices">Named indices. Default value: default-constructed instance of type index_map.</param>
		// <param name="CorrelationSpecification">Method to use for correlation matrix decomposition. Default value: Cholesky.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSimulationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency, object NamedStateVariableTemplates, object Generator, object CalculationMethod, object Iterations, object SimulationPoints, object AuxiliaryIterations, object NamedSimFuncTemplates,
		object NamedIndices, object CorrelationSpecification)
		{

			Hashtable CreateSimulationValuationSpecification_args = new Hashtable();
			CreateSimulationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSimulationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSimulationValuationSpecification_args.Add("Currency", Currency);
			CreateSimulationValuationSpecification_args.Add("NamedStateVariableTemplates", NamedStateVariableTemplates);
			CreateSimulationValuationSpecification_args.Add("Generator", Generator);
			CreateSimulationValuationSpecification_args.Add("CalculationMethod", CalculationMethod);
			CreateSimulationValuationSpecification_args.Add("Iterations", Iterations);
			CreateSimulationValuationSpecification_args.Add("SimulationPoints", SimulationPoints);
			CreateSimulationValuationSpecification_args.Add("AuxiliaryIterations", AuxiliaryIterations);
			CreateSimulationValuationSpecification_args.Add("NamedSimFuncTemplates", NamedSimFuncTemplates);
			CreateSimulationValuationSpecification_args.Add("NamedIndices", NamedIndices);
			CreateSimulationValuationSpecification_args.Add("CorrelationSpecification", CorrelationSpecification);
			return F3Formatter.f3_style_serialization("CreateSimulationValuationSpecification", CreateSimulationValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification for circulant matrix backward evolution pricing involving a single asset-like index.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Index">Index to be modeled stochastically.</param>
		// <param name="CharFunc">Characteristic function builder for the stochastic process modeling the index.</param>
		// <param name="IntegralSize">Size of the integral approximating the convolution.</param>
		// <param name="NumberOfPoints">Number of points to use in the numerical calculation of the convolution.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Index, object CharFunc, object IntegralSize, object NumberOfPoints)
		{

			Hashtable CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args = new Hashtable();
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("Index", Index);
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("CharFunc", CharFunc);
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("IntegralSize", IntegralSize);
			CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args.Add("NumberOfPoints", NumberOfPoints);
			return F3Formatter.f3_style_serialization("CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification", CreateSingleAssetCirculantMatrixBackwardEvolutionValuationSpecification_args);
		}

		// <summary>
		// Create a valuation specification for Fourier transform pricing involving a single asset-like index.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Valuation currency.</param>
		// <param name="Index">Index to be modeled stochastically.</param>
		// <param name="CharFunc">Characteristic function builder for the stochastic process modeling the index.</param>
		// <param name="IntegralSize">Size of the integral approximating the Fourier transform.</param>
		// <param name="NumberOfPoints">Number of points to use in the numerical calculation of the Fourier integral.</param>
		// <param name="DampingParameter">Damping factor to apply for ensuring the existence of the Fourier transform.</param>
		// <param name="DampingParameterTag">Tag to use for the damping parameter.</param>
		// <param name="IndexName">Name of the index in FITR. Default value: default-constructed instance of type index_name.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSingleAssetFourierTransformValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency, object Index, object CharFunc, object IntegralSize, object NumberOfPoints, object DampingParameter, object DampingParameterTag, object IndexName)
		{

			Hashtable CreateSingleAssetFourierTransformValuationSpecification_args = new Hashtable();
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("Currency", Currency);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("Index", Index);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("CharFunc", CharFunc);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("IntegralSize", IntegralSize);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("NumberOfPoints", NumberOfPoints);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("DampingParameter", DampingParameter);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("DampingParameterTag", DampingParameterTag);
			CreateSingleAssetFourierTransformValuationSpecification_args.Add("IndexName", IndexName);
			return F3Formatter.f3_style_serialization("CreateSingleAssetFourierTransformValuationSpecification", CreateSingleAssetFourierTransformValuationSpecification_args);
		}

		// <summary>
		// Create a single barrier European option on an underlying index.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Underlying">Underlying on which the option is written.</param>
		// <param name="Start">Start time point of the barrier observation period of the underlying.</param>
		// <param name="Expiry">Expiry of the option and end time point of the barrier observation period.</param>
		// <param name="Notional">Notional amount of the option.</param>
		// <param name="BarrierLevel">Barrier level against which the underlying is       compared.</param>
		// <param name="UpOrDown">Direction from which the barrier can be       breached.</param>
		// <param name="InOrOut">Knock-in or knock-out.</param>
		// <param name="BarrierObservation">Specification for       when the underlying is to be observed.</param>
		// <param name="Strike">Strike of the option.</param>
		// <param name="Payoff">Description of the option payoff.</param>
		// <param name="BuySell">Specification of whether the option is bought or sold.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleBarrierEuropeanOption(object ProductName, object Underlying, object Start, object Expiry, object Notional, object BarrierLevel, object UpOrDown, object InOrOut, object BarrierObservation, object Strike,
		object Payoff, object BuySell)
		{

			Hashtable CreateSingleBarrierEuropeanOption_args = new Hashtable();
			CreateSingleBarrierEuropeanOption_args.Add("ProductName", ProductName);
			CreateSingleBarrierEuropeanOption_args.Add("Underlying", Underlying);
			CreateSingleBarrierEuropeanOption_args.Add("Start", Start);
			CreateSingleBarrierEuropeanOption_args.Add("Expiry", Expiry);
			CreateSingleBarrierEuropeanOption_args.Add("Notional", Notional);
			CreateSingleBarrierEuropeanOption_args.Add("BarrierLevel", BarrierLevel);
			CreateSingleBarrierEuropeanOption_args.Add("UpOrDown", UpOrDown);
			CreateSingleBarrierEuropeanOption_args.Add("InOrOut", InOrOut);
			CreateSingleBarrierEuropeanOption_args.Add("BarrierObservation", BarrierObservation);
			CreateSingleBarrierEuropeanOption_args.Add("Strike", Strike);
			CreateSingleBarrierEuropeanOption_args.Add("Payoff", Payoff);
			CreateSingleBarrierEuropeanOption_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateSingleBarrierEuropeanOption", CreateSingleBarrierEuropeanOption_args);
		}

		// <summary>
		// Form an index which indicates whether a single barrier is breached.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="BarrierLevel">Barrier level against which the underlying index is compared.</param>
		// <param name="UpOrDown">Direction from which the barrier can be breached.</param>
		// <param name="InOrOut">Knock-in or knock-out.</param>
		// <param name="ObservationSpec">Specification for when the underlying is to be observed.</param>
		// <param name="Referencer">Rule for defining the observation period. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSingleBarrierIndex(object IndexName, object UnderlyingIndex, object BarrierLevel, object UpOrDown, object InOrOut, object ObservationSpec, object Referencer)
		{

			Hashtable CreateSingleBarrierIndex_args = new Hashtable();
			CreateSingleBarrierIndex_args.Add("IndexName", IndexName);
			CreateSingleBarrierIndex_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateSingleBarrierIndex_args.Add("BarrierLevel", BarrierLevel);
			CreateSingleBarrierIndex_args.Add("UpOrDown", UpOrDown);
			CreateSingleBarrierIndex_args.Add("InOrOut", InOrOut);
			CreateSingleBarrierIndex_args.Add("ObservationSpec", ObservationSpec);
			CreateSingleBarrierIndex_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateSingleBarrierIndex", CreateSingleBarrierIndex_args);
		}

		// <summary>
		// Create a backward evolution operator for performing a single backward induction step in the Fourier space for single knock-out options.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="Strike">Strike price.</param>
		// <param name="Barrier">Barrier level.</param>
		// <param name="UpAndOut">True for up-and-out, false for down-and-out.</param>
		// <param name="StrikeParameterTag">Tag to use for the strike price.</param>
		// <param name="BarrierParameterTag">Tag to use for the barrier level.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator(object OperatorName, object Strike, object Barrier, object UpAndOut, object StrikeParameterTag, object BarrierParameterTag)
		{

			Hashtable CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args = new Hashtable();
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("OperatorName", OperatorName);
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("Strike", Strike);
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("Barrier", Barrier);
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("UpAndOut", UpAndOut);
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("StrikeParameterTag", StrikeParameterTag);
			CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args.Add("BarrierParameterTag", BarrierParameterTag);
			return F3Formatter.f3_style_serialization("CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator", CreateSingleBarrierKnockOutFourierSpaceBackwardEvolveOperator_args);
		}

		// <summary>
		// Create a simulation function template for the simulation of a single barrier.
		// </summary>
		// <param name="SimulationFunctionTemplate">Name to use for the simulation function template.</param>
		// <param name="MarketConvention">Market convention used in the simulation of a derived index.</param>
		// <param name="DateListBuilder">Rule for determining observation dates from a roll schedule.</param>
		// <returns>Retuns the name of the constructed object of type SimulationFunctions.</returns>
		public object CreateSingleBarrierSimulationFunctionTemplate(object SimulationFunctionTemplate, object MarketConvention, object DateListBuilder)
		{

			Hashtable CreateSingleBarrierSimulationFunctionTemplate_args = new Hashtable();
			CreateSingleBarrierSimulationFunctionTemplate_args.Add("SimulationFunctionTemplate", SimulationFunctionTemplate);
			CreateSingleBarrierSimulationFunctionTemplate_args.Add("MarketConvention", MarketConvention);
			CreateSingleBarrierSimulationFunctionTemplate_args.Add("DateListBuilder", DateListBuilder);
			return F3Formatter.f3_style_serialization("CreateSingleBarrierSimulationFunctionTemplate", CreateSingleBarrierSimulationFunctionTemplate_args);
		}

		// <summary>
		// Create a product that represents a single cash flow.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="RollDates">Dates roll for the cash flow.</param>
		// <param name="Index">Index describing the cash flow payments.</param>
		// <param name="Notional">The notional amount of the cash flow.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flow.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCashflowProduct(object ProductName, object RollDates, object Index, object Notional, object Currency, object PayRec)
		{

			Hashtable CreateSingleCashflowProduct_args = new Hashtable();
			CreateSingleCashflowProduct_args.Add("ProductName", ProductName);
			CreateSingleCashflowProduct_args.Add("RollDates", RollDates);
			CreateSingleCashflowProduct_args.Add("Index", Index);
			CreateSingleCashflowProduct_args.Add("Notional", Notional);
			CreateSingleCashflowProduct_args.Add("Currency", Currency);
			CreateSingleCashflowProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateSingleCashflowProduct", CreateSingleCashflowProduct_args);
		}

		// <summary>
		// Create a product that represents a leg of flows in one currency.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="RollSchedule">Roll schedule for the cash flows.</param>
		// <param name="FixedCoupon">The fixed coupon paid on each flow of the leg.</param>
		// <param name="Notionals">The notionals of the cash flows.</param>
		// <param name="Currency">Currency of the notionals.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flows.</param>
		// <param name="Index">Index multiplying the fixed coupon payment. Default value: UnitConstant.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCurrencyFixedLeg(object ProductName, object RollSchedule, object FixedCoupon, object Notionals, object Currency, object PayRec, object Index)
		{

			Hashtable CreateSingleCurrencyFixedLeg_args = new Hashtable();
			CreateSingleCurrencyFixedLeg_args.Add("ProductName", ProductName);
			CreateSingleCurrencyFixedLeg_args.Add("RollSchedule", RollSchedule);
			CreateSingleCurrencyFixedLeg_args.Add("FixedCoupon", FixedCoupon);
			CreateSingleCurrencyFixedLeg_args.Add("Notionals", Notionals);
			CreateSingleCurrencyFixedLeg_args.Add("Currency", Currency);
			CreateSingleCurrencyFixedLeg_args.Add("PayRec", PayRec);
			CreateSingleCurrencyFixedLeg_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("CreateSingleCurrencyFixedLeg", CreateSingleCurrencyFixedLeg_args);
		}

		// <summary>
		// Create a product that represents a leg of floating-rate linked flows in one currency.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="RollSchedule">Roll schedule for the cash flows.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate paid on each flow of the leg. Default value: 0.0.</param>
		// <param name="Notionals">The notionals of the cash flows.</param>
		// <param name="Currency">Currency of the notionals.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flows.</param>
		// <param name="Index">Index scaling the cash flow payments, including any margin over the floating rate. Default value: UnitConstant.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCurrencyFloatingLeg(object ProductName, object RollSchedule, object FloatingRateIndex, object Margin, object Notionals, object Currency, object PayRec, object Index)
		{

			Hashtable CreateSingleCurrencyFloatingLeg_args = new Hashtable();
			CreateSingleCurrencyFloatingLeg_args.Add("ProductName", ProductName);
			CreateSingleCurrencyFloatingLeg_args.Add("RollSchedule", RollSchedule);
			CreateSingleCurrencyFloatingLeg_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateSingleCurrencyFloatingLeg_args.Add("Margin", Margin);
			CreateSingleCurrencyFloatingLeg_args.Add("Notionals", Notionals);
			CreateSingleCurrencyFloatingLeg_args.Add("Currency", Currency);
			CreateSingleCurrencyFloatingLeg_args.Add("PayRec", PayRec);
			CreateSingleCurrencyFloatingLeg_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("CreateSingleCurrencyFloatingLeg", CreateSingleCurrencyFloatingLeg_args);
		}

		// <summary>
		// Create a product that represents the swap of one stream of cash flows for another.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="CouponLeg">Product to use as the coupon-bearing leg.</param>
		// <param name="OffsettingLeg">Product to use as the offsetting leg.</param>
		// <param name="ExtraFlows">Set of weighted products to include in addition to the two legs. Default value: default-constructed instance of type weighted_products.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCurrencyGenericSwap(object ProductName, object CouponLeg, object OffsettingLeg, object ExtraFlows)
		{

			Hashtable CreateSingleCurrencyGenericSwap_args = new Hashtable();
			CreateSingleCurrencyGenericSwap_args.Add("ProductName", ProductName);
			CreateSingleCurrencyGenericSwap_args.Add("CouponLeg", CouponLeg);
			CreateSingleCurrencyGenericSwap_args.Add("OffsettingLeg", OffsettingLeg);
			CreateSingleCurrencyGenericSwap_args.Add("ExtraFlows", ExtraFlows);
			return F3Formatter.f3_style_serialization("CreateSingleCurrencyGenericSwap", CreateSingleCurrencyGenericSwap_args);
		}

		// <summary>
		// Create a product that represents the swap of one stream of cash flows for another.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="CouponLeg">Product to use as the coupon-bearing leg.</param>
		// <param name="OffsettingLeg">Product to use as the offsetting leg.</param>
		// <param name="ExtraFlows">Set of weighted products to include in addition to the two legs.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCurrencyGenericSwapWithExtraFlows(object ProductName, object CouponLeg, object OffsettingLeg, object ExtraFlows)
		{

			Hashtable CreateSingleCurrencyGenericSwapWithExtraFlows_args = new Hashtable();
			CreateSingleCurrencyGenericSwapWithExtraFlows_args.Add("ProductName", ProductName);
			CreateSingleCurrencyGenericSwapWithExtraFlows_args.Add("CouponLeg", CouponLeg);
			CreateSingleCurrencyGenericSwapWithExtraFlows_args.Add("OffsettingLeg", OffsettingLeg);
			CreateSingleCurrencyGenericSwapWithExtraFlows_args.Add("ExtraFlows", ExtraFlows);
			return F3Formatter.f3_style_serialization("CreateSingleCurrencyGenericSwapWithExtraFlows", CreateSingleCurrencyGenericSwapWithExtraFlows_args);
		}

		// <summary>
		// Create a product that represents the swap of one stream of cash flows for another.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="CouponLeg">Product to use as the coupon-bearing leg.</param>
		// <param name="OffsettingLeg">Product to use as the offsetting leg.</param>
		// <param name="ExtraFlows">Set of weighted products to include in addition to the two legs. Default value: default-constructed instance of type weighted_products.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleCurrencyVanillaSwap(object ProductName, object CouponLeg, object OffsettingLeg, object ExtraFlows)
		{

			Hashtable CreateSingleCurrencyVanillaSwap_args = new Hashtable();
			CreateSingleCurrencyVanillaSwap_args.Add("ProductName", ProductName);
			CreateSingleCurrencyVanillaSwap_args.Add("CouponLeg", CouponLeg);
			CreateSingleCurrencyVanillaSwap_args.Add("OffsettingLeg", OffsettingLeg);
			CreateSingleCurrencyVanillaSwap_args.Add("ExtraFlows", ExtraFlows);
			return F3Formatter.f3_style_serialization("CreateSingleCurrencyVanillaSwap", CreateSingleCurrencyVanillaSwap_args);
		}

		// <summary>
		// Create a market data set containing a set of credit default swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="SwapRates">Vector of CDS premia.</param>
		// <param name="Currency">Currency of CDS.</param>
		// <param name="CDSDataName">Name of CDS market data.</param>
		// <param name="CDSDataType">Type of CDS market data.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditContract">Credit contract.</param>
		// <param name="PayAccrued">Switch for whether or not to pay accrued interest upon default. Default value: true.</param>
		// <param name="OffsettingLegMarketConventions">Market conventions for the offsetting (default) leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateSingleEventCDSMarketData(object MarketDataSetName, object Maturities, object SwapRates, object Currency, object CDSDataName, object CDSDataType, object MarketConventions, object CreditContract, object PayAccrued, object OffsettingLegMarketConventions,
		object QuoteDate)
		{

			Hashtable CreateSingleEventCDSMarketData_args = new Hashtable();
			CreateSingleEventCDSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateSingleEventCDSMarketData_args.Add("Maturities", Maturities);
			CreateSingleEventCDSMarketData_args.Add("SwapRates", SwapRates);
			CreateSingleEventCDSMarketData_args.Add("Currency", Currency);
			CreateSingleEventCDSMarketData_args.Add("CDSDataName", CDSDataName);
			CreateSingleEventCDSMarketData_args.Add("CDSDataType", CDSDataType);
			CreateSingleEventCDSMarketData_args.Add("MarketConventions", MarketConventions);
			CreateSingleEventCDSMarketData_args.Add("CreditContract", CreditContract);
			CreateSingleEventCDSMarketData_args.Add("PayAccrued", PayAccrued);
			CreateSingleEventCDSMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			CreateSingleEventCDSMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateSingleEventCDSMarketData", CreateSingleEventCDSMarketData_args);
		}

		// <summary>
		// Create a single-event fixed-for-floating constant maturity credit default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="Coupon">The coupon rate paid on each roll of the fixed leg.</param>
		// <param name="Cap">The cap for the credit default swap rate.</param>
		// <param name="UnderlyingCDSRateInstrument">The specification of the reference rate.</param>
		// <param name="PayAccrued">Flag indicating whether accrued interest is to be paid on default.</param>
		// <param name="PayOnlyIfSurvive">Flag Indicating whether payment is conditional on survival of the reference entity.</param>
		// <param name="FixedLegConvention">Market conventions of the fixed leg.</param>
		// <param name="FloatingLegConvention">Market conventions of the floating leg.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <param name="Referencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleEventCDSRateSwap(object ProductName, object StartDate, object Maturity, object Notional, object UpfrontFee, object Coupon, object Cap, object UnderlyingCDSRateInstrument, object PayAccrued, object PayOnlyIfSurvive,
		object FixedLegConvention, object FloatingLegConvention, object PayRec, object Referencer)
		{

			Hashtable CreateSingleEventCDSRateSwap_args = new Hashtable();
			CreateSingleEventCDSRateSwap_args.Add("ProductName", ProductName);
			CreateSingleEventCDSRateSwap_args.Add("StartDate", StartDate);
			CreateSingleEventCDSRateSwap_args.Add("Maturity", Maturity);
			CreateSingleEventCDSRateSwap_args.Add("Notional", Notional);
			CreateSingleEventCDSRateSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateSingleEventCDSRateSwap_args.Add("Coupon", Coupon);
			CreateSingleEventCDSRateSwap_args.Add("Cap", Cap);
			CreateSingleEventCDSRateSwap_args.Add("UnderlyingCDSRateInstrument", UnderlyingCDSRateInstrument);
			CreateSingleEventCDSRateSwap_args.Add("PayAccrued", PayAccrued);
			CreateSingleEventCDSRateSwap_args.Add("PayOnlyIfSurvive", PayOnlyIfSurvive);
			CreateSingleEventCDSRateSwap_args.Add("FixedLegConvention", FixedLegConvention);
			CreateSingleEventCDSRateSwap_args.Add("FloatingLegConvention", FloatingLegConvention);
			CreateSingleEventCDSRateSwap_args.Add("PayRec", PayRec);
			CreateSingleEventCDSRateSwap_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventCDSRateSwap", CreateSingleEventCDSRateSwap_args);
		}

		// <summary>
		// Create a single-event constant maturity default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="Cap">The cap for the credit default swap rate.</param>
		// <param name="UnderlyingCDSRateInstrument">The specification of the reference rate.</param>
		// <param name="PayAccrued">Flag indicating whether accrued interest is to be paid on default.</param>
		// <param name="PayOnlyIfSurvive">Flag Indicating whether payment is conditional on survival of the reference entity.</param>
		// <param name="MarketConvention">Market conventions.</param>
		// <param name="DefaultUnitWeight">The weight of the default unit index. Default value: 1.0.</param>
		// <param name="DefaultRecoveryWeight">The weight of the default recovery index. Default value: -1.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <param name="Referencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleEventConstantMaturityDefaultSwap(object ProductName, object StartDate, object Maturity, object Notional, object UpfrontFee, object Cap, object UnderlyingCDSRateInstrument, object PayAccrued, object PayOnlyIfSurvive, object MarketConvention,
		object DefaultUnitWeight, object DefaultRecoveryWeight, object PayRec, object Referencer)
		{

			Hashtable CreateSingleEventConstantMaturityDefaultSwap_args = new Hashtable();
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("ProductName", ProductName);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("StartDate", StartDate);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("Maturity", Maturity);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("Notional", Notional);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("Cap", Cap);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("UnderlyingCDSRateInstrument", UnderlyingCDSRateInstrument);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("PayAccrued", PayAccrued);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("PayOnlyIfSurvive", PayOnlyIfSurvive);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("DefaultUnitWeight", DefaultUnitWeight);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("DefaultRecoveryWeight", DefaultRecoveryWeight);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("PayRec", PayRec);
			CreateSingleEventConstantMaturityDefaultSwap_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventConstantMaturityDefaultSwap", CreateSingleEventConstantMaturityDefaultSwap_args);
		}

		// <summary>
		// Create a single-name credit index for accrual on default calculations.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of the credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSingleEventCreditAccrualOnDefaultIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateSingleEventCreditAccrualOnDefaultIndex_args = new Hashtable();
			CreateSingleEventCreditAccrualOnDefaultIndex_args.Add("IndexName", IndexName);
			CreateSingleEventCreditAccrualOnDefaultIndex_args.Add("CreditContract", CreditContract);
			CreateSingleEventCreditAccrualOnDefaultIndex_args.Add("Currency", Currency);
			CreateSingleEventCreditAccrualOnDefaultIndex_args.Add("MarketConventions", MarketConventions);
			CreateSingleEventCreditAccrualOnDefaultIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditAccrualOnDefaultIndex", CreateSingleEventCreditAccrualOnDefaultIndex_args);
		}

		// <summary>
		// Create a single-name credit default recovery index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of the credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSingleEventCreditDefaultRecoveryIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateSingleEventCreditDefaultRecoveryIndex_args = new Hashtable();
			CreateSingleEventCreditDefaultRecoveryIndex_args.Add("IndexName", IndexName);
			CreateSingleEventCreditDefaultRecoveryIndex_args.Add("CreditContract", CreditContract);
			CreateSingleEventCreditDefaultRecoveryIndex_args.Add("Currency", Currency);
			CreateSingleEventCreditDefaultRecoveryIndex_args.Add("MarketConventions", MarketConventions);
			CreateSingleEventCreditDefaultRecoveryIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditDefaultRecoveryIndex", CreateSingleEventCreditDefaultRecoveryIndex_args);
		}

		// <summary>
		// Create a single-event credit default swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <param name="Premium">The premium paid on each roll of the premium leg.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="PayAccruedInterestUponDefault">Pay accrued interest upon default.</param>
		// <param name="MarketConvention">Market conventions for the premium leg.</param>
		// <param name="WeightDefaultUnit">The weight of the default unit index. Default value: 1.0.</param>
		// <param name="WeightDefaultRecovery">The weight of the default recovery index. Default value: -1.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <param name="OffsettingMarketConvention">Market conventions for the offsetting leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleEventCreditDefaultSwap(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object CreditContract, object Premium, object UpfrontFee, object PayAccruedInterestUponDefault, object MarketConvention,
		object WeightDefaultUnit, object WeightDefaultRecovery, object PayRec, object OffsettingMarketConvention)
		{

			Hashtable CreateSingleEventCreditDefaultSwap_args = new Hashtable();
			CreateSingleEventCreditDefaultSwap_args.Add("ProductName", ProductName);
			CreateSingleEventCreditDefaultSwap_args.Add("StartDate", StartDate);
			CreateSingleEventCreditDefaultSwap_args.Add("Maturity", Maturity);
			CreateSingleEventCreditDefaultSwap_args.Add("Notional", Notional);
			CreateSingleEventCreditDefaultSwap_args.Add("Currency", Currency);
			CreateSingleEventCreditDefaultSwap_args.Add("CreditContract", CreditContract);
			CreateSingleEventCreditDefaultSwap_args.Add("Premium", Premium);
			CreateSingleEventCreditDefaultSwap_args.Add("UpfrontFee", UpfrontFee);
			CreateSingleEventCreditDefaultSwap_args.Add("PayAccruedInterestUponDefault", PayAccruedInterestUponDefault);
			CreateSingleEventCreditDefaultSwap_args.Add("MarketConvention", MarketConvention);
			CreateSingleEventCreditDefaultSwap_args.Add("WeightDefaultUnit", WeightDefaultUnit);
			CreateSingleEventCreditDefaultSwap_args.Add("WeightDefaultRecovery", WeightDefaultRecovery);
			CreateSingleEventCreditDefaultSwap_args.Add("PayRec", PayRec);
			CreateSingleEventCreditDefaultSwap_args.Add("OffsettingMarketConvention", OffsettingMarketConvention);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditDefaultSwap", CreateSingleEventCreditDefaultSwap_args);
		}

		// <summary>
		// Create a single-event credit default swaption.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="CreditEntity">The credit entity on which the underlying credit default swap is written.</param>
		// <param name="Expiry">Expiry date of the swaption.</param>
		// <param name="Maturity">Underlying swap maturity.</param>
		// <param name="Notional">Notional of the underlying swap.</param>
		// <param name="Currency">Currency of the underlying swap.</param>
		// <param name="Strike">Strike of the swaption.</param>
		// <param name="Payoff">Payer or receiver swaption.</param>
		// <param name="BuySell">Flag indicating buying or selling the swaption.</param>
		// <param name="PremiumLegMarketConvention">Premium leg market conventions.</param>
		// <param name="ProtectionLegMarketConvention">Protection leg market conventions.</param>
		// <param name="PayAccrued">Switch for whether the underlying swap pays accrued premium amount upon default. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleEventCreditDefaultSwaption(object ProductName, object CreditEntity, object Expiry, object Maturity, object Notional, object Currency, object Strike, object Payoff, object BuySell, object PremiumLegMarketConvention,
		object ProtectionLegMarketConvention, object PayAccrued)
		{

			Hashtable CreateSingleEventCreditDefaultSwaption_args = new Hashtable();
			CreateSingleEventCreditDefaultSwaption_args.Add("ProductName", ProductName);
			CreateSingleEventCreditDefaultSwaption_args.Add("CreditEntity", CreditEntity);
			CreateSingleEventCreditDefaultSwaption_args.Add("Expiry", Expiry);
			CreateSingleEventCreditDefaultSwaption_args.Add("Maturity", Maturity);
			CreateSingleEventCreditDefaultSwaption_args.Add("Notional", Notional);
			CreateSingleEventCreditDefaultSwaption_args.Add("Currency", Currency);
			CreateSingleEventCreditDefaultSwaption_args.Add("Strike", Strike);
			CreateSingleEventCreditDefaultSwaption_args.Add("Payoff", Payoff);
			CreateSingleEventCreditDefaultSwaption_args.Add("BuySell", BuySell);
			CreateSingleEventCreditDefaultSwaption_args.Add("PremiumLegMarketConvention", PremiumLegMarketConvention);
			CreateSingleEventCreditDefaultSwaption_args.Add("ProtectionLegMarketConvention", ProtectionLegMarketConvention);
			CreateSingleEventCreditDefaultSwaption_args.Add("PayAccrued", PayAccrued);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditDefaultSwaption", CreateSingleEventCreditDefaultSwaption_args);
		}

		// <summary>
		// Create a single-name credit default unity index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of the credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSingleEventCreditDefaultUnityIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateSingleEventCreditDefaultUnityIndex_args = new Hashtable();
			CreateSingleEventCreditDefaultUnityIndex_args.Add("IndexName", IndexName);
			CreateSingleEventCreditDefaultUnityIndex_args.Add("CreditContract", CreditContract);
			CreateSingleEventCreditDefaultUnityIndex_args.Add("Currency", Currency);
			CreateSingleEventCreditDefaultUnityIndex_args.Add("MarketConventions", MarketConventions);
			CreateSingleEventCreditDefaultUnityIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditDefaultUnityIndex", CreateSingleEventCreditDefaultUnityIndex_args);
		}

		// <summary>
		// Create a single-name credit survival index.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="CreditContract">Definition of the credit event and other details.</param>
		// <param name="Currency">Currency underlying the index.</param>
		// <param name="MarketConventions">Market conventions for the index.</param>
		// <param name="FixingReferencer">Index referencer.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSingleEventCreditSurvivalIndex(object IndexName, object CreditContract, object Currency, object MarketConventions, object FixingReferencer)
		{

			Hashtable CreateSingleEventCreditSurvivalIndex_args = new Hashtable();
			CreateSingleEventCreditSurvivalIndex_args.Add("IndexName", IndexName);
			CreateSingleEventCreditSurvivalIndex_args.Add("CreditContract", CreditContract);
			CreateSingleEventCreditSurvivalIndex_args.Add("Currency", Currency);
			CreateSingleEventCreditSurvivalIndex_args.Add("MarketConventions", MarketConventions);
			CreateSingleEventCreditSurvivalIndex_args.Add("FixingReferencer", FixingReferencer);
			return F3Formatter.f3_style_serialization("CreateSingleEventCreditSurvivalIndex", CreateSingleEventCreditSurvivalIndex_args);
		}

		// <summary>
		// Create a closed-form valuation specification for the one-factor Hull-White model.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="IntegrationMethod">Integration method to be used for the integral of the short rate volatility.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSingleFactorHullWhiteClosedFormValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object IntegrationMethod)
		{

			Hashtable CreateSingleFactorHullWhiteClosedFormValuationSpecification_args = new Hashtable();
			CreateSingleFactorHullWhiteClosedFormValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSingleFactorHullWhiteClosedFormValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSingleFactorHullWhiteClosedFormValuationSpecification_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("CreateSingleFactorHullWhiteClosedFormValuationSpecification", CreateSingleFactorHullWhiteClosedFormValuationSpecification_args);
		}

		// <summary>
		// Define a contract written on a single credit asset-backed entity.
		// </summary>
		// <param name="Name">Name to use for the credit asset-backed security contract.</param>
		// <param name="CreditEntity">The credit asset-backed entity on which the contract is written.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateSingleNameCreditAssetBackedSecurityContract(object Name, object CreditEntity)
		{

			Hashtable CreateSingleNameCreditAssetBackedSecurityContract_args = new Hashtable();
			CreateSingleNameCreditAssetBackedSecurityContract_args.Add("Name", Name);
			CreateSingleNameCreditAssetBackedSecurityContract_args.Add("CreditEntity", CreditEntity);
			return F3Formatter.f3_style_serialization("CreateSingleNameCreditAssetBackedSecurityContract", CreateSingleNameCreditAssetBackedSecurityContract_args);
		}

		// <summary>
		// Define a contract written on a single credit entity.
		// </summary>
		// <param name="Name">Name to use for the credit contract.</param>
		// <param name="CreditEntity">The credit entity on which the contract is written.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateSingleNameCreditContract(object Name, object CreditEntity)
		{

			Hashtable CreateSingleNameCreditContract_args = new Hashtable();
			CreateSingleNameCreditContract_args.Add("Name", Name);
			CreateSingleNameCreditContract_args.Add("CreditEntity", CreditEntity);
			return F3Formatter.f3_style_serialization("CreateSingleNameCreditContract", CreateSingleNameCreditContract_args);
		}

		// <summary>
		// Define a contract written on a single credit loan-only entity.
		// </summary>
		// <param name="Name">Name to use for the credit loan-only contract.</param>
		// <param name="CreditEntity">The credit loan-only entity on which the contract is written.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateSingleNameCreditLoanOnlyContract(object Name, object CreditEntity)
		{

			Hashtable CreateSingleNameCreditLoanOnlyContract_args = new Hashtable();
			CreateSingleNameCreditLoanOnlyContract_args.Add("Name", Name);
			CreateSingleNameCreditLoanOnlyContract_args.Add("CreditEntity", CreditEntity);
			return F3Formatter.f3_style_serialization("CreateSingleNameCreditLoanOnlyContract", CreateSingleNameCreditLoanOnlyContract_args);
		}

		// <summary>
		// Create a calibration target for a single parameter calibration.
		// </summary>
		// <param name="CalibrationTargetName">Name to use for calibration target.</param>
		// <param name="CurveTag">Target curve tag.</param>
		// <param name="InitialValue">Initial value for parameter. Default value: 0.01.</param>
		// <param name="UseGhosts">Flag indicating whether to use ghost curves. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationTarget.</returns>
		public object CreateSingleParameterCalibrationTarget(object CalibrationTargetName, object CurveTag, object InitialValue, object UseGhosts)
		{

			Hashtable CreateSingleParameterCalibrationTarget_args = new Hashtable();
			CreateSingleParameterCalibrationTarget_args.Add("CalibrationTargetName", CalibrationTargetName);
			CreateSingleParameterCalibrationTarget_args.Add("CurveTag", CurveTag);
			CreateSingleParameterCalibrationTarget_args.Add("InitialValue", InitialValue);
			CreateSingleParameterCalibrationTarget_args.Add("UseGhosts", UseGhosts);
			return F3Formatter.f3_style_serialization("CreateSingleParameterCalibrationTarget", CreateSingleParameterCalibrationTarget_args);
		}

		// <summary>
		// Create a sequencing strategy with a single approximating product.
		// </summary>
		// <param name="StrategyName">Name to use for the created strategy.</param>
		// <param name="RelevantDates">Relevant dates of the approximating product.</param>
		// <returns>Retuns the name of the constructed object of type ProductSequencingStrategy.</returns>
		public object CreateSingleProductSequencingStrategy(object StrategyName, object RelevantDates)
		{

			Hashtable CreateSingleProductSequencingStrategy_args = new Hashtable();
			CreateSingleProductSequencingStrategy_args.Add("StrategyName", StrategyName);
			CreateSingleProductSequencingStrategy_args.Add("RelevantDates", RelevantDates);
			return F3Formatter.f3_style_serialization("CreateSingleProductSequencingStrategy", CreateSingleProductSequencingStrategy_args);
		}

		// <summary>
		// Create a state variable template that can specify the explanatory variables             in trigger replacement.
		// </summary>
		// <param name="StateVariableTemplateName">Name to use for the new state variable template.</param>
		// <param name="Underlying">The underlying state variable template.</param>
		// <param name="ExplanatoryIndices">A list of indices to use as explanatory variables. Default value: default-constructed instance of type indices.</param>
		// <param name="ExplanatoryInstruments">A list of instruments to use as explanatory variables. Default value: default-constructed instance of type instruments.</param>
		// <param name="AddChoiceSpecificZeros">A flag indicating whether or not to include zero-coupon bonds maturing at trade-specific dates. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type StateVariables.</returns>
		public object CreateSingleRateExplanatoryVariablesStateVariableTemplate(object StateVariableTemplateName, object Underlying, object ExplanatoryIndices, object ExplanatoryInstruments, object AddChoiceSpecificZeros)
		{

			Hashtable CreateSingleRateExplanatoryVariablesStateVariableTemplate_args = new Hashtable();
			CreateSingleRateExplanatoryVariablesStateVariableTemplate_args.Add("StateVariableTemplateName", StateVariableTemplateName);
			CreateSingleRateExplanatoryVariablesStateVariableTemplate_args.Add("Underlying", Underlying);
			CreateSingleRateExplanatoryVariablesStateVariableTemplate_args.Add("ExplanatoryIndices", ExplanatoryIndices);
			CreateSingleRateExplanatoryVariablesStateVariableTemplate_args.Add("ExplanatoryInstruments", ExplanatoryInstruments);
			CreateSingleRateExplanatoryVariablesStateVariableTemplate_args.Add("AddChoiceSpecificZeros", AddChoiceSpecificZeros);
			return F3Formatter.f3_style_serialization("CreateSingleRateExplanatoryVariablesStateVariableTemplate", CreateSingleRateExplanatoryVariablesStateVariableTemplate_args);
		}

		// <summary>
		// Create a valuation specification for numeric calculations of a single discounting rate.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Currency">Currency to use as the numeraire, or valuation, currency.</param>
		// <param name="NamedIndices">Named indices.</param>
		// <param name="StateVariableTemplate">State variable template type for modeling discount rates.</param>
		// <param name="Generator">Base generator to use in simulation computations.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="Iterations">Iteration control. Default value: 1023.</param>
		// <param name="AuxiliaryIterations">Iteration control for auxiliary simulation. Default value: default-constructed instance of type computation_specification.</param>
		// <param name="NamedSimFuncTemplates">Named simulation function templates. Default value: default-constructed instance of type sim_function_template_map.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSingleRateSimulationValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Currency, object NamedIndices, object StateVariableTemplate, object Generator, object CalculationMethod, object Iterations, object AuxiliaryIterations, object NamedSimFuncTemplates)
		{

			Hashtable CreateSingleRateSimulationValuationSpecification_args = new Hashtable();
			CreateSingleRateSimulationValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSingleRateSimulationValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSingleRateSimulationValuationSpecification_args.Add("Currency", Currency);
			CreateSingleRateSimulationValuationSpecification_args.Add("NamedIndices", NamedIndices);
			CreateSingleRateSimulationValuationSpecification_args.Add("StateVariableTemplate", StateVariableTemplate);
			CreateSingleRateSimulationValuationSpecification_args.Add("Generator", Generator);
			CreateSingleRateSimulationValuationSpecification_args.Add("CalculationMethod", CalculationMethod);
			CreateSingleRateSimulationValuationSpecification_args.Add("Iterations", Iterations);
			CreateSingleRateSimulationValuationSpecification_args.Add("AuxiliaryIterations", AuxiliaryIterations);
			CreateSingleRateSimulationValuationSpecification_args.Add("NamedSimFuncTemplates", NamedSimFuncTemplates);
			return F3Formatter.f3_style_serialization("CreateSingleRateSimulationValuationSpecification", CreateSingleRateSimulationValuationSpecification_args);
		}

		// <summary>
		// Create a market convention that only generates schedules with a single roll from an underlying convention.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateSingleRollMarketConvention(object MarketConventionName, object UnderlyingConventions)
		{

			Hashtable CreateSingleRollMarketConvention_args = new Hashtable();
			CreateSingleRollMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateSingleRollMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			return F3Formatter.f3_style_serialization("CreateSingleRollMarketConvention", CreateSingleRollMarketConvention_args);
		}

		// <summary>
		// Define a futures contract type for a futures contract whose underlying is the individual stock of a company.
		// </summary>
		// <param name="ContractTypeName">Name to use for the futures contract type.</param>
		// <param name="ContractSize">The number of shares of the underlying stock in one futures contract.</param>
		// <param name="MaturityCalculator">Maturity calculator used to determine the expiry date of the futures contract.</param>
		// <param name="UniqueID">Optional string used to generate the unique name of the fixings curve associated with the futures index. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type FuturesContractType.</returns>
		public object CreateSingleStockFuturesContractType(object ContractTypeName, object ContractSize, object MaturityCalculator, object UniqueID)
		{

			Hashtable CreateSingleStockFuturesContractType_args = new Hashtable();
			CreateSingleStockFuturesContractType_args.Add("ContractTypeName", ContractTypeName);
			CreateSingleStockFuturesContractType_args.Add("ContractSize", ContractSize);
			CreateSingleStockFuturesContractType_args.Add("MaturityCalculator", MaturityCalculator);
			CreateSingleStockFuturesContractType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateSingleStockFuturesContractType", CreateSingleStockFuturesContractType_args);
		}

		// <summary>
		// Create a single tranche collateralized debt obligation.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure.</param>
		// <param name="Currency">Currency.</param>
		// <param name="TrancheContract">A tranche contract.</param>
		// <param name="Premium">The premium paid on each roll of the premium leg.</param>
		// <param name="UpfrontFee">Amount paid upfront.</param>
		// <param name="PayAccruedInterestUponDefault">Pay accrued interest upon default. Default value: true.</param>
		// <param name="MarketConvention">Market conventions.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the premium leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateSingleTrancheCDO(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object TrancheContract, object Premium, object UpfrontFee, object PayAccruedInterestUponDefault, object MarketConvention,
		object PayRec)
		{

			Hashtable CreateSingleTrancheCDO_args = new Hashtable();
			CreateSingleTrancheCDO_args.Add("ProductName", ProductName);
			CreateSingleTrancheCDO_args.Add("StartDate", StartDate);
			CreateSingleTrancheCDO_args.Add("Maturity", Maturity);
			CreateSingleTrancheCDO_args.Add("Notional", Notional);
			CreateSingleTrancheCDO_args.Add("Currency", Currency);
			CreateSingleTrancheCDO_args.Add("TrancheContract", TrancheContract);
			CreateSingleTrancheCDO_args.Add("Premium", Premium);
			CreateSingleTrancheCDO_args.Add("UpfrontFee", UpfrontFee);
			CreateSingleTrancheCDO_args.Add("PayAccruedInterestUponDefault", PayAccruedInterestUponDefault);
			CreateSingleTrancheCDO_args.Add("MarketConvention", MarketConvention);
			CreateSingleTrancheCDO_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateSingleTrancheCDO", CreateSingleTrancheCDO_args);
		}

		// <summary>
		// Create a function that returns the integral over one variable of a two-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Integrand">Two-dimensional function to be integrated.</param>
		// <param name="HoldSecondArgumentConstant">Switch to indicate whether the second argument should be held constant during the integration.</param>
		// <param name="Method">The numerical method to evaluate the integral.</param>
		// <returns>Retuns the name of the constructed object of type ThreeDimensionalFunction.</returns>
		public object CreateSinglyIntegrated2dFunction(object FunctionName, object Integrand, object HoldSecondArgumentConstant, object Method)
		{

			Hashtable CreateSinglyIntegrated2dFunction_args = new Hashtable();
			CreateSinglyIntegrated2dFunction_args.Add("FunctionName", FunctionName);
			CreateSinglyIntegrated2dFunction_args.Add("Integrand", Integrand);
			CreateSinglyIntegrated2dFunction_args.Add("HoldSecondArgumentConstant", HoldSecondArgumentConstant);
			CreateSinglyIntegrated2dFunction_args.Add("Method", Method);
			return F3Formatter.f3_style_serialization("CreateSinglyIntegrated2dFunction", CreateSinglyIntegrated2dFunction_args);
		}

		// <summary>
		// Create a modifier that removes values from both ends of the underlying generator's values.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="FrontCut">Number of leading values to drop. Default value: 0.</param>
		// <param name="EndCut">Number of end values to drop. Default value: 0.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateSliceModifier(object ModifierName, object FrontCut, object EndCut)
		{

			Hashtable CreateSliceModifier_args = new Hashtable();
			CreateSliceModifier_args.Add("ModifierName", ModifierName);
			CreateSliceModifier_args.Add("FrontCut", FrontCut);
			CreateSliceModifier_args.Add("EndCut", EndCut);
			return F3Formatter.f3_style_serialization("CreateSliceModifier", CreateSliceModifier_args);
		}

		// <summary>
		// Create a one-dimensional slice of a two-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="TwoDimFunction">Two-dimensional function to slice.</param>
		// <param name="ValueOfConstantArgument">Value of the constant argument.</param>
		// <param name="ConstantParameterTag">Tag for the constant parameter.</param>
		// <param name="HoldSecondArgumentConstant">Switch to determine whether or not to hold the second variable constant.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateSliceOf2dFunction(object FunctionName, object TwoDimFunction, object ValueOfConstantArgument, object ConstantParameterTag, object HoldSecondArgumentConstant)
		{

			Hashtable CreateSliceOf2dFunction_args = new Hashtable();
			CreateSliceOf2dFunction_args.Add("FunctionName", FunctionName);
			CreateSliceOf2dFunction_args.Add("TwoDimFunction", TwoDimFunction);
			CreateSliceOf2dFunction_args.Add("ValueOfConstantArgument", ValueOfConstantArgument);
			CreateSliceOf2dFunction_args.Add("ConstantParameterTag", ConstantParameterTag);
			CreateSliceOf2dFunction_args.Add("HoldSecondArgumentConstant", HoldSecondArgumentConstant);
			return F3Formatter.f3_style_serialization("CreateSliceOf2dFunction", CreateSliceOf2dFunction_args);
		}

		// <summary>
		// Create a four-point interpolation function with continuous value, and     first- and second-order derivatives, that connects two arbitrary functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="XValues">Four interpolation points.</param>
		// <param name="LeftFunction">One-dimensional function to be interpolated on the left side.</param>
		// <param name="RightFunction">One-dimensional function to be interpolated on the right side.</param>
		// <param name="XParameterTag">Tag to use for the XValues parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateSmoothFourPointInterpolationFunction(object FunctionName, object XValues, object LeftFunction, object RightFunction, object XParameterTag)
		{

			Hashtable CreateSmoothFourPointInterpolationFunction_args = new Hashtable();
			CreateSmoothFourPointInterpolationFunction_args.Add("FunctionName", FunctionName);
			CreateSmoothFourPointInterpolationFunction_args.Add("XValues", XValues);
			CreateSmoothFourPointInterpolationFunction_args.Add("LeftFunction", LeftFunction);
			CreateSmoothFourPointInterpolationFunction_args.Add("RightFunction", RightFunction);
			CreateSmoothFourPointInterpolationFunction_args.Add("XParameterTag", XParameterTag);
			return F3Formatter.f3_style_serialization("CreateSmoothFourPointInterpolationFunction", CreateSmoothFourPointInterpolationFunction_args);
		}

		// <summary>
		// Create a backward evolution operator for determining whether an input is less than another input.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="SmoothingParameter">Value of the smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateSmoothedIsLessThanOperator(object OperatorName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable CreateSmoothedIsLessThanOperator_args = new Hashtable();
			CreateSmoothedIsLessThanOperator_args.Add("OperatorName", OperatorName);
			CreateSmoothedIsLessThanOperator_args.Add("SmoothingParameter", SmoothingParameter);
			CreateSmoothedIsLessThanOperator_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreateSmoothedIsLessThanOperator", CreateSmoothedIsLessThanOperator_args);
		}

		// <summary>
		// Create a backward evolution operator for evaluating the smoothed maximum of one or more ladders.
		// </summary>
		// <param name="OperatorName">Name to use for the new operator.</param>
		// <param name="SmoothingParameter">Value of the smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type OperatorSource.</returns>
		public object CreateSmoothedMaximumOperator(object OperatorName, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable CreateSmoothedMaximumOperator_args = new Hashtable();
			CreateSmoothedMaximumOperator_args.Add("OperatorName", OperatorName);
			CreateSmoothedMaximumOperator_args.Add("SmoothingParameter", SmoothingParameter);
			CreateSmoothedMaximumOperator_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreateSmoothedMaximumOperator", CreateSmoothedMaximumOperator_args);
		}

		// <summary>
		// Create a valuation specification with a smoothing parameter.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="SmoothingParameter">The smoothing parameter.</param>
		// <param name="SmoothingParameterTag">Tag to use for the smoothing parameter.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateSmoothingParameterValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object SmoothingParameter, object SmoothingParameterTag)
		{

			Hashtable CreateSmoothingParameterValuationSpecification_args = new Hashtable();
			CreateSmoothingParameterValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateSmoothingParameterValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateSmoothingParameterValuationSpecification_args.Add("SmoothingParameter", SmoothingParameter);
			CreateSmoothingParameterValuationSpecification_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreateSmoothingParameterValuationSpecification", CreateSmoothingParameterValuationSpecification_args);
		}

		// <summary>
		// Create a sort value modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="NumberOfElementsToSkip">Number of elements at the beginning of the state variable to omit from the sort.</param>
		// <param name="LengthOfRangeToBeSorted">Length of the range to be sorted.</param>
		// <param name="NumberOfValuesToReturn">Returns a partial set of the sorted list. Default value: 0.</param>
		// <param name="SmoothingParameterValue">Smoothing parameter value.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter tag.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateSortMatrixModifier(object ModifierName, object NumberOfElementsToSkip, object LengthOfRangeToBeSorted, object NumberOfValuesToReturn, object SmoothingParameterValue, object SmoothingParameterTag)
		{

			Hashtable CreateSortMatrixModifier_args = new Hashtable();
			CreateSortMatrixModifier_args.Add("ModifierName", ModifierName);
			CreateSortMatrixModifier_args.Add("NumberOfElementsToSkip", NumberOfElementsToSkip);
			CreateSortMatrixModifier_args.Add("LengthOfRangeToBeSorted", LengthOfRangeToBeSorted);
			CreateSortMatrixModifier_args.Add("NumberOfValuesToReturn", NumberOfValuesToReturn);
			CreateSortMatrixModifier_args.Add("SmoothingParameterValue", SmoothingParameterValue);
			CreateSortMatrixModifier_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("CreateSortMatrixModifier", CreateSortMatrixModifier_args);
		}

		// <summary>
		// Create a standard yield convention for fixed coupon or floating rate note bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for measuring the period from the settlement date to the next payment date.</param>
		// <param name="AccrueWholeCoupon">Accrue a whole regular first period when the settlement is a roll start date. Default value: true.</param>
		// <param name="SimpleInLast">Use simple yield for settlement dates in the last payment period. Default value: true.</param>
		// <param name="CompoundingFrequency">The compounding type. Default value: Natural.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateStandardYieldConvention(object YieldConventionName, object AccrualConvention, object AccrueWholeCoupon, object SimpleInLast, object CompoundingFrequency)
		{

			Hashtable CreateStandardYieldConvention_args = new Hashtable();
			CreateStandardYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateStandardYieldConvention_args.Add("AccrualConvention", AccrualConvention);
			CreateStandardYieldConvention_args.Add("AccrueWholeCoupon", AccrueWholeCoupon);
			CreateStandardYieldConvention_args.Add("SimpleInLast", SimpleInLast);
			CreateStandardYieldConvention_args.Add("CompoundingFrequency", CompoundingFrequency);
			return F3Formatter.f3_style_serialization("CreateStandardYieldConvention", CreateStandardYieldConvention_args);
		}

		// <summary>
		// Create a date modifier that performs the trade-to-start date action on a given date.
		// </summary>
		// <param name="DateModifierName">Name to use for the modifier.</param>
		// <param name="MarketConventions">Market conventions for trade-start date relationship.</param>
		// <returns>Retuns the name of the constructed object of type DateModifier.</returns>
		public object CreateStartDateModifier(object DateModifierName, object MarketConventions)
		{

			Hashtable CreateStartDateModifier_args = new Hashtable();
			CreateStartDateModifier_args.Add("DateModifierName", DateModifierName);
			CreateStartDateModifier_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateStartDateModifier", CreateStartDateModifier_args);
		}

		// <summary>
		// Create the modifier corresponding to a given state variable template.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Index">The index to be simulated.</param>
		// <param name="StateVariableTemplate">The state variable template.</param>
		// <param name="ObservationTimes">The list of times at which the state variables are to be observed.</param>
		// <param name="Model">A model containing the curves required to form the modifier.</param>
		// <param name="ValuationMethod">Specification of any further details of the calculation. Default value: Default.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateStateVariableModifier(object ModifierName, object Index, object StateVariableTemplate, object ObservationTimes, object Model, object ValuationMethod)
		{

			Hashtable CreateStateVariableModifier_args = new Hashtable();
			CreateStateVariableModifier_args.Add("ModifierName", ModifierName);
			CreateStateVariableModifier_args.Add("Index", Index);
			CreateStateVariableModifier_args.Add("StateVariableTemplate", StateVariableTemplate);
			CreateStateVariableModifier_args.Add("ObservationTimes", ObservationTimes);
			CreateStateVariableModifier_args.Add("Model", Model);
			CreateStateVariableModifier_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("CreateStateVariableModifier", CreateStateVariableModifier_args);
		}

		// <summary>
		// Create an index representing a step function.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="StepInTime">The step-in time.</param>
		// <param name="AtNotAfter">Step in at the step-in time, not just after. Default value: true.</param>
		// <param name="Referencer">Index referencer to use.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateStepInIndex(object IndexName, object StepInTime, object AtNotAfter, object Referencer)
		{

			Hashtable CreateStepInIndex_args = new Hashtable();
			CreateStepInIndex_args.Add("IndexName", IndexName);
			CreateStepInIndex_args.Add("StepInTime", StepInTime);
			CreateStepInIndex_args.Add("AtNotAfter", AtNotAfter);
			CreateStepInIndex_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateStepInIndex", CreateStepInIndex_args);
		}

		// <summary>
		// Create an accumulator that outputs paths to a stream.
		// </summary>
		// <param name="Name">Name to use for new accumulator.</param>
		// <param name="OutputTarget">Stream-based resource to send output.</param>
		// <param name="Separator">String which separates different numbers in the output. Default value: ,.</param>
		// <returns>Retuns the name of the constructed object of type AccumulatorSource.</returns>
		public object CreateStreamOutputPathAccumulator(object Name, object OutputTarget, object Separator)
		{

			Hashtable CreateStreamOutputPathAccumulator_args = new Hashtable();
			CreateStreamOutputPathAccumulator_args.Add("Name", Name);
			CreateStreamOutputPathAccumulator_args.Add("OutputTarget", OutputTarget);
			CreateStreamOutputPathAccumulator_args.Add("Separator", Separator);
			return F3Formatter.f3_style_serialization("CreateStreamOutputPathAccumulator", CreateStreamOutputPathAccumulator_args);
		}

		// <summary>
		// Create a market convention that renders any stub periods in the underlying market convention schedule as full periods.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateStubFreeMarketConvention(object MarketConventionName, object UnderlyingConventions)
		{

			Hashtable CreateStubFreeMarketConvention_args = new Hashtable();
			CreateStubFreeMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateStubFreeMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			return F3Formatter.f3_style_serialization("CreateStubFreeMarketConvention", CreateStubFreeMarketConvention_args);
		}

		// <summary>
		// Create an index whose value is the weighted sum of underlying indices.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="ConstituentIndices">Vector of indices.</param>
		// <param name="IndexWeights">Optional vector of index weights. Default value: default-constructed instance of type vector.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSummationIndex(object IndexName, object ConstituentIndices, object IndexWeights)
		{

			Hashtable CreateSummationIndex_args = new Hashtable();
			CreateSummationIndex_args.Add("IndexName", IndexName);
			CreateSummationIndex_args.Add("ConstituentIndices", ConstituentIndices);
			CreateSummationIndex_args.Add("IndexWeights", IndexWeights);
			return F3Formatter.f3_style_serialization("CreateSummationIndex", CreateSummationIndex_args);
		}

		// <summary>
		// Create a convexity adjustment function for swap futures based on the Hull-White single-factor short-rate model.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="MeanReversion">Factor scaling the mean reversion.</param>
		// <param name="HWVolatilityFunction">Function that returns the variance of change in short rate over time interval.</param>
		// <param name="DiscountFactorFunction">Function that returns the discount factor for a time interval.</param>
		// <param name="SwapLength">Length of the underlying swap as fraction of a year.</param>
		// <param name="FloatingCouponLength">Coupon length of the floating payments.</param>
		// <returns>Retuns the name of the constructed object of type ConvexityAdjustmentFunction.</returns>
		public object CreateSwapFuturesHullWhiteConvexityAdjustmentFunction(object FunctionName, object MeanReversion, object HWVolatilityFunction, object DiscountFactorFunction, object SwapLength, object FloatingCouponLength)
		{

			Hashtable CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args = new Hashtable();
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("FunctionName", FunctionName);
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("MeanReversion", MeanReversion);
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("HWVolatilityFunction", HWVolatilityFunction);
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("DiscountFactorFunction", DiscountFactorFunction);
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("SwapLength", SwapLength);
			CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args.Add("FloatingCouponLength", FloatingCouponLength);
			return F3Formatter.f3_style_serialization("CreateSwapFuturesHullWhiteConvexityAdjustmentFunction", CreateSwapFuturesHullWhiteConvexityAdjustmentFunction_args);
		}

		// <summary>
		// Create a swap length calculator given a set of market conventions.
		// </summary>
		// <param name="SwapLengthCalculatorName">Name to use for swap calculator.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <returns>Retuns the name of the constructed object of type LengthCalculator.</returns>
		public object CreateSwapLengthCalculator(object SwapLengthCalculatorName, object MarketConventions)
		{

			Hashtable CreateSwapLengthCalculator_args = new Hashtable();
			CreateSwapLengthCalculator_args.Add("SwapLengthCalculatorName", SwapLengthCalculatorName);
			CreateSwapLengthCalculator_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("CreateSwapLengthCalculator", CreateSwapLengthCalculator_args);
		}

		// <summary>
		// Create a market convention encapsulating settlement parameters for a simple swap.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="MaturityCalculator">Swap maturity calculator.</param>
		// <param name="SettlementMaturityDescriptor">Maturity descriptor relating trade to settlement date.</param>
		// <param name="RollLength">Length of coupon period in months.</param>
		// <param name="DayCountConvention">Day count convention.</param>
		// <param name="RollDayModifier">Date modifier applied to all roll end dates, excluding the trade maturity date.</param>
		// <param name="StubType">Stub type. Default value: StubAtStart.</param>
		// <param name="MonthEndMethod">Input specifying how to augment schedule generation when the schedule end date falls on the month end. Default value: NoAdjustment.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateSwapMarketConvention(object MarketConventionName, object MaturityCalculator, object SettlementMaturityDescriptor, object RollLength, object DayCountConvention, object RollDayModifier, object StubType, object MonthEndMethod)
		{

			Hashtable CreateSwapMarketConvention_args = new Hashtable();
			CreateSwapMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateSwapMarketConvention_args.Add("MaturityCalculator", MaturityCalculator);
			CreateSwapMarketConvention_args.Add("SettlementMaturityDescriptor", SettlementMaturityDescriptor);
			CreateSwapMarketConvention_args.Add("RollLength", RollLength);
			CreateSwapMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			CreateSwapMarketConvention_args.Add("RollDayModifier", RollDayModifier);
			CreateSwapMarketConvention_args.Add("StubType", StubType);
			CreateSwapMarketConvention_args.Add("MonthEndMethod", MonthEndMethod);
			return F3Formatter.f3_style_serialization("CreateSwapMarketConvention", CreateSwapMarketConvention_args);
		}

		// <summary>
		// Construct an index representing the non-par value of a swap at its start date.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="SwapMaturity">Swap maturity.</param>
		// <param name="Currency">Currency of the swap.</param>
		// <param name="FixedCoupon">Coupon rate of the fixed leg.</param>
		// <param name="FixedLegMarketConvention">Market convention of the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConvention">Market convention of the floating leg.</param>
		// <param name="OptionalFixingTableName">Optional name for the fixings table associated with the index. Default value: default-constructed instance of type fixings_name.</param>
		// <param name="CollateralAgreement">Collateral agreement for the underlying swap. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSwapNonParValueIndex(object IndexName, object SwapMaturity, object Currency, object FixedCoupon, object FixedLegMarketConvention, object FloatingRateIndex, object FloatingLegMarketConvention, object OptionalFixingTableName, object CollateralAgreement)
		{

			Hashtable CreateSwapNonParValueIndex_args = new Hashtable();
			CreateSwapNonParValueIndex_args.Add("IndexName", IndexName);
			CreateSwapNonParValueIndex_args.Add("SwapMaturity", SwapMaturity);
			CreateSwapNonParValueIndex_args.Add("Currency", Currency);
			CreateSwapNonParValueIndex_args.Add("FixedCoupon", FixedCoupon);
			CreateSwapNonParValueIndex_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateSwapNonParValueIndex_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateSwapNonParValueIndex_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateSwapNonParValueIndex_args.Add("OptionalFixingTableName", OptionalFixingTableName);
			CreateSwapNonParValueIndex_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateSwapNonParValueIndex", CreateSwapNonParValueIndex_args);
		}

		// <summary>
		// Construct an index representing a swap rate.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="SwapMaturity">Swap rate maturity.</param>
		// <param name="Currency">Currency underlying swap rate.</param>
		// <param name="FixedLegConventions">Market conventions of the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegConventions">Market conventions of the floating leg.</param>
		// <param name="OptionalFixingTableName">Optional name for the fixings table associated with the index. Default value: default-constructed instance of type fixings_name.</param>
		// <param name="OptionalSwapRateCurveName">Optional name for the curve associated with the index. Default value: default-constructed instance of type curve_name.</param>
		// <param name="CollateralAgreement">Collateral agreement for the underlying swap. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateSwapRateIndex(object IndexName, object SwapMaturity, object Currency, object FixedLegConventions, object FloatingRateIndex, object FloatingLegConventions, object OptionalFixingTableName, object OptionalSwapRateCurveName, object CollateralAgreement)
		{

			Hashtable CreateSwapRateIndex_args = new Hashtable();
			CreateSwapRateIndex_args.Add("IndexName", IndexName);
			CreateSwapRateIndex_args.Add("SwapMaturity", SwapMaturity);
			CreateSwapRateIndex_args.Add("Currency", Currency);
			CreateSwapRateIndex_args.Add("FixedLegConventions", FixedLegConventions);
			CreateSwapRateIndex_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateSwapRateIndex_args.Add("FloatingLegConventions", FloatingLegConventions);
			CreateSwapRateIndex_args.Add("OptionalFixingTableName", OptionalFixingTableName);
			CreateSwapRateIndex_args.Add("OptionalSwapRateCurveName", OptionalSwapRateCurveName);
			CreateSwapRateIndex_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateSwapRateIndex", CreateSwapRateIndex_args);
		}

		// <summary>
		// Create a one-dimensional function representing the value of a swap PVBP leg as a function of par rate.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="RollSchedule">Roll schedule of swap PVBP leg.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateSwapRatePVBPFunction(object FunctionName, object RollSchedule)
		{

			Hashtable CreateSwapRatePVBPFunction_args = new Hashtable();
			CreateSwapRatePVBPFunction_args.Add("FunctionName", FunctionName);
			CreateSwapRatePVBPFunction_args.Add("RollSchedule", RollSchedule);
			return F3Formatter.f3_style_serialization("CreateSwapRatePVBPFunction", CreateSwapRatePVBPFunction_args);
		}

		// <summary>
		// Create a swaption instrument strategy for a given value of underlying swap length.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="SwapLength">Underlying swap length.</param>
		// <param name="Expiries">Vector of swaption expiries.</param>
		// <param name="Strikes">Vector of swaption strikes.</param>
		// <param name="Payoff">Payoff of swaptions.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="RateIndex">Index describing the LIBOR rate.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="CollateralAgreement">Agreement under which the quoted instruments are collateralized. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateSwaptionFixedTenorInstrumentStrategyCollection(object StrategyName, object SwapLength, object Expiries, object Strikes, object Payoff, object FixedLegMarketConvention, object RateIndex, object FloatingLegMarketConvention, object CollateralAgreement)
		{

			Hashtable CreateSwaptionFixedTenorInstrumentStrategyCollection_args = new Hashtable();
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("StrategyName", StrategyName);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("SwapLength", SwapLength);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("Expiries", Expiries);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("Strikes", Strikes);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("Payoff", Payoff);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("RateIndex", RateIndex);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateSwaptionFixedTenorInstrumentStrategyCollection_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateSwaptionFixedTenorInstrumentStrategyCollection", CreateSwaptionFixedTenorInstrumentStrategyCollection_args);
		}

		// <summary>
		// Create a swaption strategy collection for a given underlying tenor, using the quotes contained in the market data sets and skipping any invalid quotes.
		// </summary>
		// <param name="StrategyName">Name to use for the strategy.</param>
		// <param name="MarketSets">All market data sets containing swaption quotes.</param>
		// <param name="SwapLength">Underlying swap length.</param>
		// <param name="MinimalNumberOfInstruments">Ensures that constructed strategies contain a minimum number of instruments. Default value: 1.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData(object StrategyName, object MarketSets, object SwapLength, object MinimalNumberOfInstruments)
		{

			Hashtable CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args = new Hashtable();
			CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args.Add("StrategyName", StrategyName);
			CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args.Add("MarketSets", MarketSets);
			CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args.Add("SwapLength", SwapLength);
			CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args.Add("MinimalNumberOfInstruments", MinimalNumberOfInstruments);
			return F3Formatter.f3_style_serialization("CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData", CreateSwaptionFixedTenorInstrumentStrategyCollectionFromMarketData_args);
		}

		// <summary>
		// Create an instrument strategy given swaption information.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="Expiries">Vector of swaption expiries.</param>
		// <param name="SwapLengths">Vector of underlying swap lengths.</param>
		// <param name="Strikes">Vector of swaption strikes.</param>
		// <param name="Payoffs">Payoffs of swaptions.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="CollateralAgreement">Agreement under which the quoted instruments are collateralized. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateSwaptionInstrumentStrategy(object StrategyName, object Expiries, object SwapLengths, object Strikes, object Payoffs, object FixedLegMarketConvention, object FloatingRateIndex, object FloatingLegMarketConvention, object CollateralAgreement)
		{

			Hashtable CreateSwaptionInstrumentStrategy_args = new Hashtable();
			CreateSwaptionInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateSwaptionInstrumentStrategy_args.Add("Expiries", Expiries);
			CreateSwaptionInstrumentStrategy_args.Add("SwapLengths", SwapLengths);
			CreateSwaptionInstrumentStrategy_args.Add("Strikes", Strikes);
			CreateSwaptionInstrumentStrategy_args.Add("Payoffs", Payoffs);
			CreateSwaptionInstrumentStrategy_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateSwaptionInstrumentStrategy_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateSwaptionInstrumentStrategy_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateSwaptionInstrumentStrategy_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateSwaptionInstrumentStrategy", CreateSwaptionInstrumentStrategy_args);
		}

		// <summary>
		// Create an instrument type for interest rate swaptions.
		// </summary>
		// <param name="InstrumentTypeName">Name       of the instrument type.</param>
		// <param name="FixedLegMarketConventions">Market conventions for       the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <param name="Payoff">Payoff for the option. Default value: straddle.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateSwaptionInstrumentType(object InstrumentTypeName, object FixedLegMarketConventions, object FloatingRateIndex, object FloatingLegMarketConventions, object Payoff)
		{

			Hashtable CreateSwaptionInstrumentType_args = new Hashtable();
			CreateSwaptionInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateSwaptionInstrumentType_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateSwaptionInstrumentType_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateSwaptionInstrumentType_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			CreateSwaptionInstrumentType_args.Add("Payoff", Payoff);
			return F3Formatter.f3_style_serialization("CreateSwaptionInstrumentType", CreateSwaptionInstrumentType_args);
		}

		// <summary>
		// Create a swaption instrument strategy.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="Expiries">Longest swaption expiry in the swaption matrix.</param>
		// <param name="SwapLengths">Longest underlying swap length in the swaption matrix.</param>
		// <param name="RateIndex">Index describing the LIBOR rate.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="Strike">Swaption strike.</param>
		// <param name="Payoff">Payoff of swaptions. Default value: Straddle.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="CollateralAgreement">Agreement under which the quoted instruments are collateralized. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateSwaptionMatrixInstrumentStrategy(object StrategyName, object Expiries, object SwapLengths, object RateIndex, object FixedLegMarketConvention, object Strike, object Payoff, object FloatingLegMarketConvention, object CollateralAgreement)
		{

			Hashtable CreateSwaptionMatrixInstrumentStrategy_args = new Hashtable();
			CreateSwaptionMatrixInstrumentStrategy_args.Add("StrategyName", StrategyName);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("Expiries", Expiries);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("SwapLengths", SwapLengths);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("RateIndex", RateIndex);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("Strike", Strike);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("Payoff", Payoff);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateSwaptionMatrixInstrumentStrategy_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateSwaptionMatrixInstrumentStrategy", CreateSwaptionMatrixInstrumentStrategy_args);
		}

		// <summary>
		// Create a swaption instrument strategy.
		// </summary>
		// <param name="StrategyName">Name to use for the instrument strategy.</param>
		// <param name="LongestExpiry">Longest swaption expiry in the swaption matrix.</param>
		// <param name="LongestSwapLength">Longest underlying swap length in the swaption matrix.</param>
		// <param name="RateIndex">Index describing the LIBOR rate.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="Strike">Swaption strike.</param>
		// <param name="Payoff">Payoff of swaptions. Default value: Straddle.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentStrategy.</returns>
		public object CreateSwaptionMatrixOuterProductStrategy(object StrategyName, object LongestExpiry, object LongestSwapLength, object RateIndex, object FixedLegMarketConvention, object Strike, object Payoff, object FloatingLegMarketConvention)
		{

			Hashtable CreateSwaptionMatrixOuterProductStrategy_args = new Hashtable();
			CreateSwaptionMatrixOuterProductStrategy_args.Add("StrategyName", StrategyName);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("LongestExpiry", LongestExpiry);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("LongestSwapLength", LongestSwapLength);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("RateIndex", RateIndex);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("Strike", Strike);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("Payoff", Payoff);
			CreateSwaptionMatrixOuterProductStrategy_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			return F3Formatter.f3_style_serialization("CreateSwaptionMatrixOuterProductStrategy", CreateSwaptionMatrixOuterProductStrategy_args);
		}

		// <summary>
		// Create a symmetric multiple modifier.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Modifiers">List of modifiers to use to form symmetric multiple modifier.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object CreateSymmetricMultipleModifier(object ModifierName, object Modifiers)
		{

			Hashtable CreateSymmetricMultipleModifier_args = new Hashtable();
			CreateSymmetricMultipleModifier_args.Add("ModifierName", ModifierName);
			CreateSymmetricMultipleModifier_args.Add("Modifiers", Modifiers);
			return F3Formatter.f3_style_serialization("CreateSymmetricMultipleModifier", CreateSymmetricMultipleModifier_args);
		}

		// <summary>
		// Construct TCP socket interface to this F3 context.
		// </summary>
		// <param name="SocketName">Name to associate with the socket.</param>
		// <param name="PortNumber">Port number to listen on. Default value: 0.</param>
		// <param name="NumberOfThreads">Number of server threads. Default value: 1.</param>
		// <param name="Cookie">Optional secret cookie to use for the connection.</param>
		// <param name="HeartbeatInterval">Duration of hearbeat interval in milliseconds during network communication. Default value: 60000.</param>
		// <returns>Retuns the name of the constructed object of type SocketConnection.</returns>
		public object CreateTCPSocket(object SocketName, object PortNumber, object NumberOfThreads, object Cookie, object HeartbeatInterval)
		{

			Hashtable CreateTCPSocket_args = new Hashtable();
			CreateTCPSocket_args.Add("SocketName", SocketName);
			CreateTCPSocket_args.Add("PortNumber", PortNumber);
			CreateTCPSocket_args.Add("NumberOfThreads", NumberOfThreads);
			CreateTCPSocket_args.Add("Cookie", Cookie);
			CreateTCPSocket_args.Add("HeartbeatInterval", HeartbeatInterval);
			return F3Formatter.f3_style_serialization("CreateTCPSocket", CreateTCPSocket_args);
		}

		// <summary>
		// Creates a new technical report bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the technical report bibliography entry.</param>
		// <param name="Author">Author to use for the technical report bibliography entry.</param>
		// <param name="Year">Year to use for the technical report bibliography entry.</param>
		// <param name="Title">Title to use for the technical report bibliography entry.</param>
		// <param name="Type">Type to use for the technical report bibliography entry.</param>
		// <param name="Institution">Institution to use for the technical report bibliography entry.</param>
		// <param name="Note">Note to use for the technical report bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateTechnicalReportBibliographyEntry(object Name, object Author, object Year, object Title, object Type, object Institution, object Note)
		{

			Hashtable CreateTechnicalReportBibliographyEntry_args = new Hashtable();
			CreateTechnicalReportBibliographyEntry_args.Add("Name", Name);
			CreateTechnicalReportBibliographyEntry_args.Add("Author", Author);
			CreateTechnicalReportBibliographyEntry_args.Add("Year", Year);
			CreateTechnicalReportBibliographyEntry_args.Add("Title", Title);
			CreateTechnicalReportBibliographyEntry_args.Add("Type", Type);
			CreateTechnicalReportBibliographyEntry_args.Add("Institution", Institution);
			CreateTechnicalReportBibliographyEntry_args.Add("Note", Note);
			return F3Formatter.f3_style_serialization("CreateTechnicalReportBibliographyEntry", CreateTechnicalReportBibliographyEntry_args);
		}

		// <summary>
		// Create a state variable ordering object given a state variable template.
		// </summary>
		// <param name="OrderingName">Name to use for the ordering.</param>
		// <param name="StateVariableTemplate">State variable template to use in simulation.</param>
		// <param name="TimePoints">Simulation time points.</param>
		// <param name="ValuationMethod">Specification of simulation time points used in discretization. Default value: Default.</param>
		// <returns>Retuns the name of the constructed object of type StateVariableOrdering.</returns>
		public object CreateTemplateStateVariableOrdering(object OrderingName, object StateVariableTemplate, object TimePoints, object ValuationMethod)
		{

			Hashtable CreateTemplateStateVariableOrdering_args = new Hashtable();
			CreateTemplateStateVariableOrdering_args.Add("OrderingName", OrderingName);
			CreateTemplateStateVariableOrdering_args.Add("StateVariableTemplate", StateVariableTemplate);
			CreateTemplateStateVariableOrdering_args.Add("TimePoints", TimePoints);
			CreateTemplateStateVariableOrdering_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("CreateTemplateStateVariableOrdering", CreateTemplateStateVariableOrdering_args);
		}

		// <summary>
		// Create a market data set from a collection of terminal correlation matrices at multiple observation dates for a list of underlying indices.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="ObservationMaturities">Observation maturities associated with the correlation matrices.</param>
		// <param name="CorrelationMatrices">Correlation matrices.</param>
		// <param name="UnderlyingIndices">Underlying indices for which the correlation matrices are applied.</param>
		// <param name="MarketDataName">Name to use for the correlation market data.</param>
		// <param name="MarketDataType">Type name for the correlation market data.</param>
		// <param name="MarketConventions">Market conventions for maturities.</param>
		// <param name="Currency">Currency of market data implied canonical correlation products.</param>
		// <param name="CorrelationType">Type of terminal correlation market data. Default value: Lognormal.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateTerminalCorrelationMatricesMarketData(object MarketDataSetName, object ObservationMaturities, object CorrelationMatrices, object UnderlyingIndices, object MarketDataName, object MarketDataType, object MarketConventions, object Currency, object CorrelationType)
		{

			Hashtable CreateTerminalCorrelationMatricesMarketData_args = new Hashtable();
			CreateTerminalCorrelationMatricesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateTerminalCorrelationMatricesMarketData_args.Add("ObservationMaturities", ObservationMaturities);
			CreateTerminalCorrelationMatricesMarketData_args.Add("CorrelationMatrices", CorrelationMatrices);
			CreateTerminalCorrelationMatricesMarketData_args.Add("UnderlyingIndices", UnderlyingIndices);
			CreateTerminalCorrelationMatricesMarketData_args.Add("MarketDataName", MarketDataName);
			CreateTerminalCorrelationMatricesMarketData_args.Add("MarketDataType", MarketDataType);
			CreateTerminalCorrelationMatricesMarketData_args.Add("MarketConventions", MarketConventions);
			CreateTerminalCorrelationMatricesMarketData_args.Add("Currency", Currency);
			CreateTerminalCorrelationMatricesMarketData_args.Add("CorrelationType", CorrelationType);
			return F3Formatter.f3_style_serialization("CreateTerminalCorrelationMatricesMarketData", CreateTerminalCorrelationMatricesMarketData_args);
		}

		// <summary>
		// Create a function that converts times according to a date rule.
		// </summary>
		// <param name="FunctionName">Name to associate with the created function.</param>
		// <param name="BaseTimePoint">Base time point for date to time conversion.</param>
		// <param name="TimeCalculator">Date to time, and converse, calculator.</param>
		// <param name="DateModifier">Date modifier to be applied to the date implied from the input time.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateTimeAdjustmentFunction(object FunctionName, object BaseTimePoint, object TimeCalculator, object DateModifier)
		{

			Hashtable CreateTimeAdjustmentFunction_args = new Hashtable();
			CreateTimeAdjustmentFunction_args.Add("FunctionName", FunctionName);
			CreateTimeAdjustmentFunction_args.Add("BaseTimePoint", BaseTimePoint);
			CreateTimeAdjustmentFunction_args.Add("TimeCalculator", TimeCalculator);
			CreateTimeAdjustmentFunction_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("CreateTimeAdjustmentFunction", CreateTimeAdjustmentFunction_args);
		}

		// <summary>
		// Create a valuation specification that specifies a methodology for calculating time.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="TimeCalculator">The methodology for calculating time.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateTimeCalculatorValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object TimeCalculator)
		{

			Hashtable CreateTimeCalculatorValuationSpecification_args = new Hashtable();
			CreateTimeCalculatorValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateTimeCalculatorValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateTimeCalculatorValuationSpecification_args.Add("TimeCalculator", TimeCalculator);
			return F3Formatter.f3_style_serialization("CreateTimeCalculatorValuationSpecification", CreateTimeCalculatorValuationSpecification_args);
		}

		// <summary>
		// Create an index whose value is the fraction of time that an underlying index lies within a range.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Underlying">Underlying index.</param>
		// <param name="LowerBound">The lower bound of the range.</param>
		// <param name="UpperBound">The upper bound of the range.</param>
		// <param name="ObservationSpec">Specification of when the underlying, lower bound and upper bound are to be observed.</param>
		// <param name="Referencer">Rule for defining the observation period. Default value: UnmodifiedStartEndDatePair.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateTimeFractionWithinRangeIndex(object IndexName, object Underlying, object LowerBound, object UpperBound, object ObservationSpec, object Referencer)
		{

			Hashtable CreateTimeFractionWithinRangeIndex_args = new Hashtable();
			CreateTimeFractionWithinRangeIndex_args.Add("IndexName", IndexName);
			CreateTimeFractionWithinRangeIndex_args.Add("Underlying", Underlying);
			CreateTimeFractionWithinRangeIndex_args.Add("LowerBound", LowerBound);
			CreateTimeFractionWithinRangeIndex_args.Add("UpperBound", UpperBound);
			CreateTimeFractionWithinRangeIndex_args.Add("ObservationSpec", ObservationSpec);
			CreateTimeFractionWithinRangeIndex_args.Add("Referencer", Referencer);
			return F3Formatter.f3_style_serialization("CreateTimeFractionWithinRangeIndex", CreateTimeFractionWithinRangeIndex_args);
		}

		// <summary>
		// Create a time-major state variable ordering object.
		// </summary>
		// <param name="OrderingName">Name to use for the ordering.</param>
		// <param name="NumberOfFactors">Number of factors.</param>
		// <returns>Retuns the name of the constructed object of type StateVariableOrdering.</returns>
		public object CreateTimeMajorStateVariableOrdering(object OrderingName, object NumberOfFactors)
		{

			Hashtable CreateTimeMajorStateVariableOrdering_args = new Hashtable();
			CreateTimeMajorStateVariableOrdering_args.Add("OrderingName", OrderingName);
			CreateTimeMajorStateVariableOrdering_args.Add("NumberOfFactors", NumberOfFactors);
			return F3Formatter.f3_style_serialization("CreateTimeMajorStateVariableOrdering", CreateTimeMajorStateVariableOrdering_args);
		}

		// <summary>
		// Create a total variance interpolation method with an underlying interpolation method.
		// </summary>
		// <param name="MethodName">Name to use for the total variance interpolation method.</param>
		// <param name="UnderlyingInterpolationMethod">Underlying interpolation method.</param>
		// <returns>Retuns the name of the constructed object of type InterpolationBuilder.</returns>
		public object CreateTotalVarianceInterpolationMethod(object MethodName, object UnderlyingInterpolationMethod)
		{

			Hashtable CreateTotalVarianceInterpolationMethod_args = new Hashtable();
			CreateTotalVarianceInterpolationMethod_args.Add("MethodName", MethodName);
			CreateTotalVarianceInterpolationMethod_args.Add("UnderlyingInterpolationMethod", UnderlyingInterpolationMethod);
			return F3Formatter.f3_style_serialization("CreateTotalVarianceInterpolationMethod", CreateTotalVarianceInterpolationMethod_args);
		}

		// <summary>
		// Decorate a product with additional information.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="UnderlyingProduct">The underlying product.</param>
		// <param name="Counterparty">The counterparty. Default value: UnspecifiedCreditEntity.</param>
		// <param name="ExternalReferenceID">The external reference ID. Default value: default-constructed instance of type external_reference_id.</param>
		// <param name="TradingBookID">The trading book ID. Default value: default-constructed instance of type trading_book_id.</param>
		// <param name="FixingsName">Optional ID to use for identifying associated fixings. Default value: UnspecifiedTradeFixingsName.</param>
		// <param name="AdditionalTradeProperties">Additional trade properties used to decorate a trade. Default value: default-constructed instance of type additional_trade_properties.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateTrade(object ProductName, object UnderlyingProduct, object Counterparty, object ExternalReferenceID, object TradingBookID, object FixingsName, object AdditionalTradeProperties)
		{

			Hashtable CreateTrade_args = new Hashtable();
			CreateTrade_args.Add("ProductName", ProductName);
			CreateTrade_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateTrade_args.Add("Counterparty", Counterparty);
			CreateTrade_args.Add("ExternalReferenceID", ExternalReferenceID);
			CreateTrade_args.Add("TradingBookID", TradingBookID);
			CreateTrade_args.Add("FixingsName", FixingsName);
			CreateTrade_args.Add("AdditionalTradeProperties", AdditionalTradeProperties);
			return F3Formatter.f3_style_serialization("CreateTrade", CreateTrade_args);
		}

		// <summary>
		// Define a contract written on a tranche.
		// </summary>
		// <param name="Name">Name to use for the tranche contract.</param>
		// <param name="Constituents">The underlying portfolio on which the tranche contract is written.</param>
		// <param name="AttachmentPoint">The attachment point.</param>
		// <param name="DetachmentPoint">The detachment point.</param>
		// <param name="WriteDownNotionalOnDefault">Switch for whether the tranche notional is written down after defaults.</param>
		// <param name="ContractOnLoss">Switch for whether the tranche contract is based on accumulated losses or defaulted notional.</param>
		// <returns>Retuns the name of the constructed object of type CreditContract.</returns>
		public object CreateTrancheContract(object Name, object Constituents, object AttachmentPoint, object DetachmentPoint, object WriteDownNotionalOnDefault, object ContractOnLoss)
		{

			Hashtable CreateTrancheContract_args = new Hashtable();
			CreateTrancheContract_args.Add("Name", Name);
			CreateTrancheContract_args.Add("Constituents", Constituents);
			CreateTrancheContract_args.Add("AttachmentPoint", AttachmentPoint);
			CreateTrancheContract_args.Add("DetachmentPoint", DetachmentPoint);
			CreateTrancheContract_args.Add("WriteDownNotionalOnDefault", WriteDownNotionalOnDefault);
			CreateTrancheContract_args.Add("ContractOnLoss", ContractOnLoss);
			return F3Formatter.f3_style_serialization("CreateTrancheContract", CreateTrancheContract_args);
		}

		// <summary>
		// Create a market data set containing a set of tranche spreads.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="TrancheBoundaries">Attachment and detachment points for the tranches.</param>
		// <param name="TrancheSpreads">The tranche spreads.</param>
		// <param name="TrancheSpreadsName">Name of tranche spread market data.</param>
		// <param name="TrancheSpreadsType">Type of tranche spread market data.</param>
		// <param name="Currency">Currency of tranche trade.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditPortfolio">Credit portfolio.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateTrancheSpreadMarketData(object MarketDataSetName, object Maturities, object TrancheBoundaries, object TrancheSpreads, object TrancheSpreadsName, object TrancheSpreadsType, object Currency, object MarketConventions, object CreditPortfolio, object QuoteDate)
		{

			Hashtable CreateTrancheSpreadMarketData_args = new Hashtable();
			CreateTrancheSpreadMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateTrancheSpreadMarketData_args.Add("Maturities", Maturities);
			CreateTrancheSpreadMarketData_args.Add("TrancheBoundaries", TrancheBoundaries);
			CreateTrancheSpreadMarketData_args.Add("TrancheSpreads", TrancheSpreads);
			CreateTrancheSpreadMarketData_args.Add("TrancheSpreadsName", TrancheSpreadsName);
			CreateTrancheSpreadMarketData_args.Add("TrancheSpreadsType", TrancheSpreadsType);
			CreateTrancheSpreadMarketData_args.Add("Currency", Currency);
			CreateTrancheSpreadMarketData_args.Add("MarketConventions", MarketConventions);
			CreateTrancheSpreadMarketData_args.Add("CreditPortfolio", CreditPortfolio);
			CreateTrancheSpreadMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateTrancheSpreadMarketData", CreateTrancheSpreadMarketData_args);
		}

		// <summary>
		// Create a Trapezoidal integration method.
		// </summary>
		// <param name="MethodName">Name to use for the method.</param>
		// <param name="NumberOfSteps">Number of steps.</param>
		// <returns>Retuns the name of the constructed object of type IntegrationMethod.</returns>
		public object CreateTrapezoidalIntegrationMethod(object MethodName, object NumberOfSteps)
		{

			Hashtable CreateTrapezoidalIntegrationMethod_args = new Hashtable();
			CreateTrapezoidalIntegrationMethod_args.Add("MethodName", MethodName);
			CreateTrapezoidalIntegrationMethod_args.Add("NumberOfSteps", NumberOfSteps);
			return F3Formatter.f3_style_serialization("CreateTrapezoidalIntegrationMethod", CreateTrapezoidalIntegrationMethod_args);
		}

		// <summary>
		// Create a valuation specification for generic trigger replacement.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <param name="Generator">Base generator to use in trigger replacement computations.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="Iterations">Number of iterations. Default value: 1023.</param>
		// <param name="TriggerExplanatoryStrategy">Strategy to use for the trigger explanation. Default value: DefaultOrderPolynomials.</param>
		// <param name="TriggerReplacementCalculator">Strategy to use for the trigger replacement calculator. Default value: DefaultRegression.</param>
		// <param name="CacheNestedTrees">Flag to indicate whether or not nested valuation trees should be collected (typically for reporting). Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateTriggerReplacementValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod, object Generator, object CalculationMethod, object Iterations, object TriggerExplanatoryStrategy, object TriggerReplacementCalculator, object CacheNestedTrees)
		{

			Hashtable CreateTriggerReplacementValuationSpecification_args = new Hashtable();
			CreateTriggerReplacementValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateTriggerReplacementValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			CreateTriggerReplacementValuationSpecification_args.Add("Generator", Generator);
			CreateTriggerReplacementValuationSpecification_args.Add("CalculationMethod", CalculationMethod);
			CreateTriggerReplacementValuationSpecification_args.Add("Iterations", Iterations);
			CreateTriggerReplacementValuationSpecification_args.Add("TriggerExplanatoryStrategy", TriggerExplanatoryStrategy);
			CreateTriggerReplacementValuationSpecification_args.Add("TriggerReplacementCalculator", TriggerReplacementCalculator);
			CreateTriggerReplacementValuationSpecification_args.Add("CacheNestedTrees", CacheNestedTrees);
			return F3Formatter.f3_style_serialization("CreateTriggerReplacementValuationSpecification", CreateTriggerReplacementValuationSpecification_args);
		}

		// <summary>
		// Create a two-dimensional slice of a three-dimensional function.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="ThreeDimFunction">Three-dimensional function to slice.</param>
		// <param name="FixedArgument">Value of the fixed argument.</param>
		// <param name="FixedParameterTag">Tag for the fixed parameter.</param>
		// <param name="FixedIndex">Index of the fixed variable.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateTwoDimSliceOf3dFunction(object FunctionName, object ThreeDimFunction, object FixedArgument, object FixedParameterTag, object FixedIndex)
		{

			Hashtable CreateTwoDimSliceOf3dFunction_args = new Hashtable();
			CreateTwoDimSliceOf3dFunction_args.Add("FunctionName", FunctionName);
			CreateTwoDimSliceOf3dFunction_args.Add("ThreeDimFunction", ThreeDimFunction);
			CreateTwoDimSliceOf3dFunction_args.Add("FixedArgument", FixedArgument);
			CreateTwoDimSliceOf3dFunction_args.Add("FixedParameterTag", FixedParameterTag);
			CreateTwoDimSliceOf3dFunction_args.Add("FixedIndex", FixedIndex);
			return F3Formatter.f3_style_serialization("CreateTwoDimSliceOf3dFunction", CreateTwoDimSliceOf3dFunction_args);
		}

		// <summary>
		// Create a two-sided bound constraint to use in calibration.
		// </summary>
		// <param name="ConstraintName">Name to use for constraint.</param>
		// <param name="LowerBound">Lower bound value.</param>
		// <param name="UpperBound">Upper bound value.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationBoundConstraint.</returns>
		public object CreateTwoSidedBoundCalibrationConstraint(object ConstraintName, object LowerBound, object UpperBound)
		{

			Hashtable CreateTwoSidedBoundCalibrationConstraint_args = new Hashtable();
			CreateTwoSidedBoundCalibrationConstraint_args.Add("ConstraintName", ConstraintName);
			CreateTwoSidedBoundCalibrationConstraint_args.Add("LowerBound", LowerBound);
			CreateTwoSidedBoundCalibrationConstraint_args.Add("UpperBound", UpperBound);
			return F3Formatter.f3_style_serialization("CreateTwoSidedBoundCalibrationConstraint", CreateTwoSidedBoundCalibrationConstraint_args);
		}

		// <summary>
		// Create a product whose value gives the total uncollateralized exposure                                                                        to a counterparty on a specified date, given a collateral agreement.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="UnderlyingProduct">Underlying product.</param>
		// <param name="CollateralAgreement">Collateralization rules to use for the new product.</param>
		// <param name="MarkToMarketDate">Date on which to observe the underlying product's value.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateUncollateralizedRemainderProduct(object ProductName, object UnderlyingProduct, object CollateralAgreement, object MarkToMarketDate)
		{

			Hashtable CreateUncollateralizedRemainderProduct_args = new Hashtable();
			CreateUncollateralizedRemainderProduct_args.Add("ProductName", ProductName);
			CreateUncollateralizedRemainderProduct_args.Add("UnderlyingProduct", UnderlyingProduct);
			CreateUncollateralizedRemainderProduct_args.Add("CollateralAgreement", CollateralAgreement);
			CreateUncollateralizedRemainderProduct_args.Add("MarkToMarketDate", MarkToMarketDate);
			return F3Formatter.f3_style_serialization("CreateUncollateralizedRemainderProduct", CreateUncollateralizedRemainderProduct_args);
		}

		// <summary>
		// Create the holiday convention implicit in a 0b maturity.
		// </summary>
		// <param name="HolidayConventionName">Name to use for the holiday convention.</param>
		// <param name="MaturityCalculator">Underlying maturity calculator.</param>
		// <returns>Retuns the name of the constructed object of type HolidayConvention.</returns>
		public object CreateUnmovedBusinessDayHolidayConvention(object HolidayConventionName, object MaturityCalculator)
		{

			Hashtable CreateUnmovedBusinessDayHolidayConvention_args = new Hashtable();
			CreateUnmovedBusinessDayHolidayConvention_args.Add("HolidayConventionName", HolidayConventionName);
			CreateUnmovedBusinessDayHolidayConvention_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateUnmovedBusinessDayHolidayConvention", CreateUnmovedBusinessDayHolidayConvention_args);
		}

		// <summary>
		// Creates a new unpublished bibliography entry.
		// </summary>
		// <param name="Name">Name to use for the unpublished bibliography entry.</param>
		// <param name="Author">Author to use for the unpublished bibliography entry.</param>
		// <param name="Year">Year to use for the unpublished bibliography entry.</param>
		// <param name="Title">Title to use for the unpublished bibliography entry.</param>
		// <param name="Note">Note to use for the unpublished bibliography entry.</param>
		// <returns>Retuns the name of the constructed object of type Bibliography.</returns>
		public object CreateUnpublishedBibliographyEntry(object Name, object Author, object Year, object Title, object Note)
		{

			Hashtable CreateUnpublishedBibliographyEntry_args = new Hashtable();
			CreateUnpublishedBibliographyEntry_args.Add("Name", Name);
			CreateUnpublishedBibliographyEntry_args.Add("Author", Author);
			CreateUnpublishedBibliographyEntry_args.Add("Year", Year);
			CreateUnpublishedBibliographyEntry_args.Add("Title", Title);
			CreateUnpublishedBibliographyEntry_args.Add("Note", Note);
			return F3Formatter.f3_style_serialization("CreateUnpublishedBibliographyEntry", CreateUnpublishedBibliographyEntry_args);
		}

		// <summary>
		// Create a market data set containing credit default swaps, quoted as notional fraction upfront.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="UpfrontFractions">Vector of CDS upfront fees as fraction of notional.</param>
		// <param name="FixedPremia">Vector of fixed CDS premia.</param>
		// <param name="Currency">Currency of CDS.</param>
		// <param name="CDSDataName">Name of CDS market data.</param>
		// <param name="CDSDataType">Type of CDS market data.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditContract">Credit contract.</param>
		// <param name="PayAccrued">Switch for whether or not to pay accrued interest upon default. Default value: true.</param>
		// <param name="OffsettingLegMarketConventions">Market conventions for the offsetting (default) leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateUpfrontSingleEventCDSMarketData(object MarketDataSetName, object Maturities, object UpfrontFractions, object FixedPremia, object Currency, object CDSDataName, object CDSDataType, object MarketConventions, object CreditContract, object PayAccrued,
		object OffsettingLegMarketConventions, object QuoteDate)
		{

			Hashtable CreateUpfrontSingleEventCDSMarketData_args = new Hashtable();
			CreateUpfrontSingleEventCDSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateUpfrontSingleEventCDSMarketData_args.Add("Maturities", Maturities);
			CreateUpfrontSingleEventCDSMarketData_args.Add("UpfrontFractions", UpfrontFractions);
			CreateUpfrontSingleEventCDSMarketData_args.Add("FixedPremia", FixedPremia);
			CreateUpfrontSingleEventCDSMarketData_args.Add("Currency", Currency);
			CreateUpfrontSingleEventCDSMarketData_args.Add("CDSDataName", CDSDataName);
			CreateUpfrontSingleEventCDSMarketData_args.Add("CDSDataType", CDSDataType);
			CreateUpfrontSingleEventCDSMarketData_args.Add("MarketConventions", MarketConventions);
			CreateUpfrontSingleEventCDSMarketData_args.Add("CreditContract", CreditContract);
			CreateUpfrontSingleEventCDSMarketData_args.Add("PayAccrued", PayAccrued);
			CreateUpfrontSingleEventCDSMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			CreateUpfrontSingleEventCDSMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateUpfrontSingleEventCDSMarketData", CreateUpfrontSingleEventCDSMarketData_args);
		}

		// <summary>
		// Create a market data set containing credit default swaps, quoted as notional fraction upfront.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="UpfrontFractions">Vector of CDS upfront fees as fraction of notional.</param>
		// <param name="FixedPremia">Vector of fixed CDS premia.</param>
		// <param name="Currency">Currency of CDS.</param>
		// <param name="CDSDataName">Name of CDS market data.</param>
		// <param name="CDSDataType">Type of CDS market data.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditEntity">Credit entity.</param>
		// <param name="PayAccrued">Switch for whether or not to pay accrued interest upon default. Default value: true.</param>
		// <param name="OffsettingLegMarketConventions">Market conventions for the offsetting (default) leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateUpfrontVanillaCDSMarketData(object MarketDataSetName, object Maturities, object UpfrontFractions, object FixedPremia, object Currency, object CDSDataName, object CDSDataType, object MarketConventions, object CreditEntity, object PayAccrued,
		object OffsettingLegMarketConventions, object QuoteDate)
		{

			Hashtable CreateUpfrontVanillaCDSMarketData_args = new Hashtable();
			CreateUpfrontVanillaCDSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateUpfrontVanillaCDSMarketData_args.Add("Maturities", Maturities);
			CreateUpfrontVanillaCDSMarketData_args.Add("UpfrontFractions", UpfrontFractions);
			CreateUpfrontVanillaCDSMarketData_args.Add("FixedPremia", FixedPremia);
			CreateUpfrontVanillaCDSMarketData_args.Add("Currency", Currency);
			CreateUpfrontVanillaCDSMarketData_args.Add("CDSDataName", CDSDataName);
			CreateUpfrontVanillaCDSMarketData_args.Add("CDSDataType", CDSDataType);
			CreateUpfrontVanillaCDSMarketData_args.Add("MarketConventions", MarketConventions);
			CreateUpfrontVanillaCDSMarketData_args.Add("CreditEntity", CreditEntity);
			CreateUpfrontVanillaCDSMarketData_args.Add("PayAccrued", PayAccrued);
			CreateUpfrontVanillaCDSMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			CreateUpfrontVanillaCDSMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateUpfrontVanillaCDSMarketData", CreateUpfrontVanillaCDSMarketData_args);
		}

		// <summary>
		// Create an upper bound constraint to use in calibration.
		// </summary>
		// <param name="ConstraintName">Name to use for constraint.</param>
		// <param name="UpperBound">Upper bound value.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationBoundConstraint.</returns>
		public object CreateUpperBoundCalibrationConstraint(object ConstraintName, object UpperBound)
		{

			Hashtable CreateUpperBoundCalibrationConstraint_args = new Hashtable();
			CreateUpperBoundCalibrationConstraint_args.Add("ConstraintName", ConstraintName);
			CreateUpperBoundCalibrationConstraint_args.Add("UpperBound", UpperBound);
			return F3Formatter.f3_style_serialization("CreateUpperBoundCalibrationConstraint", CreateUpperBoundCalibrationConstraint_args);
		}

		// <summary>
		// Create a new valuation specification from any input that explicitly or implicitly defines one.
		// </summary>
		// <param name="ValuationMethod">Name to use for the created valuation specification.</param>
		// <param name="UnderlyingValuationMethod">Underlying valuation specification.</param>
		// <returns>Retuns the name of the constructed object of type ValuationSpecification.</returns>
		public object CreateValuationSpecification(object ValuationMethod, object UnderlyingValuationMethod)
		{

			Hashtable CreateValuationSpecification_args = new Hashtable();
			CreateValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			CreateValuationSpecification_args.Add("UnderlyingValuationMethod", UnderlyingValuationMethod);
			return F3Formatter.f3_style_serialization("CreateValuationSpecification", CreateValuationSpecification_args);
		}

		// <summary>
		// Form a credit index basis adjustment method based on matching trade values, given a 2d mapping..
		// </summary>
		// <param name="MethodName">Name to use for the adjustment method.</param>
		// <param name="CurveMapping">Curve mapping.</param>
		// <param name="InitialFixedPoint">Optional fixed point for the basis adjustment curve at time zero. Default value: default-constructed instance of type real_if_any.</param>
		// <returns>Retuns the name of the constructed object of type CreditBasisAdjustmentMethod.</returns>
		public object CreateValueMatchingAdjustmentMethod(object MethodName, object CurveMapping, object InitialFixedPoint)
		{

			Hashtable CreateValueMatchingAdjustmentMethod_args = new Hashtable();
			CreateValueMatchingAdjustmentMethod_args.Add("MethodName", MethodName);
			CreateValueMatchingAdjustmentMethod_args.Add("CurveMapping", CurveMapping);
			CreateValueMatchingAdjustmentMethod_args.Add("InitialFixedPoint", InitialFixedPoint);
			return F3Formatter.f3_style_serialization("CreateValueMatchingAdjustmentMethod", CreateValueMatchingAdjustmentMethod_args);
		}

		// <summary>
		// Create a replication strategy using a portfolio of call options that will match the payoff function at specified strikes..
		// </summary>
		// <param name="StrategyName">Name to use for the strategy.</param>
		// <param name="NumberOfOptions">Number of options to use in replication.</param>
		// <param name="LowerStrikeCutoff">The lowest strike to use in the replication. Default value: <s>Ratio</s><d>0.0</d>.</param>
		// <param name="UpperStrikeCutoff">The highest strike to use in the replication. Default value: <s>Ratio</s><d>5.0</d>.</param>
		// <returns>Retuns the name of the constructed object of type ReplicationStrategy.</returns>
		public object CreateValueMatchingReplicationStrategy(object StrategyName, object NumberOfOptions, object LowerStrikeCutoff, object UpperStrikeCutoff)
		{

			Hashtable CreateValueMatchingReplicationStrategy_args = new Hashtable();
			CreateValueMatchingReplicationStrategy_args.Add("StrategyName", StrategyName);
			CreateValueMatchingReplicationStrategy_args.Add("NumberOfOptions", NumberOfOptions);
			CreateValueMatchingReplicationStrategy_args.Add("LowerStrikeCutoff", LowerStrikeCutoff);
			CreateValueMatchingReplicationStrategy_args.Add("UpperStrikeCutoff", UpperStrikeCutoff);
			return F3Formatter.f3_style_serialization("CreateValueMatchingReplicationStrategy", CreateValueMatchingReplicationStrategy_args);
		}

		// <summary>
		// Create a market data set containing a set of single-name credit default swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="SwapRates">Vector of CDS premia.</param>
		// <param name="Currency">Currency of CDS.</param>
		// <param name="CDSDataName">Name of CDS market data.</param>
		// <param name="CDSDataType">Type of CDS market data.</param>
		// <param name="MarketConventions">Market conventions.</param>
		// <param name="CreditEntity">Credit entity.</param>
		// <param name="PayAccrued">Switch for whether or not to pay accrued interest upon default. Default value: true.</param>
		// <param name="OffsettingLegMarketConventions">Market conventions for the offsetting (default) leg. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="QuoteDate">The day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaCDSMarketData(object MarketDataSetName, object Maturities, object SwapRates, object Currency, object CDSDataName, object CDSDataType, object MarketConventions, object CreditEntity, object PayAccrued, object OffsettingLegMarketConventions,
		object QuoteDate)
		{

			Hashtable CreateVanillaCDSMarketData_args = new Hashtable();
			CreateVanillaCDSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaCDSMarketData_args.Add("Maturities", Maturities);
			CreateVanillaCDSMarketData_args.Add("SwapRates", SwapRates);
			CreateVanillaCDSMarketData_args.Add("Currency", Currency);
			CreateVanillaCDSMarketData_args.Add("CDSDataName", CDSDataName);
			CreateVanillaCDSMarketData_args.Add("CDSDataType", CDSDataType);
			CreateVanillaCDSMarketData_args.Add("MarketConventions", MarketConventions);
			CreateVanillaCDSMarketData_args.Add("CreditEntity", CreditEntity);
			CreateVanillaCDSMarketData_args.Add("PayAccrued", PayAccrued);
			CreateVanillaCDSMarketData_args.Add("OffsettingLegMarketConventions", OffsettingLegMarketConventions);
			CreateVanillaCDSMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateVanillaCDSMarketData", CreateVanillaCDSMarketData_args);
		}

		// <summary>
		// Create a vanilla FX forward.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="PaymentDate">Cash flow date.</param>
		// <param name="Notional">The notional of the asset currency leg.</param>
		// <param name="AssetCurrency">Currency of the notional amount.</param>
		// <param name="NumeraireCurrency">Currency of the numeraire.</param>
		// <param name="ContractRate">The agreed rate used to calculate the exchange of cash at maturity.</param>
		// <param name="PayRec">Pay is to pay asset currency on the payment date and receive numeraire currency.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaFXForward(object ProductName, object PaymentDate, object Notional, object AssetCurrency, object NumeraireCurrency, object ContractRate, object PayRec)
		{

			Hashtable CreateVanillaFXForward_args = new Hashtable();
			CreateVanillaFXForward_args.Add("ProductName", ProductName);
			CreateVanillaFXForward_args.Add("PaymentDate", PaymentDate);
			CreateVanillaFXForward_args.Add("Notional", Notional);
			CreateVanillaFXForward_args.Add("AssetCurrency", AssetCurrency);
			CreateVanillaFXForward_args.Add("NumeraireCurrency", NumeraireCurrency);
			CreateVanillaFXForward_args.Add("ContractRate", ContractRate);
			CreateVanillaFXForward_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateVanillaFXForward", CreateVanillaFXForward_args);
		}

		// <summary>
		// Create an instrument type for an FX forward.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="MarketConventions">Market conventions used to determine the payment dates of the forward contract.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateVanillaFXForwardInstrumentType(object InstrumentTypeName, object MarketConventions, object FXRateIndex, object FXFwdQuoteConvention)
		{

			Hashtable CreateVanillaFXForwardInstrumentType_args = new Hashtable();
			CreateVanillaFXForwardInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateVanillaFXForwardInstrumentType_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXForwardInstrumentType_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXForwardInstrumentType_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			return F3Formatter.f3_style_serialization("CreateVanillaFXForwardInstrumentType", CreateVanillaFXForwardInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of vanilla FX forwards.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MarketConventions">MarketConventions for the forward contract.</param>
		// <param name="MarketDataName">Name of FX forward market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of FX forward market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <param name="QuoteSpecifications">Vector of quote specifications.</param>
		// <param name="Quotes">Vector of quotes.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaFXForwardMarketData(object MarketDataSetName, object MarketConventions, object MarketDataName, object MarketDataType, object FXRateIndex, object FXFwdQuoteConvention, object QuoteSpecifications, object Quotes)
		{

			Hashtable CreateVanillaFXForwardMarketData_args = new Hashtable();
			CreateVanillaFXForwardMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaFXForwardMarketData_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXForwardMarketData_args.Add("MarketDataName", MarketDataName);
			CreateVanillaFXForwardMarketData_args.Add("MarketDataType", MarketDataType);
			CreateVanillaFXForwardMarketData_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXForwardMarketData_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			CreateVanillaFXForwardMarketData_args.Add("QuoteSpecifications", QuoteSpecifications);
			CreateVanillaFXForwardMarketData_args.Add("Quotes", Quotes);
			return F3Formatter.f3_style_serialization("CreateVanillaFXForwardMarketData", CreateVanillaFXForwardMarketData_args);
		}

		// <summary>
		// Create a vanilla FX non-deliverable forward contract.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="PaymentDate">Cash flow date.</param>
		// <param name="PaymentCurrency">Currency in which the payment is made.</param>
		// <param name="Notional">The notional amount in the asset currency.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="ContractRate">The agreed rate used to calculate the exchange of cash at maturity.</param>
		// <param name="PayRec">Pay is to receive the contract rate.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaFXNonDeliverableForward(object ProductName, object PaymentDate, object PaymentCurrency, object Notional, object FXRateIndex, object ContractRate, object PayRec)
		{

			Hashtable CreateVanillaFXNonDeliverableForward_args = new Hashtable();
			CreateVanillaFXNonDeliverableForward_args.Add("ProductName", ProductName);
			CreateVanillaFXNonDeliverableForward_args.Add("PaymentDate", PaymentDate);
			CreateVanillaFXNonDeliverableForward_args.Add("PaymentCurrency", PaymentCurrency);
			CreateVanillaFXNonDeliverableForward_args.Add("Notional", Notional);
			CreateVanillaFXNonDeliverableForward_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXNonDeliverableForward_args.Add("ContractRate", ContractRate);
			CreateVanillaFXNonDeliverableForward_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateVanillaFXNonDeliverableForward", CreateVanillaFXNonDeliverableForward_args);
		}

		// <summary>
		// Create an instrument type for an FX non-deliverable forward.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="MarketConventions">Market conventions used to determine the payment dates of the non-deliverable forward contract.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateVanillaFXNonDeliverableForwardInstrumentType(object InstrumentTypeName, object MarketConventions, object FXRateIndex, object FXFwdQuoteConvention)
		{

			Hashtable CreateVanillaFXNonDeliverableForwardInstrumentType_args = new Hashtable();
			CreateVanillaFXNonDeliverableForwardInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateVanillaFXNonDeliverableForwardInstrumentType_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXNonDeliverableForwardInstrumentType_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXNonDeliverableForwardInstrumentType_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			return F3Formatter.f3_style_serialization("CreateVanillaFXNonDeliverableForwardInstrumentType", CreateVanillaFXNonDeliverableForwardInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of vanilla FX non-deliverable forwards.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="PaymentCurrency">Currency in which the payment is made.</param>
		// <param name="MarketConventions">MarketConventions for the forward contract.</param>
		// <param name="MarketDataName">Name of NDF market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of NDF market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <param name="QuoteSpecifications">Vector of quote specifications.</param>
		// <param name="Quotes">Vector of quotes.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaFXNonDeliverableForwardMarketData(object MarketDataSetName, object PaymentCurrency, object MarketConventions, object MarketDataName, object MarketDataType, object FXRateIndex, object FXFwdQuoteConvention, object QuoteSpecifications, object Quotes)
		{

			Hashtable CreateVanillaFXNonDeliverableForwardMarketData_args = new Hashtable();
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("PaymentCurrency", PaymentCurrency);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("MarketDataName", MarketDataName);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("MarketDataType", MarketDataType);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("QuoteSpecifications", QuoteSpecifications);
			CreateVanillaFXNonDeliverableForwardMarketData_args.Add("Quotes", Quotes);
			return F3Formatter.f3_style_serialization("CreateVanillaFXNonDeliverableForwardMarketData", CreateVanillaFXNonDeliverableForwardMarketData_args);
		}

		// <summary>
		// Create a vanilla FX swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="FirstPaymentDate">First cash flow date.</param>
		// <param name="SecondPaymentDate">Second cash flow date.</param>
		// <param name="Notional">The notional of the asset currency leg.</param>
		// <param name="AssetCurrency">Currency of the notional amount.</param>
		// <param name="NumeraireCurrency">Currency of the numeraire leg.</param>
		// <param name="FirstFXRate">The agreed contract rate used to calculate the exchange rate at the first payment date.</param>
		// <param name="SecondFXRate">The agreed contract rate used to calculate the exchange rate at the second payment date.</param>
		// <param name="PayRec">Pay is to receive numeraire on the second payment date.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaFXSwap(object ProductName, object FirstPaymentDate, object SecondPaymentDate, object Notional, object AssetCurrency, object NumeraireCurrency, object FirstFXRate, object SecondFXRate, object PayRec)
		{

			Hashtable CreateVanillaFXSwap_args = new Hashtable();
			CreateVanillaFXSwap_args.Add("ProductName", ProductName);
			CreateVanillaFXSwap_args.Add("FirstPaymentDate", FirstPaymentDate);
			CreateVanillaFXSwap_args.Add("SecondPaymentDate", SecondPaymentDate);
			CreateVanillaFXSwap_args.Add("Notional", Notional);
			CreateVanillaFXSwap_args.Add("AssetCurrency", AssetCurrency);
			CreateVanillaFXSwap_args.Add("NumeraireCurrency", NumeraireCurrency);
			CreateVanillaFXSwap_args.Add("FirstFXRate", FirstFXRate);
			CreateVanillaFXSwap_args.Add("SecondFXRate", SecondFXRate);
			CreateVanillaFXSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateVanillaFXSwap", CreateVanillaFXSwap_args);
		}

		// <summary>
		// Create an instrument type for an FX swap.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="MarketConventions">Market conventions used to determine the payment dates of the swap.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateVanillaFXSwapInstrumentType(object InstrumentTypeName, object MarketConventions, object FXRateIndex, object FXFwdQuoteConvention)
		{

			Hashtable CreateVanillaFXSwapInstrumentType_args = new Hashtable();
			CreateVanillaFXSwapInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateVanillaFXSwapInstrumentType_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXSwapInstrumentType_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXSwapInstrumentType_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			return F3Formatter.f3_style_serialization("CreateVanillaFXSwapInstrumentType", CreateVanillaFXSwapInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of vanilla FX swap quotes.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="MarketConventions">MarketConventions for the swap.</param>
		// <param name="MarketDataName">Name of FX swap market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="MarketDataType">Type of FX swap market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="FXRateIndex">Index describing the FX rate for the two currencies.</param>
		// <param name="FXFwdQuoteConvention">FX forward quote convention.</param>
		// <param name="QuoteSpecifications">Vector of quote specifications.</param>
		// <param name="Quotes">Vector of quotes.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaFXSwapMarketData(object MarketDataSetName, object MarketConventions, object MarketDataName, object MarketDataType, object FXRateIndex, object FXFwdQuoteConvention, object QuoteSpecifications, object Quotes)
		{

			Hashtable CreateVanillaFXSwapMarketData_args = new Hashtable();
			CreateVanillaFXSwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaFXSwapMarketData_args.Add("MarketConventions", MarketConventions);
			CreateVanillaFXSwapMarketData_args.Add("MarketDataName", MarketDataName);
			CreateVanillaFXSwapMarketData_args.Add("MarketDataType", MarketDataType);
			CreateVanillaFXSwapMarketData_args.Add("FXRateIndex", FXRateIndex);
			CreateVanillaFXSwapMarketData_args.Add("FXFwdQuoteConvention", FXFwdQuoteConvention);
			CreateVanillaFXSwapMarketData_args.Add("QuoteSpecifications", QuoteSpecifications);
			CreateVanillaFXSwapMarketData_args.Add("Quotes", Quotes);
			return F3Formatter.f3_style_serialization("CreateVanillaFXSwapMarketData", CreateVanillaFXSwapMarketData_args);
		}

		// <summary>
		// Create an instrument type for an interest rate swap.
		// </summary>
		// <param name="InstrumentTypeName">Name of the instrument type.</param>
		// <param name="MarketConventionsForFixedLeg">Market conventions for the fixed leg.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateVanillaIRSInstrumentType(object InstrumentTypeName, object MarketConventionsForFixedLeg, object FloatingIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateVanillaIRSInstrumentType_args = new Hashtable();
			CreateVanillaIRSInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateVanillaIRSInstrumentType_args.Add("MarketConventionsForFixedLeg", MarketConventionsForFixedLeg);
			CreateVanillaIRSInstrumentType_args.Add("FloatingIndex", FloatingIndex);
			CreateVanillaIRSInstrumentType_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateVanillaIRSInstrumentType", CreateVanillaIRSInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing a set of interest rate swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="SwapRates">Vector of swap rates.</param>
		// <param name="Currency">Currency of swaps. Default value: default-constructed instance of type currency.</param>
		// <param name="IRSName">Name of IRS market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="IRSType">Type of IRS market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="MarketConventionsForFixedLeg">Market conventions for fixed leg.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for floating leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaIRSMarketData(object MarketDataSetName, object Maturities, object SwapRates, object Currency, object IRSName, object IRSType, object MarketConventionsForFixedLeg, object FloatingIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateVanillaIRSMarketData_args = new Hashtable();
			CreateVanillaIRSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaIRSMarketData_args.Add("Maturities", Maturities);
			CreateVanillaIRSMarketData_args.Add("SwapRates", SwapRates);
			CreateVanillaIRSMarketData_args.Add("Currency", Currency);
			CreateVanillaIRSMarketData_args.Add("IRSName", IRSName);
			CreateVanillaIRSMarketData_args.Add("IRSType", IRSType);
			CreateVanillaIRSMarketData_args.Add("MarketConventionsForFixedLeg", MarketConventionsForFixedLeg);
			CreateVanillaIRSMarketData_args.Add("FloatingIndex", FloatingIndex);
			CreateVanillaIRSMarketData_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateVanillaIRSMarketData", CreateVanillaIRSMarketData_args);
		}

		// <summary>
		// Create a single currency interest rate cap or floor.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the cap or floor.</param>
		// <param name="Maturity">Maturity of the cap or floor.</param>
		// <param name="Notional">Notional amount of the product.</param>
		// <param name="FloatingIndex">Index describing the floating rate.</param>
		// <param name="Strike">Strike specification.</param>
		// <param name="CallPut">Call is a cap and Put is a floor.</param>
		// <param name="BuySell">Flag indicating buying or selling the product.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaInterestRateCapFloor(object ProductName, object StartDate, object Maturity, object Notional, object FloatingIndex, object Strike, object CallPut, object BuySell)
		{

			Hashtable CreateVanillaInterestRateCapFloor_args = new Hashtable();
			CreateVanillaInterestRateCapFloor_args.Add("ProductName", ProductName);
			CreateVanillaInterestRateCapFloor_args.Add("StartDate", StartDate);
			CreateVanillaInterestRateCapFloor_args.Add("Maturity", Maturity);
			CreateVanillaInterestRateCapFloor_args.Add("Notional", Notional);
			CreateVanillaInterestRateCapFloor_args.Add("FloatingIndex", FloatingIndex);
			CreateVanillaInterestRateCapFloor_args.Add("Strike", Strike);
			CreateVanillaInterestRateCapFloor_args.Add("CallPut", CallPut);
			CreateVanillaInterestRateCapFloor_args.Add("BuySell", BuySell);
			return F3Formatter.f3_style_serialization("CreateVanillaInterestRateCapFloor", CreateVanillaInterestRateCapFloor_args);
		}

		// <summary>
		// Create a single currency vanilla interest rate swaption.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="Expiry">Expiry date of the swaption.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">Notional for the swap.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Strike">Strike of the swaption.</param>
		// <param name="Payoff">Payer or receiver swaption.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="BuySell">Flag indicating buying or selling the swaption.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaInterestRateSwaption(object ProductName, object Expiry, object Maturity, object Notional, object Currency, object Strike, object Payoff, object FixedLegMarketConvention, object FloatingRateIndex, object BuySell,
		object FloatingLegMarketConvention)
		{

			Hashtable CreateVanillaInterestRateSwaption_args = new Hashtable();
			CreateVanillaInterestRateSwaption_args.Add("ProductName", ProductName);
			CreateVanillaInterestRateSwaption_args.Add("Expiry", Expiry);
			CreateVanillaInterestRateSwaption_args.Add("Maturity", Maturity);
			CreateVanillaInterestRateSwaption_args.Add("Notional", Notional);
			CreateVanillaInterestRateSwaption_args.Add("Currency", Currency);
			CreateVanillaInterestRateSwaption_args.Add("Strike", Strike);
			CreateVanillaInterestRateSwaption_args.Add("Payoff", Payoff);
			CreateVanillaInterestRateSwaption_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateVanillaInterestRateSwaption_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateVanillaInterestRateSwaption_args.Add("BuySell", BuySell);
			CreateVanillaInterestRateSwaption_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			return F3Formatter.f3_style_serialization("CreateVanillaInterestRateSwaption", CreateVanillaInterestRateSwaption_args);
		}

		// <summary>
		// Create a product from an instrument type.
		// </summary>
		// <param name="ProductName">Name to use for the constructed product.</param>
		// <param name="TradeDate">Trade date of the instrument.</param>
		// <param name="InstrumentType">Market data instrument type.</param>
		// <param name="QuoteSpecification">Quote specification.</param>
		// <param name="Quote">Quote.</param>
		// <param name="Notional">Notional amount of the product. Default value: 1000000.</param>
		// <param name="PayRec">Pay/Receive or Buy/Sell specification. Default value: pay.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaMarketProduct(object ProductName, object TradeDate, object InstrumentType, object QuoteSpecification, object Quote, object Notional, object PayRec)
		{

			Hashtable CreateVanillaMarketProduct_args = new Hashtable();
			CreateVanillaMarketProduct_args.Add("ProductName", ProductName);
			CreateVanillaMarketProduct_args.Add("TradeDate", TradeDate);
			CreateVanillaMarketProduct_args.Add("InstrumentType", InstrumentType);
			CreateVanillaMarketProduct_args.Add("QuoteSpecification", QuoteSpecification);
			CreateVanillaMarketProduct_args.Add("Quote", Quote);
			CreateVanillaMarketProduct_args.Add("Notional", Notional);
			CreateVanillaMarketProduct_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateVanillaMarketProduct", CreateVanillaMarketProduct_args);
		}

		// <summary>
		// Create a market data set containing a set of implied Black volatility quotes in a matrix for vanilla options.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Expiries">Vector of option expiries.</param>
		// <param name="Strikes">Vector of option strikes.</param>
		// <param name="ImpliedVolatilities">Matrix of option-implied volatilities.</param>
		// <param name="DataName">Name of market data. Default value: default-constructed instance of type marketdata_name.</param>
		// <param name="DataType">Type of market data. Default value: default-constructed instance of type marketdata_type.</param>
		// <param name="Payoff">Payoff specification.</param>
		// <param name="MarketConventions">Market conventions for the options.</param>
		// <param name="UnderlyingIndex">Index describing the option underlying.</param>
		// <param name="QuoteDate">Day on which the quotes are provided. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateVanillaOptionMarketData(object MarketDataSetName, object Expiries, object Strikes, object ImpliedVolatilities, object DataName, object DataType, object Payoff, object MarketConventions, object UnderlyingIndex, object QuoteDate)
		{

			Hashtable CreateVanillaOptionMarketData_args = new Hashtable();
			CreateVanillaOptionMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateVanillaOptionMarketData_args.Add("Expiries", Expiries);
			CreateVanillaOptionMarketData_args.Add("Strikes", Strikes);
			CreateVanillaOptionMarketData_args.Add("ImpliedVolatilities", ImpliedVolatilities);
			CreateVanillaOptionMarketData_args.Add("DataName", DataName);
			CreateVanillaOptionMarketData_args.Add("DataType", DataType);
			CreateVanillaOptionMarketData_args.Add("Payoff", Payoff);
			CreateVanillaOptionMarketData_args.Add("MarketConventions", MarketConventions);
			CreateVanillaOptionMarketData_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateVanillaOptionMarketData_args.Add("QuoteDate", QuoteDate);
			return F3Formatter.f3_style_serialization("CreateVanillaOptionMarketData", CreateVanillaOptionMarketData_args);
		}

		// <summary>
		// Create a variance swap product given a strike contract rate as the fixed leg and realized variance defined in terms of an underlying index as the floating leg..
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Date for which the variance swap starts.</param>
		// <param name="MaturityDate">Maturity of the variance swap.</param>
		// <param name="Notional">Notional amount of the variance swap.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="ContractStrike">Strike price of the variance swap, expressed as a volatility.</param>
		// <param name="StrikeMarketConvention">Market convention for the contract strike observation.</param>
		// <param name="StrikeScaleIndex">Index scaling the strike cash flow payment.</param>
		// <param name="UnderlyingIndex">Underlying index used to calculate the realized variance accumulated from the start date to the maturity date.</param>
		// <param name="ObservationMarketConvention">Market convention for the realized variance observation.</param>
		// <param name="Margin">Margin over the realized variance index paid on each flow date.</param>
		// <param name="VarianceScaleIndex">Index scaling the realized variance cash flow payment, including any margin over the variance index.</param>
		// <param name="MeanAdjusted">True if the variance is mean-adjusted.</param>
		// <param name="Position">Indicator of payment or receipt of the realized variance.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateVanillaVarianceSwapProduct(object ProductName, object StartDate, object MaturityDate, object Notional, object Currency, object ContractStrike, object StrikeMarketConvention, object StrikeScaleIndex, object UnderlyingIndex, object ObservationMarketConvention,
		object Margin, object VarianceScaleIndex, object MeanAdjusted, object Position)
		{

			Hashtable CreateVanillaVarianceSwapProduct_args = new Hashtable();
			CreateVanillaVarianceSwapProduct_args.Add("ProductName", ProductName);
			CreateVanillaVarianceSwapProduct_args.Add("StartDate", StartDate);
			CreateVanillaVarianceSwapProduct_args.Add("MaturityDate", MaturityDate);
			CreateVanillaVarianceSwapProduct_args.Add("Notional", Notional);
			CreateVanillaVarianceSwapProduct_args.Add("Currency", Currency);
			CreateVanillaVarianceSwapProduct_args.Add("ContractStrike", ContractStrike);
			CreateVanillaVarianceSwapProduct_args.Add("StrikeMarketConvention", StrikeMarketConvention);
			CreateVanillaVarianceSwapProduct_args.Add("StrikeScaleIndex", StrikeScaleIndex);
			CreateVanillaVarianceSwapProduct_args.Add("UnderlyingIndex", UnderlyingIndex);
			CreateVanillaVarianceSwapProduct_args.Add("ObservationMarketConvention", ObservationMarketConvention);
			CreateVanillaVarianceSwapProduct_args.Add("Margin", Margin);
			CreateVanillaVarianceSwapProduct_args.Add("VarianceScaleIndex", VarianceScaleIndex);
			CreateVanillaVarianceSwapProduct_args.Add("MeanAdjusted", MeanAdjusted);
			CreateVanillaVarianceSwapProduct_args.Add("Position", Position);
			return F3Formatter.f3_style_serialization("CreateVanillaVarianceSwapProduct", CreateVanillaVarianceSwapProduct_args);
		}

		// <summary>
		// Create the characteristic function for the variance-gamma distribution.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="SigmaValue">The variance-gamma volatility.</param>
		// <param name="ThetaValue">The skewness.</param>
		// <param name="NuValue">The kurtosis.</param>
		// <param name="ExpiryTime">The expiry time.</param>
		// <param name="SigmaParameterTag">Tag to use for the variance-gamma volatility.</param>
		// <param name="ThetaParameterTag">Tag to use for the skewness.</param>
		// <param name="NuParameterTag">Tag to use for the kurtosis.</param>
		// <param name="ExpiryParameterTag">Tag to use for the expiry time.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalComplexFunction.</returns>
		public object CreateVarianceGammaCharacteristicFunction(object FunctionName, object SigmaValue, object ThetaValue, object NuValue, object ExpiryTime, object SigmaParameterTag, object ThetaParameterTag, object NuParameterTag, object ExpiryParameterTag)
		{

			Hashtable CreateVarianceGammaCharacteristicFunction_args = new Hashtable();
			CreateVarianceGammaCharacteristicFunction_args.Add("FunctionName", FunctionName);
			CreateVarianceGammaCharacteristicFunction_args.Add("SigmaValue", SigmaValue);
			CreateVarianceGammaCharacteristicFunction_args.Add("ThetaValue", ThetaValue);
			CreateVarianceGammaCharacteristicFunction_args.Add("NuValue", NuValue);
			CreateVarianceGammaCharacteristicFunction_args.Add("ExpiryTime", ExpiryTime);
			CreateVarianceGammaCharacteristicFunction_args.Add("SigmaParameterTag", SigmaParameterTag);
			CreateVarianceGammaCharacteristicFunction_args.Add("ThetaParameterTag", ThetaParameterTag);
			CreateVarianceGammaCharacteristicFunction_args.Add("NuParameterTag", NuParameterTag);
			CreateVarianceGammaCharacteristicFunction_args.Add("ExpiryParameterTag", ExpiryParameterTag);
			return F3Formatter.f3_style_serialization("CreateVarianceGammaCharacteristicFunction", CreateVarianceGammaCharacteristicFunction_args);
		}

		// <summary>
		// Create a market convention that generates schedules with rolls that are an integer number of weeks long.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="RollLength">Roll length, in weeks.</param>
		// <param name="StubType">Stub type.</param>
		// <param name="RollDayModifier">Date modifier applied to all roll end dates, excluding the final roll..</param>
		// <param name="DayCountConvention">Day count convention for calculation of accrual factors.</param>
		// <param name="ModifyStart">True if start date should be also be adjusted using the RollDayModifier modifier. Default value: false.</param>
		// <param name="EndDateModifier">Date modifier for the end date of the final roll. Default value: NullModifier.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateWeeklyScheduleMarketConvention(object MarketConventionName, object UnderlyingConventions, object RollLength, object StubType, object RollDayModifier, object DayCountConvention, object ModifyStart, object EndDateModifier)
		{

			Hashtable CreateWeeklyScheduleMarketConvention_args = new Hashtable();
			CreateWeeklyScheduleMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateWeeklyScheduleMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateWeeklyScheduleMarketConvention_args.Add("RollLength", RollLength);
			CreateWeeklyScheduleMarketConvention_args.Add("StubType", StubType);
			CreateWeeklyScheduleMarketConvention_args.Add("RollDayModifier", RollDayModifier);
			CreateWeeklyScheduleMarketConvention_args.Add("DayCountConvention", DayCountConvention);
			CreateWeeklyScheduleMarketConvention_args.Add("ModifyStart", ModifyStart);
			CreateWeeklyScheduleMarketConvention_args.Add("EndDateModifier", EndDateModifier);
			return F3Formatter.f3_style_serialization("CreateWeeklyScheduleMarketConvention", CreateWeeklyScheduleMarketConvention_args);
		}

		// <summary>
		// Create a two-dimensional function from the weighted sum of a collection of two-dimensional functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Functions">Collection of two-dimensional functions.</param>
		// <param name="Weights">Collection of weights.</param>
		// <param name="WeightParameterTag">Tag to use for the weight parameters.</param>
		// <returns>Retuns the name of the constructed object of type TwoDimensionalFunction.</returns>
		public object CreateWeighted2dSumFunction(object FunctionName, object Functions, object Weights, object WeightParameterTag)
		{

			Hashtable CreateWeighted2dSumFunction_args = new Hashtable();
			CreateWeighted2dSumFunction_args.Add("FunctionName", FunctionName);
			CreateWeighted2dSumFunction_args.Add("Functions", Functions);
			CreateWeighted2dSumFunction_args.Add("Weights", Weights);
			CreateWeighted2dSumFunction_args.Add("WeightParameterTag", WeightParameterTag);
			return F3Formatter.f3_style_serialization("CreateWeighted2dSumFunction", CreateWeighted2dSumFunction_args);
		}

		// <summary>
		// Create a function from the weighted sum of a collection of functions.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="Functions">Collection of one-dimensional functions.</param>
		// <param name="Weights">Collection of weights.</param>
		// <param name="WeightParameterTag">Tag to use for the weight parameters.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateWeightedSumFunction(object FunctionName, object Functions, object Weights, object WeightParameterTag)
		{

			Hashtable CreateWeightedSumFunction_args = new Hashtable();
			CreateWeightedSumFunction_args.Add("FunctionName", FunctionName);
			CreateWeightedSumFunction_args.Add("Functions", Functions);
			CreateWeightedSumFunction_args.Add("Weights", Weights);
			CreateWeightedSumFunction_args.Add("WeightParameterTag", WeightParameterTag);
			return F3Formatter.f3_style_serialization("CreateWeightedSumFunction", CreateWeightedSumFunction_args);
		}

		// <summary>
		// Create an automatically sized histogram source.
		// </summary>
		// <param name="HistogramName">Name to use for the histogram source.</param>
		// <param name="NumBins">Number of bins. Default value: 50.</param>
		// <returns>Retuns the name of the constructed object of type Histogram.</returns>
		public object CreateWholeSampleUniformBinsAutoSizedHistogram(object HistogramName, object NumBins)
		{

			Hashtable CreateWholeSampleUniformBinsAutoSizedHistogram_args = new Hashtable();
			CreateWholeSampleUniformBinsAutoSizedHistogram_args.Add("HistogramName", HistogramName);
			CreateWholeSampleUniformBinsAutoSizedHistogram_args.Add("NumBins", NumBins);
			return F3Formatter.f3_style_serialization("CreateWholeSampleUniformBinsAutoSizedHistogram", CreateWholeSampleUniformBinsAutoSizedHistogram_args);
		}

		// <summary>
		// Create a market convention from an underlying convention and a settlement calculator.
		// </summary>
		// <param name="MarketConventionName">Name to use for market convention.</param>
		// <param name="UnderlyingConventions">Underlying market conventions.</param>
		// <param name="SettlementModifier">Date modifier specifying the settlement convention.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object CreateWrappedSettlementMarketConvention(object MarketConventionName, object UnderlyingConventions, object SettlementModifier)
		{

			Hashtable CreateWrappedSettlementMarketConvention_args = new Hashtable();
			CreateWrappedSettlementMarketConvention_args.Add("MarketConventionName", MarketConventionName);
			CreateWrappedSettlementMarketConvention_args.Add("UnderlyingConventions", UnderlyingConventions);
			CreateWrappedSettlementMarketConvention_args.Add("SettlementModifier", SettlementModifier);
			return F3Formatter.f3_style_serialization("CreateWrappedSettlementMarketConvention", CreateWrappedSettlementMarketConvention_args);
		}

		// <summary>
		// Create a single currency year-on-year inflation swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap (may be different from the trade date).</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional structure for the fixed leg.</param>
		// <param name="YearOnYearCoupon">The year-on-year rate.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateYearOnYearInflationSwap(object ProductName, object StartDate, object Maturity, object Notional, object YearOnYearCoupon, object FixedLegMarketConvention, object FloatingRateIndex, object FloatingLegMarketConvention, object Margin, object PayRec)
		{

			Hashtable CreateYearOnYearInflationSwap_args = new Hashtable();
			CreateYearOnYearInflationSwap_args.Add("ProductName", ProductName);
			CreateYearOnYearInflationSwap_args.Add("StartDate", StartDate);
			CreateYearOnYearInflationSwap_args.Add("Maturity", Maturity);
			CreateYearOnYearInflationSwap_args.Add("Notional", Notional);
			CreateYearOnYearInflationSwap_args.Add("YearOnYearCoupon", YearOnYearCoupon);
			CreateYearOnYearInflationSwap_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateYearOnYearInflationSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateYearOnYearInflationSwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateYearOnYearInflationSwap_args.Add("Margin", Margin);
			CreateYearOnYearInflationSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateYearOnYearInflationSwap", CreateYearOnYearInflationSwap_args);
		}

		// <summary>
		// Create a market data set containing a set of year-on-year inflation swap rates.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="YearOnYearInflationSwapRates">Vector of year-on-year inflation swap rates.</param>
		// <param name="YearOnYearInflationName">Name of year-on-year inflation swap market data.</param>
		// <param name="YearOnYearInflationType">Type of year-on-year inflation swap market data.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the legs.</param>
		// <param name="InflationIndex">Inflation index (RPI).</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateYearOnYearInflationSwapMarketData(object MarketDataSetName, object Maturities, object YearOnYearInflationSwapRates, object YearOnYearInflationName, object YearOnYearInflationType, object FixedLegMarketConventions, object InflationIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateYearOnYearInflationSwapMarketData_args = new Hashtable();
			CreateYearOnYearInflationSwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateYearOnYearInflationSwapMarketData_args.Add("Maturities", Maturities);
			CreateYearOnYearInflationSwapMarketData_args.Add("YearOnYearInflationSwapRates", YearOnYearInflationSwapRates);
			CreateYearOnYearInflationSwapMarketData_args.Add("YearOnYearInflationName", YearOnYearInflationName);
			CreateYearOnYearInflationSwapMarketData_args.Add("YearOnYearInflationType", YearOnYearInflationType);
			CreateYearOnYearInflationSwapMarketData_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateYearOnYearInflationSwapMarketData_args.Add("InflationIndex", InflationIndex);
			CreateYearOnYearInflationSwapMarketData_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateYearOnYearInflationSwapMarketData", CreateYearOnYearInflationSwapMarketData_args);
		}

		// <summary>
		// Create a scenario which changes interest rates by a fixed amount.
		// </summary>
		// <param name="ScenarioName">Name to use for the scenario.</param>
		// <param name="Currency">Currency for which interest rates should be shifted.</param>
		// <param name="ShiftAmount">The amount by which interest rates should be shifted. Default value: 0.0001.</param>
		// <returns>Retuns the name of the constructed object of type Scenario.</returns>
		public object CreateYieldCurveParallelShiftScenario(object ScenarioName, object Currency, object ShiftAmount)
		{

			Hashtable CreateYieldCurveParallelShiftScenario_args = new Hashtable();
			CreateYieldCurveParallelShiftScenario_args.Add("ScenarioName", ScenarioName);
			CreateYieldCurveParallelShiftScenario_args.Add("Currency", Currency);
			CreateYieldCurveParallelShiftScenario_args.Add("ShiftAmount", ShiftAmount);
			return F3Formatter.f3_style_serialization("CreateYieldCurveParallelShiftScenario", CreateYieldCurveParallelShiftScenario_args);
		}

		// <summary>
		// Create a generator for scenarios which change interest rates by a fixed amount.
		// </summary>
		// <param name="GeneratorName">Name to use for the constructed generator.</param>
		// <param name="Currency">Currency for which interest rates should be shifted.</param>
		// <param name="ShiftAmountGenerator">Underlying numeric generator that generates the amounts by which interest rates should be shifted.</param>
		// <returns>Retuns the name of the constructed object of type ScenarioGenerator.</returns>
		public object CreateYieldCurveParallelShiftScenarioGenerator(object GeneratorName, object Currency, object ShiftAmountGenerator)
		{

			Hashtable CreateYieldCurveParallelShiftScenarioGenerator_args = new Hashtable();
			CreateYieldCurveParallelShiftScenarioGenerator_args.Add("GeneratorName", GeneratorName);
			CreateYieldCurveParallelShiftScenarioGenerator_args.Add("Currency", Currency);
			CreateYieldCurveParallelShiftScenarioGenerator_args.Add("ShiftAmountGenerator", ShiftAmountGenerator);
			return F3Formatter.f3_style_serialization("CreateYieldCurveParallelShiftScenarioGenerator", CreateYieldCurveParallelShiftScenarioGenerator_args);
		}

		// <summary>
		// Create a function to calculate the dirty price of a fixed coupon bond, given the yield.
		// </summary>
		// <param name="FunctionName">Name to use for the function.</param>
		// <param name="CouponsPerYear">Number of coupon periods per year.</param>
		// <param name="Delta">Time in years from settlement until the first coupon payment.</param>
		// <param name="CouponRate">Coupon rate per year.</param>
		// <param name="NumCoupons">Number of coupons left until bond maturity.</param>
		// <param name="CouponsPerYearTag">Tag for CouponsPerYear parameter.</param>
		// <param name="DeltaTag">Tag for Delta parameter.</param>
		// <param name="CouponRateTag">Tag for CouponRate parameter.</param>
		// <returns>Retuns the name of the constructed object of type OneDimensionalFunction.</returns>
		public object CreateYieldToPriceFunction(object FunctionName, object CouponsPerYear, object Delta, object CouponRate, object NumCoupons, object CouponsPerYearTag, object DeltaTag, object CouponRateTag)
		{

			Hashtable CreateYieldToPriceFunction_args = new Hashtable();
			CreateYieldToPriceFunction_args.Add("FunctionName", FunctionName);
			CreateYieldToPriceFunction_args.Add("CouponsPerYear", CouponsPerYear);
			CreateYieldToPriceFunction_args.Add("Delta", Delta);
			CreateYieldToPriceFunction_args.Add("CouponRate", CouponRate);
			CreateYieldToPriceFunction_args.Add("NumCoupons", NumCoupons);
			CreateYieldToPriceFunction_args.Add("CouponsPerYearTag", CouponsPerYearTag);
			CreateYieldToPriceFunction_args.Add("DeltaTag", DeltaTag);
			CreateYieldToPriceFunction_args.Add("CouponRateTag", CouponRateTag);
			return F3Formatter.f3_style_serialization("CreateYieldToPriceFunction", CreateYieldToPriceFunction_args);
		}

		// <summary>
		// Create a yield convention which calculates the Z-spread for a bond.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="UnderlyingCurveTag">The curve tag for the curve against which the spread is computed. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="CompoundingFrequency">Compounding frequency used in the spread calculation. Default value: Continuous.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateZSpreadConvention(object YieldConventionName, object UnderlyingCurveTag, object CompoundingFrequency)
		{

			Hashtable CreateZSpreadConvention_args = new Hashtable();
			CreateZSpreadConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateZSpreadConvention_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			CreateZSpreadConvention_args.Add("CompoundingFrequency", CompoundingFrequency);
			return F3Formatter.f3_style_serialization("CreateZSpreadConvention", CreateZSpreadConvention_args);
		}

		// <summary>
		// Create an instrument type for a zero coupon bond product.
		// </summary>
		// <param name="InstrumentTypeName">Name of instrument type.</param>
		// <param name="Currency">Currency of the zero-coupon bond.</param>
		// <param name="YieldConvention">Default yield convention for bond yields.</param>
		// <param name="MaturityCalculator">Method for calculating the maturities of zero-coupon bonds. Default value: BasicMonthYear.</param>
		// <returns>Retuns the name of the constructed object of type InstrumentType.</returns>
		public object CreateZeroCouponBondInstrumentType(object InstrumentTypeName, object Currency, object YieldConvention, object MaturityCalculator)
		{

			Hashtable CreateZeroCouponBondInstrumentType_args = new Hashtable();
			CreateZeroCouponBondInstrumentType_args.Add("InstrumentTypeName", InstrumentTypeName);
			CreateZeroCouponBondInstrumentType_args.Add("Currency", Currency);
			CreateZeroCouponBondInstrumentType_args.Add("YieldConvention", YieldConvention);
			CreateZeroCouponBondInstrumentType_args.Add("MaturityCalculator", MaturityCalculator);
			return F3Formatter.f3_style_serialization("CreateZeroCouponBondInstrumentType", CreateZeroCouponBondInstrumentType_args);
		}

		// <summary>
		// Create a market data set containing zero-coupon bonds.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="Currency">Currency of the zero-coupon bond.</param>
		// <param name="Maturities">Vector of bond maturities.</param>
		// <param name="MaturityCalculator">Method for calculating the maturities of explanatory zero-coupon bonds. Default value: BasicMonthYear.</param>
		// <param name="TagName">Name-part of the market data tag.</param>
		// <param name="TagType">Type-part of the market data tag.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateZeroCouponBondMarketData(object MarketDataSetName, object Currency, object Maturities, object MaturityCalculator, object TagName, object TagType)
		{

			Hashtable CreateZeroCouponBondMarketData_args = new Hashtable();
			CreateZeroCouponBondMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateZeroCouponBondMarketData_args.Add("Currency", Currency);
			CreateZeroCouponBondMarketData_args.Add("Maturities", Maturities);
			CreateZeroCouponBondMarketData_args.Add("MaturityCalculator", MaturityCalculator);
			CreateZeroCouponBondMarketData_args.Add("TagName", TagName);
			CreateZeroCouponBondMarketData_args.Add("TagType", TagType);
			return F3Formatter.f3_style_serialization("CreateZeroCouponBondMarketData", CreateZeroCouponBondMarketData_args);
		}

		// <summary>
		// Create a market data set containing zero-coupon bond prices paying 100 at maturity.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="Currency">Currency of the zero-coupon bond.</param>
		// <param name="Maturities">Vector of bond maturities.</param>
		// <param name="Quotes">Vector of bond prices.</param>
		// <param name="MaturityCalculator">Method for calculating the maturities of zero-coupon bonds. Default value: BasicMonthYear.</param>
		// <param name="TagName">Name-part of the market data tag.</param>
		// <param name="TagType">Type-part of the market data tag.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateZeroCouponBondPriceMarketData(object MarketDataSetName, object Currency, object Maturities, object Quotes, object MaturityCalculator, object TagName, object TagType)
		{

			Hashtable CreateZeroCouponBondPriceMarketData_args = new Hashtable();
			CreateZeroCouponBondPriceMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateZeroCouponBondPriceMarketData_args.Add("Currency", Currency);
			CreateZeroCouponBondPriceMarketData_args.Add("Maturities", Maturities);
			CreateZeroCouponBondPriceMarketData_args.Add("Quotes", Quotes);
			CreateZeroCouponBondPriceMarketData_args.Add("MaturityCalculator", MaturityCalculator);
			CreateZeroCouponBondPriceMarketData_args.Add("TagName", TagName);
			CreateZeroCouponBondPriceMarketData_args.Add("TagType", TagType);
			return F3Formatter.f3_style_serialization("CreateZeroCouponBondPriceMarketData", CreateZeroCouponBondPriceMarketData_args);
		}

		// <summary>
		// Create a single currency zero coupon bond type.
		// </summary>
		// <param name="BondTypeName">Name to use for the created bond type.</param>
		// <param name="SettlementConvention">Settlement convention.</param>
		// <param name="YieldConvention">Default yield convention.</param>
		// <param name="AccrualConvention">Accrual convention for accrued interest. This argument is unused.. Default value: default-constructed instance of type accrual_convention.</param>
		// <param name="Currency">Currency for settlement and all cash flows.</param>
		// <param name="UniqueID">Optional unique ID for the created bond type. Default value: default-constructed instance of type curve_name.</param>
		// <returns>Retuns the name of the constructed object of type BondType.</returns>
		public object CreateZeroCouponBondType(object BondTypeName, object SettlementConvention, object YieldConvention, object AccrualConvention, object Currency, object UniqueID)
		{

			Hashtable CreateZeroCouponBondType_args = new Hashtable();
			CreateZeroCouponBondType_args.Add("BondTypeName", BondTypeName);
			CreateZeroCouponBondType_args.Add("SettlementConvention", SettlementConvention);
			CreateZeroCouponBondType_args.Add("YieldConvention", YieldConvention);
			CreateZeroCouponBondType_args.Add("AccrualConvention", AccrualConvention);
			CreateZeroCouponBondType_args.Add("Currency", Currency);
			CreateZeroCouponBondType_args.Add("UniqueID", UniqueID);
			return F3Formatter.f3_style_serialization("CreateZeroCouponBondType", CreateZeroCouponBondType_args);
		}

		// <summary>
		// Create a market data set containing zero-coupon bond prices or yields paying 100 at maturity.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="Currency">Currency of the zero-coupon bond.</param>
		// <param name="YieldConvention">The yield convention in which the bond prices are quoted.</param>
		// <param name="Maturities">Vector of bond maturities.</param>
		// <param name="Quotes">Vector of bond prices or yields.</param>
		// <param name="MaturityCalculator">Method for calculating the maturities of zero-coupon bonds. Default value: BasicMonthYear.</param>
		// <param name="TagName">Name-part of the market data tag.</param>
		// <param name="TagType">Type-part of the market data tag.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateZeroCouponBondYieldMarketData(object MarketDataSetName, object Currency, object YieldConvention, object Maturities, object Quotes, object MaturityCalculator, object TagName, object TagType)
		{

			Hashtable CreateZeroCouponBondYieldMarketData_args = new Hashtable();
			CreateZeroCouponBondYieldMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateZeroCouponBondYieldMarketData_args.Add("Currency", Currency);
			CreateZeroCouponBondYieldMarketData_args.Add("YieldConvention", YieldConvention);
			CreateZeroCouponBondYieldMarketData_args.Add("Maturities", Maturities);
			CreateZeroCouponBondYieldMarketData_args.Add("Quotes", Quotes);
			CreateZeroCouponBondYieldMarketData_args.Add("MaturityCalculator", MaturityCalculator);
			CreateZeroCouponBondYieldMarketData_args.Add("TagName", TagName);
			CreateZeroCouponBondYieldMarketData_args.Add("TagType", TagType);
			return F3Formatter.f3_style_serialization("CreateZeroCouponBondYieldMarketData", CreateZeroCouponBondYieldMarketData_args);
		}

		// <summary>
		// Create discount yield convention for zero coupon bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldAccrualConvention">Accrual convention for measuring the accrual fraction used in yield calculation.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateZeroCouponDiscountYieldConvention(object YieldConventionName, object YieldAccrualConvention)
		{

			Hashtable CreateZeroCouponDiscountYieldConvention_args = new Hashtable();
			CreateZeroCouponDiscountYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateZeroCouponDiscountYieldConvention_args.Add("YieldAccrualConvention", YieldAccrualConvention);
			return F3Formatter.f3_style_serialization("CreateZeroCouponDiscountYieldConvention", CreateZeroCouponDiscountYieldConvention_args);
		}

		// <summary>
		// Create an index representing the value of a zero coupon cash flow.
		// </summary>
		// <param name="IndexName">Name to use for the index.</param>
		// <param name="Currency">Currency underlying cash flow.</param>
		// <param name="RedemptionDate">Redemption date of the zero coupon cash flow.</param>
		// <param name="CollateralAgreement">Agreement specifying how the coupon is to be collateralized. Default value: ZeroCollateral.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object CreateZeroCouponIndex(object IndexName, object Currency, object RedemptionDate, object CollateralAgreement)
		{

			Hashtable CreateZeroCouponIndex_args = new Hashtable();
			CreateZeroCouponIndex_args.Add("IndexName", IndexName);
			CreateZeroCouponIndex_args.Add("Currency", Currency);
			CreateZeroCouponIndex_args.Add("RedemptionDate", RedemptionDate);
			CreateZeroCouponIndex_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("CreateZeroCouponIndex", CreateZeroCouponIndex_args);
		}

		// <summary>
		// Create a single currency zero coupon inflation swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap (may be different from the trade date).</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional amount of  the fixed leg.</param>
		// <param name="ZeroCoupon">The zero coupon rate.</param>
		// <param name="FixedLegMarketConvention">Fixed leg market conventions.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateZeroCouponInflationSwap(object ProductName, object StartDate, object Maturity, object Notional, object ZeroCoupon, object FixedLegMarketConvention, object FloatingRateIndex, object FloatingLegMarketConvention, object Margin, object PayRec)
		{

			Hashtable CreateZeroCouponInflationSwap_args = new Hashtable();
			CreateZeroCouponInflationSwap_args.Add("ProductName", ProductName);
			CreateZeroCouponInflationSwap_args.Add("StartDate", StartDate);
			CreateZeroCouponInflationSwap_args.Add("Maturity", Maturity);
			CreateZeroCouponInflationSwap_args.Add("Notional", Notional);
			CreateZeroCouponInflationSwap_args.Add("ZeroCoupon", ZeroCoupon);
			CreateZeroCouponInflationSwap_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateZeroCouponInflationSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateZeroCouponInflationSwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateZeroCouponInflationSwap_args.Add("Margin", Margin);
			CreateZeroCouponInflationSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateZeroCouponInflationSwap", CreateZeroCouponInflationSwap_args);
		}

		// <summary>
		// Create a market data set containing a set of zero coupon inflation swap rates.
		// </summary>
		// <param name="MarketDataSetName">Name of market data set.</param>
		// <param name="Maturities">Vector of quote maturities.</param>
		// <param name="ZeroCouponInflationSwapRates">Vector of zero coupon inflation swap rates.</param>
		// <param name="ZeroCouponInflationName">Name of zero coupon inflation swap market data.</param>
		// <param name="ZeroCouponInflationType">Type of zero coupon inflation swap market data.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the fixed leg.</param>
		// <param name="InflationIndex">Inflation index (RPI).</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object CreateZeroCouponInflationSwapMarketData(object MarketDataSetName, object Maturities, object ZeroCouponInflationSwapRates, object ZeroCouponInflationName, object ZeroCouponInflationType, object FixedLegMarketConventions, object InflationIndex, object FloatingLegMarketConventions)
		{

			Hashtable CreateZeroCouponInflationSwapMarketData_args = new Hashtable();
			CreateZeroCouponInflationSwapMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			CreateZeroCouponInflationSwapMarketData_args.Add("Maturities", Maturities);
			CreateZeroCouponInflationSwapMarketData_args.Add("ZeroCouponInflationSwapRates", ZeroCouponInflationSwapRates);
			CreateZeroCouponInflationSwapMarketData_args.Add("ZeroCouponInflationName", ZeroCouponInflationName);
			CreateZeroCouponInflationSwapMarketData_args.Add("ZeroCouponInflationType", ZeroCouponInflationType);
			CreateZeroCouponInflationSwapMarketData_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			CreateZeroCouponInflationSwapMarketData_args.Add("InflationIndex", InflationIndex);
			CreateZeroCouponInflationSwapMarketData_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("CreateZeroCouponInflationSwapMarketData", CreateZeroCouponInflationSwapMarketData_args);
		}

		// <summary>
		// Create an investment yield convention for zero coupon bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldAccrualConvention">Accrual convention for measuring the accrual fraction used in yield calculation.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateZeroCouponInvestmentYieldConvention(object YieldConventionName, object YieldAccrualConvention)
		{

			Hashtable CreateZeroCouponInvestmentYieldConvention_args = new Hashtable();
			CreateZeroCouponInvestmentYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateZeroCouponInvestmentYieldConvention_args.Add("YieldAccrualConvention", YieldAccrualConvention);
			return F3Formatter.f3_style_serialization("CreateZeroCouponInvestmentYieldConvention", CreateZeroCouponInvestmentYieldConvention_args);
		}

		// <summary>
		// Create a zero coupon leg.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Date on which the leg starts.</param>
		// <param name="Maturity">Specification of the date on which the leg matures.</param>
		// <param name="Notional">Notional amount of the leg.</param>
		// <param name="Currency">Payment currency of the leg.</param>
		// <param name="ZeroCouponRate">The coupon which is compounded and paid at the end of the leg.</param>
		// <param name="MarketConvention">Schedule generator for the leg.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the cash flow.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateZeroCouponLeg(object ProductName, object StartDate, object Maturity, object Notional, object Currency, object ZeroCouponRate, object MarketConvention, object PayRec)
		{

			Hashtable CreateZeroCouponLeg_args = new Hashtable();
			CreateZeroCouponLeg_args.Add("ProductName", ProductName);
			CreateZeroCouponLeg_args.Add("StartDate", StartDate);
			CreateZeroCouponLeg_args.Add("Maturity", Maturity);
			CreateZeroCouponLeg_args.Add("Notional", Notional);
			CreateZeroCouponLeg_args.Add("Currency", Currency);
			CreateZeroCouponLeg_args.Add("ZeroCouponRate", ZeroCouponRate);
			CreateZeroCouponLeg_args.Add("MarketConvention", MarketConvention);
			CreateZeroCouponLeg_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateZeroCouponLeg", CreateZeroCouponLeg_args);
		}

		// <summary>
		// Create a zero coupon swap.
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Start date of the swap.</param>
		// <param name="Maturity">Swap maturity.</param>
		// <param name="Notional">The notional amount of the swap.</param>
		// <param name="ZeroCouponRate">The coupon which is compounded and paid at the end of the fixed leg.</param>
		// <param name="FixedLegMarketConvention">Compounding schedule generator for the fixed leg.</param>
		// <param name="FloatingRateIndex">Index describing the floating rate.</param>
		// <param name="Margin">Margin over the floating rate paid on each floating leg payment. Default value: 0.0.</param>
		// <param name="FloatingLegMarketConvention">Floating leg market conventions.</param>
		// <param name="PayRec">Flag indicating payment or receipt of the fixed leg's payments.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object CreateZeroCouponSwap(object ProductName, object StartDate, object Maturity, object Notional, object ZeroCouponRate, object FixedLegMarketConvention, object FloatingRateIndex, object Margin, object FloatingLegMarketConvention, object PayRec)
		{

			Hashtable CreateZeroCouponSwap_args = new Hashtable();
			CreateZeroCouponSwap_args.Add("ProductName", ProductName);
			CreateZeroCouponSwap_args.Add("StartDate", StartDate);
			CreateZeroCouponSwap_args.Add("Maturity", Maturity);
			CreateZeroCouponSwap_args.Add("Notional", Notional);
			CreateZeroCouponSwap_args.Add("ZeroCouponRate", ZeroCouponRate);
			CreateZeroCouponSwap_args.Add("FixedLegMarketConvention", FixedLegMarketConvention);
			CreateZeroCouponSwap_args.Add("FloatingRateIndex", FloatingRateIndex);
			CreateZeroCouponSwap_args.Add("Margin", Margin);
			CreateZeroCouponSwap_args.Add("FloatingLegMarketConvention", FloatingLegMarketConvention);
			CreateZeroCouponSwap_args.Add("PayRec", PayRec);
			return F3Formatter.f3_style_serialization("CreateZeroCouponSwap", CreateZeroCouponSwap_args);
		}

		// <summary>
		// Create a yield convention for zero coupon bonds.
		// </summary>
		// <param name="YieldConventionName">Name to use for the created yield convention.</param>
		// <param name="YieldAccrualConvention">Accrual convention for measuring the accrual fraction used in yield calculation.</param>
		// <param name="CompoundingFrequency">The number of compounding periods per year.</param>
		// <returns>Retuns the name of the constructed object of type YieldCalculator.</returns>
		public object CreateZeroCouponYieldConvention(object YieldConventionName, object YieldAccrualConvention, object CompoundingFrequency)
		{

			Hashtable CreateZeroCouponYieldConvention_args = new Hashtable();
			CreateZeroCouponYieldConvention_args.Add("YieldConventionName", YieldConventionName);
			CreateZeroCouponYieldConvention_args.Add("YieldAccrualConvention", YieldAccrualConvention);
			CreateZeroCouponYieldConvention_args.Add("CompoundingFrequency", CompoundingFrequency);
			return F3Formatter.f3_style_serialization("CreateZeroCouponYieldConvention", CreateZeroCouponYieldConvention_args);
		}

		// <summary>
		// Create a calibration target for a zero-dimensional curve.
		// </summary>
		// <param name="CalibrationTargetName">Name to use for the calibration target.</param>
		// <param name="CurveTag">Target curve tag.</param>
		// <param name="InitialValues">Initial values for parameters.</param>
		// <param name="BoundConstraints">Bound constraints for parameters. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="FixedIndices">Indices for fixed parameters. Default value: default-constructed instance of type unsigned_small_integer_vector.</param>
		// <param name="OptimizationObjective">Objective for the calibration. Default value: SingleCurrencyValue.</param>
		// <param name="UseGhosts">Flag indicating whether to use ghost curves. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type CalibrationTarget.</returns>
		public object CreateZeroDimensionalCalibrationTarget(object CalibrationTargetName, object CurveTag, object InitialValues, object BoundConstraints, object FixedIndices, object OptimizationObjective, object UseGhosts)
		{

			Hashtable CreateZeroDimensionalCalibrationTarget_args = new Hashtable();
			CreateZeroDimensionalCalibrationTarget_args.Add("CalibrationTargetName", CalibrationTargetName);
			CreateZeroDimensionalCalibrationTarget_args.Add("CurveTag", CurveTag);
			CreateZeroDimensionalCalibrationTarget_args.Add("InitialValues", InitialValues);
			CreateZeroDimensionalCalibrationTarget_args.Add("BoundConstraints", BoundConstraints);
			CreateZeroDimensionalCalibrationTarget_args.Add("FixedIndices", FixedIndices);
			CreateZeroDimensionalCalibrationTarget_args.Add("OptimizationObjective", OptimizationObjective);
			CreateZeroDimensionalCalibrationTarget_args.Add("UseGhosts", UseGhosts);
			return F3Formatter.f3_style_serialization("CreateZeroDimensionalCalibrationTarget", CreateZeroDimensionalCalibrationTarget_args);
		}

		// <summary>
		// Return the current system time.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object CurrentSystemTime(object DummyArgument)
		{

			Hashtable CurrentSystemTime_args = new Hashtable();
			CurrentSystemTime_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("CurrentSystemTime", CurrentSystemTime_args);
		}

		// <summary>
		// Query a curve-build for diagnostic information.
		// </summary>
		// <param name="Model">Model containing the curve to be queried.</param>
		// <param name="CurveTag">Tag identifying the curve to be queried.</param>
		// <param name="Requests">Requests specifying the types of query to be made.</param>
		public object CurveBuildInfo(object Model, object CurveTag, object Requests)
		{

			Hashtable CurveBuildInfo_args = new Hashtable();
			CurveBuildInfo_args.Add("Model", Model);
			CurveBuildInfo_args.Add("CurveTag", CurveTag);
			CurveBuildInfo_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("CurveBuildInfo", CurveBuildInfo_args);
		}

		// <summary>
		// Build a list of dates from a roll schedule.
		// </summary>
		// <param name="RollSchedule">Roll schedule from which the date list is formed.</param>
		// <param name="DateListBuilder">Specification of how the date list is formed.</param>
		public object DateList(object RollSchedule, object DateListBuilder)
		{

			Hashtable DateList_args = new Hashtable();
			DateList_args.Add("RollSchedule", RollSchedule);
			DateList_args.Add("DateListBuilder", DateListBuilder);
			return F3Formatter.f3_style_serialization("DateList", DateList_args);
		}

		// <summary>
		// Calculate a day count fraction.
		// </summary>
		// <param name="FirstDate">First date.</param>
		// <param name="SecondDate">Second date.</param>
		// <param name="DayCountType">Day count convention to use.</param>
		public object DayCountFraction(object FirstDate, object SecondDate, object DayCountType)
		{

			Hashtable DayCountFraction_args = new Hashtable();
			DayCountFraction_args.Add("FirstDate", FirstDate);
			DayCountFraction_args.Add("SecondDate", SecondDate);
			DayCountFraction_args.Add("DayCountType", DayCountType);
			return F3Formatter.f3_style_serialization("DayCountFraction", DayCountFraction_args);
		}

		// <summary>
		// Decompose a date into its day, month and year.
		// </summary>
		// <param name="Date">Date_ to decompose.</param>
		public object DecomposeDate(object Date_)
		{

			Hashtable DecomposeDate_args = new Hashtable();
			DecomposeDate_args.Add("Date", Date_);
			return F3Formatter.f3_style_serialization("DecomposeDate", DecomposeDate_args);
		}

		// <summary>
		// Perform matrix decomposition on a given matrix.
		// </summary>
		// <param name="InputMatrix">Input matrix.</param>
		// <param name="DecompositionMethod">Method to use for the decomposition.</param>
		// <param name="DoRisk">True if risk of input matrix is to be evaluated. Default value: false.</param>
		public object DecomposeMatrix(object InputMatrix, object DecompositionMethod, object DoRisk)
		{

			Hashtable DecomposeMatrix_args = new Hashtable();
			DecomposeMatrix_args.Add("InputMatrix", InputMatrix);
			DecomposeMatrix_args.Add("DecompositionMethod", DecompositionMethod);
			DecomposeMatrix_args.Add("DoRisk", DoRisk);
			return F3Formatter.f3_style_serialization("DecomposeMatrix", DecomposeMatrix_args);
		}

		// <summary>
		// Remove an object from a repository.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		// <param name="ObjectName">Name of the object.</param>
		public object DeleteObject(object RepositoryName, object ObjectName)
		{

			Hashtable DeleteObject_args = new Hashtable();
			DeleteObject_args.Add("RepositoryName", RepositoryName);
			DeleteObject_args.Add("ObjectName", ObjectName);
			return F3Formatter.f3_style_serialization("DeleteObject", DeleteObject_args);
		}

		// <summary>
		// Form a curve tag for a discounting curve.
		// </summary>
		// <param name="Currency">Currency in which discounting will occur.</param>
		// <param name="CollateralAgreement">Agreement under which the flow being discounted is collateralized. Default value: ZeroCollateral.</param>
		public object DiscountCurveTag(object Currency, object CollateralAgreement)
		{

			Hashtable DiscountCurveTag_args = new Hashtable();
			DiscountCurveTag_args.Add("Currency", Currency);
			DiscountCurveTag_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("DiscountCurveTag", DiscountCurveTag_args);
		}

		// <summary>
		// Displays ObjectConstructionWarnings for all user constructed types in the context.
		// </summary>
		// <param name="Dummy">A Dummy argument.</param>
		public object DisplayAllObjectConstructionWarnings(object Dummy)
		{

			Hashtable DisplayAllObjectConstructionWarnings_args = new Hashtable();
			DisplayAllObjectConstructionWarnings_args.Add("Dummy", Dummy);
			return F3Formatter.f3_style_serialization("DisplayAllObjectConstructionWarnings", DisplayAllObjectConstructionWarnings_args);
		}

		// <summary>
		// Display the properties of an object.
		// </summary>
		// <param name="ObjectType">Repository to which the object belongs.</param>
		// <param name="ObjectName">Name of object.</param>
		// <param name="ShowDefaults">Flag controlling explicit display of default values of optional construction arguments. Default value: True.</param>
		public object DisplayObject(object ObjectType, object ObjectName, object ShowDefaults)
		{

			Hashtable DisplayObject_args = new Hashtable();
			DisplayObject_args.Add("ObjectType", ObjectType);
			DisplayObject_args.Add("ObjectName", ObjectName);
			DisplayObject_args.Add("ShowDefaults", ShowDefaults);
			return F3Formatter.f3_style_serialization("DisplayObject", DisplayObject_args);
		}

		// <summary>
		// Calculate the effective length of a length set, given an anchor date and a length calculator.
		// </summary>
		// <param name="AnchorDate">Date from which to base the length calculation.</param>
		// <param name="LengthCalculator">Length calculator.</param>
		// <param name="LengthSet">Length set.</param>
		public object EffectiveLength(object AnchorDate, object LengthCalculator, object LengthSet)
		{

			Hashtable EffectiveLength_args = new Hashtable();
			EffectiveLength_args.Add("AnchorDate", AnchorDate);
			EffectiveLength_args.Add("LengthCalculator", LengthCalculator);
			EffectiveLength_args.Add("LengthSet", LengthSet);
			return F3Formatter.f3_style_serialization("EffectiveLength", EffectiveLength_args);
		}

		// <summary>
		// Perform eigenvalue and eigenvector decomposition of a real symmetric matrix.
		// </summary>
		// <param name="InputMatrix">A real symmetric matrix.</param>
		// <param name="DoRisk">True if risk of input matrix is to be evaluated. Default value: false.</param>
		public object EigenDecomposition(object InputMatrix, object DoRisk)
		{

			Hashtable EigenDecomposition_args = new Hashtable();
			EigenDecomposition_args.Add("InputMatrix", InputMatrix);
			EigenDecomposition_args.Add("DoRisk", DoRisk);
			return F3Formatter.f3_style_serialization("EigenDecomposition", EigenDecomposition_args);
		}

		// <summary>
		// Create an AST-based modifier for a product in a valuation context.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Index">Index to build AST from.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="EliminateAllConditionals">True to eliminate all conditional choice points through trigger replacement. Default value: true.</param>
		// <param name="ConditionalReplacementLimit">Maximum number of conditional choice points to replace, if EliminateAllConditionals not set. Default value: 0.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object EmitIndexASTModifier(object ModifierName, object Index, object RefSpec, object Model, object ValuationMethod, object EliminateAllConditionals, object ConditionalReplacementLimit)
		{

			Hashtable EmitIndexASTModifier_args = new Hashtable();
			EmitIndexASTModifier_args.Add("ModifierName", ModifierName);
			EmitIndexASTModifier_args.Add("Index", Index);
			EmitIndexASTModifier_args.Add("RefSpec", RefSpec);
			EmitIndexASTModifier_args.Add("Model", Model);
			EmitIndexASTModifier_args.Add("ValuationMethod", ValuationMethod);
			EmitIndexASTModifier_args.Add("EliminateAllConditionals", EliminateAllConditionals);
			EmitIndexASTModifier_args.Add("ConditionalReplacementLimit", ConditionalReplacementLimit);
			return F3Formatter.f3_style_serialization("EmitIndexASTModifier", EmitIndexASTModifier_args);
		}

		// <summary>
		// Create an AST-based modifier for a product in a valuation context.
		// </summary>
		// <param name="ModifierName">Name to use for the new modifier.</param>
		// <param name="Product">Product to build AST from.</param>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="EliminateAllConditionals">True to eliminate all conditional choice points through trigger replacement. Default value: true.</param>
		// <param name="ConditionalReplacementLimit">Maximum number of conditional choice points to replace, if EliminateAllConditionals not set. Default value: 0.</param>
		// <returns>Retuns the name of the constructed object of type ModifierSource.</returns>
		public object EmitProductASTModifier(object ModifierName, object Product, object Model, object ValuationMethod, object EliminateAllConditionals, object ConditionalReplacementLimit)
		{

			Hashtable EmitProductASTModifier_args = new Hashtable();
			EmitProductASTModifier_args.Add("ModifierName", ModifierName);
			EmitProductASTModifier_args.Add("Product", Product);
			EmitProductASTModifier_args.Add("Model", Model);
			EmitProductASTModifier_args.Add("ValuationMethod", ValuationMethod);
			EmitProductASTModifier_args.Add("EliminateAllConditionals", EliminateAllConditionals);
			EmitProductASTModifier_args.Add("ConditionalReplacementLimit", ConditionalReplacementLimit);
			return F3Formatter.f3_style_serialization("EmitProductASTModifier", EmitProductASTModifier_args);
		}

		// <summary>
		// Enable or disable tickers.
		// </summary>
		// <param name="Enable">True to enable, False to disable.</param>
		public object EnableTickers(object Enable)
		{

			Hashtable EnableTickers_args = new Hashtable();
			EnableTickers_args.Add("Enable", Enable);
			return F3Formatter.f3_style_serialization("EnableTickers", EnableTickers_args);
		}

		// <summary>
		// Return the value of an environment variable or a list of variables.
		// </summary>
		// <param name="VariableNames">Variable name(s).</param>
		public object Environment(object VariableNames)
		{

			Hashtable Environment_args = new Hashtable();
			Environment_args.Add("VariableNames", VariableNames);
			return F3Formatter.f3_style_serialization("Environment", Environment_args);
		}

		// <summary>
		// Value a European option.
		// </summary>
		// <param name="Forward">Forward value of the underlying asset.</param>
		// <param name="Strike">Strike specification.</param>
		// <param name="TimeToExpiry">Time to expiry, in years.</param>
		// <param name="Payoff">Payoff specification.</param>
		// <param name="Volatility">Volatility specification for the option.</param>
		// <param name="Requests">Array of requests of valuation information. Default value: Value.</param>
		public object EuroOption(object Forward, object Strike, object TimeToExpiry, object Payoff, object Volatility, object Requests)
		{

			Hashtable EuroOption_args = new Hashtable();
			EuroOption_args.Add("Forward", Forward);
			EuroOption_args.Add("Strike", Strike);
			EuroOption_args.Add("TimeToExpiry", TimeToExpiry);
			EuroOption_args.Add("Payoff", Payoff);
			EuroOption_args.Add("Volatility", Volatility);
			EuroOption_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("EuroOption", EuroOption_args);
		}

		// <summary>
		// Evaluate a two-dimensional function.
		// </summary>
		// <param name="Function">Two-dimensional function.</param>
		// <param name="XPoint">Evaluation X (or first dimension) point.</param>
		// <param name="YPoint">Evaluation Y (or second dimension) point.</param>
		public object Evaluate2dFunction(object Function_name, object XPoint, object YPoint)
		{

			Hashtable Evaluate2dFunction_args = new Hashtable();
			Evaluate2dFunction_args.Add("Function", Function_name);
			Evaluate2dFunction_args.Add("XPoint", XPoint);
			Evaluate2dFunction_args.Add("YPoint", YPoint);
			return F3Formatter.f3_style_serialization("Evaluate2dFunction", Evaluate2dFunction_args);
		}

		// <summary>
		// Evaluate a three-dimensional function.
		// </summary>
		// <param name="Function">Three-dimensional function.</param>
		// <param name="XPoint">Evaluation X (or first dimension) point.</param>
		// <param name="YPoint">Evaluation Y (or second dimension) point.</param>
		// <param name="ZPoint">Evaluation Z (or third dimension) point.</param>
		public object Evaluate3dFunction(object Function_name, object XPoint, object YPoint, object ZPoint)
		{

			Hashtable Evaluate3dFunction_args = new Hashtable();
			Evaluate3dFunction_args.Add("Function", Function_name);
			Evaluate3dFunction_args.Add("XPoint", XPoint);
			Evaluate3dFunction_args.Add("YPoint", YPoint);
			Evaluate3dFunction_args.Add("ZPoint", ZPoint);
			return F3Formatter.f3_style_serialization("Evaluate3dFunction", Evaluate3dFunction_args);
		}

		// <summary>
		// Evaluate a one-dimensional complex function.
		// </summary>
		// <param name="Function">One-dimensional complex function.</param>
		// <param name="Point">Evaluation point.</param>
		public object EvaluateComplexFunction(object Function_name, object Point)
		{

			Hashtable EvaluateComplexFunction_args = new Hashtable();
			EvaluateComplexFunction_args.Add("Function", Function_name);
			EvaluateComplexFunction_args.Add("Point", Point);
			return F3Formatter.f3_style_serialization("EvaluateComplexFunction", EvaluateComplexFunction_args);
		}

		// <summary>
		// Evaluate a one-dimensional function.
		// </summary>
		// <param name="Function">One-dimensional function.</param>
		// <param name="XPoint">Evaluation point.</param>
		public object EvaluateFunction(object Function_name, object XPoint)
		{

			Hashtable EvaluateFunction_args = new Hashtable();
			EvaluateFunction_args.Add("Function", Function_name);
			EvaluateFunction_args.Add("XPoint", XPoint);
			return F3Formatter.f3_style_serialization("EvaluateFunction", EvaluateFunction_args);
		}

		// <summary>
		// Evaluate a valuation metric.
		// </summary>
		// <param name="Model">Model to use for the evaluation.</param>
		// <param name="Product">Product whose valuation metric is to be computed.</param>
		// <param name="ValuationMethod">Valuation specification to use for the evaluation.</param>
		// <param name="Metric">Valuation metric to compute.</param>
		// <param name="DoRisk">Flag indicating whether risk is to be evaluated. Default value: false.</param>
		public object EvaluateValuationMetric(object Model, object Product, object ValuationMethod, object Metric, object DoRisk)
		{

			Hashtable EvaluateValuationMetric_args = new Hashtable();
			EvaluateValuationMetric_args.Add("Model", Model);
			EvaluateValuationMetric_args.Add("Product", Product);
			EvaluateValuationMetric_args.Add("ValuationMethod", ValuationMethod);
			EvaluateValuationMetric_args.Add("Metric", Metric);
			EvaluateValuationMetric_args.Add("DoRisk", DoRisk);
			return F3Formatter.f3_style_serialization("EvaluateValuationMetric", EvaluateValuationMetric_args);
		}

		// <summary>
		// Execute an evaluation function on a vector of underlyings using a vector of indices.
		// </summary>
		// <param name="Function">Evaluation function.</param>
		// <param name="Underlyings">Vector of underlyings.</param>
		// <param name="Indices">Vector of indices.</param>
		// <param name="ParamTagUnderlyings">Tag to use for the vector of underlyings.</param>
		// <param name="ParamTagIndices">Tag to use for the vector of indices.</param>
		public object ExecuteEvaluationFunction(object Function_name, object Underlyings, object Indices, object ParamTagUnderlyings, object ParamTagIndices)
		{

			Hashtable ExecuteEvaluationFunction_args = new Hashtable();
			ExecuteEvaluationFunction_args.Add("Function", Function_name);
			ExecuteEvaluationFunction_args.Add("Underlyings", Underlyings);
			ExecuteEvaluationFunction_args.Add("Indices", Indices);
			ExecuteEvaluationFunction_args.Add("ParamTagUnderlyings", ParamTagUnderlyings);
			ExecuteEvaluationFunction_args.Add("ParamTagIndices", ParamTagIndices);
			return F3Formatter.f3_style_serialization("ExecuteEvaluationFunction", ExecuteEvaluationFunction_args);
		}

		// <summary>
		// Run commands from a function file.
		// </summary>
		// <param name="FileName">Input file, or other stream-based resource.</param>
		// <param name="ExcludedFunctions">The set of functions that will be suppressed when encountered in the input stream.</param>
		// <param name="OptionalSigningKey">Key string for unlocking signed input streams. Default value: default-constructed instance of type password.</param>
		public object ExecuteFunctionFile(object FileName, object ExcludedFunctions, object OptionalSigningKey)
		{

			Hashtable ExecuteFunctionFile_args = new Hashtable();
			ExecuteFunctionFile_args.Add("FileName", FileName);
			ExecuteFunctionFile_args.Add("ExcludedFunctions", ExcludedFunctions);
			ExecuteFunctionFile_args.Add("OptionalSigningKey", OptionalSigningKey);
			return F3Formatter.f3_style_serialization("ExecuteFunctionFile", ExecuteFunctionFile_args);
		}

		// <summary>
		// Execute a function call using a network connection.
		// </summary>
		// <param name="CallString">Function call in F3ML format.</param>
		// <param name="Connection">Connection.</param>
		public object ExecuteNetworkFunctionCall(object CallString, object Connection)
		{

			Hashtable ExecuteNetworkFunctionCall_args = new Hashtable();
			ExecuteNetworkFunctionCall_args.Add("CallString", CallString);
			ExecuteNetworkFunctionCall_args.Add("Connection", Connection);
			return F3Formatter.f3_style_serialization("ExecuteNetworkFunctionCall", ExecuteNetworkFunctionCall_args);
		}

		// <summary>
		// Execute a coherent set of function calls using a network connection.
		// </summary>
		// <param name="CallString">Function calls in F3ML format.</param>
		// <param name="Connection">Connection.</param>
		public object ExecuteNetworkFunctionCallSet(object CallString, object Connection)
		{

			Hashtable ExecuteNetworkFunctionCallSet_args = new Hashtable();
			ExecuteNetworkFunctionCallSet_args.Add("CallString", CallString);
			ExecuteNetworkFunctionCallSet_args.Add("Connection", Connection);
			return F3Formatter.f3_style_serialization("ExecuteNetworkFunctionCallSet", ExecuteNetworkFunctionCallSet_args);
		}

		// <summary>
		// Run a task serialized in a file.
		// </summary>
		// <param name="Task">Input file, or other stream-based resource.</param>
		public object ExecuteTask(object Task)
		{

			Hashtable ExecuteTask_args = new Hashtable();
			ExecuteTask_args.Add("Task", Task);
			return F3Formatter.f3_style_serialization("ExecuteTask", ExecuteTask_args);
		}

		// <summary>
		// Export all user-created objects from the given list of repositories.
		// </summary>
		// <param name="RepositoryNames">repositories from which to export.</param>
		// <param name="CallTarget">Output file, or other stream-based resource, for the exported object creation calls.</param>
		// <param name="IgnoreMissing">Flag indicating if errors resulting from missing objects or dependencies should be suppressed. Default value: True.</param>
		public object ExportAllObjects(object RepositoryNames, object CallTarget, object IgnoreMissing)
		{

			Hashtable ExportAllObjects_args = new Hashtable();
			ExportAllObjects_args.Add("RepositoryNames", RepositoryNames);
			ExportAllObjects_args.Add("CallTarget", CallTarget);
			ExportAllObjects_args.Add("IgnoreMissing", IgnoreMissing);
			return F3Formatter.f3_style_serialization("ExportAllObjects", ExportAllObjects_args);
		}

		// <summary>
		// Export one or more objects to a file or other stream.
		// </summary>
		// <param name="CallTarget">Output file, or other stream-based resource, for the exported object creation calls.</param>
		// <param name="RepositoryNames">Array of repository names, one per object.</param>
		// <param name="ObjectNames">Array of object names.</param>
		// <param name="IgnoreMissing">Flag indicating if errors resulting from missing objects or dependencies should be suppressed. Default value: True.</param>
		public object ExportObjects(object CallTarget, object RepositoryNames, object ObjectNames, object IgnoreMissing)
		{

			Hashtable ExportObjects_args = new Hashtable();
			ExportObjects_args.Add("CallTarget", CallTarget);
			ExportObjects_args.Add("RepositoryNames", RepositoryNames);
			ExportObjects_args.Add("ObjectNames", ObjectNames);
			ExportObjects_args.Add("IgnoreMissing", IgnoreMissing);
			return F3Formatter.f3_style_serialization("ExportObjects", ExportObjects_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional curve based on the composition of one-dimensional curves.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWith1dCompositionCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag)
		{

			Hashtable ExtendModelWith1dCompositionCurve_args = new Hashtable();
			ExtendModelWith1dCompositionCurve_args.Add("ModelName", ModelName);
			ExtendModelWith1dCompositionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWith1dCompositionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWith1dCompositionCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWith1dCompositionCurve_args.Add("SecondCurveTag", SecondCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWith1dCompositionCurve", ExtendModelWith1dCompositionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a three-dimensional curve that is constantly extrapolated from a two-dimensional surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Two-dimensional underlying curve.</param>
		// <param name="ConstantArgumentIndex">The index corresponding to the three-dimensional function argument that is constant.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object ConstantArgumentIndex)
		{

			Hashtable ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args = new Hashtable();
			ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args.Add("ModelName", ModelName);
			ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args.Add("ConstantArgumentIndex", ConstantArgumentIndex);
			return F3Formatter.f3_style_serialization("ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve", ExtendModelWith2dSurfaceConstantExtrapolationTo3dCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a convexity adjustment curve based on an arbitrary 3d function.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingFunctionCurveTag">Tag identifying the underlying 3d function implementing the adjustment.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWith3dFunctionConvexityAdjustmentCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingFunctionCurveTag)
		{

			Hashtable ExtendModelWith3dFunctionConvexityAdjustmentCurve_args = new Hashtable();
			ExtendModelWith3dFunctionConvexityAdjustmentCurve_args.Add("ModelName", ModelName);
			ExtendModelWith3dFunctionConvexityAdjustmentCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWith3dFunctionConvexityAdjustmentCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWith3dFunctionConvexityAdjustmentCurve_args.Add("UnderlyingFunctionCurveTag", UnderlyingFunctionCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWith3dFunctionConvexityAdjustmentCurve", ExtendModelWith3dFunctionConvexityAdjustmentCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of the curves that are needed for pricing an asset backed credit default swap.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IntegrationMethod">The method used to evaluate integrals.</param>
		// <param name="DifferentiationMethod">The method used to evaluate derivatives.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithABCDSCurves(object ModelName, object BaseModel, object IntegrationMethod, object DifferentiationMethod, object Currency, object CreditContract)
		{

			Hashtable ExtendModelWithABCDSCurves_args = new Hashtable();
			ExtendModelWithABCDSCurves_args.Add("ModelName", ModelName);
			ExtendModelWithABCDSCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithABCDSCurves_args.Add("IntegrationMethod", IntegrationMethod);
			ExtendModelWithABCDSCurves_args.Add("DifferentiationMethod", DifferentiationMethod);
			ExtendModelWithABCDSCurves_args.Add("Currency", Currency);
			ExtendModelWithABCDSCurves_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("ExtendModelWithABCDSCurves", ExtendModelWithABCDSCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of all of the source model's curves.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="SourceModel">Source of curves.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithAllCurvesFromModel(object ModelName, object BaseModel, object SourceModel)
		{

			Hashtable ExtendModelWithAllCurvesFromModel_args = new Hashtable();
			ExtendModelWithAllCurvesFromModel_args.Add("ModelName", ModelName);
			ExtendModelWithAllCurvesFromModel_args.Add("BaseModel", BaseModel);
			ExtendModelWithAllCurvesFromModel_args.Add("SourceModel", SourceModel);
			return F3Formatter.f3_style_serialization("ExtendModelWithAllCurvesFromModel", ExtendModelWithAllCurvesFromModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of all of the source model's market data.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="SourceModel">Source of market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithAllMarketDataFromModel(object ModelName, object BaseModel, object SourceModel)
		{

			Hashtable ExtendModelWithAllMarketDataFromModel_args = new Hashtable();
			ExtendModelWithAllMarketDataFromModel_args.Add("ModelName", ModelName);
			ExtendModelWithAllMarketDataFromModel_args.Add("BaseModel", BaseModel);
			ExtendModelWithAllMarketDataFromModel_args.Add("SourceModel", SourceModel);
			return F3Formatter.f3_style_serialization("ExtendModelWithAllMarketDataFromModel", ExtendModelWithAllMarketDataFromModel_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a factor loading curve based on angle parameterization.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="NumberOfFactors">Total number of factors.</param>
		// <param name="FactorLoadingIndex">An integer specifying which factor loading the new curve is associated with.</param>
		// <param name="UnderlyingAngleCurves">Underlying angle curves.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithAngleParameterizationFactorLoadingCurve(object ModelName, object BaseModel, object CurveTag, object NumberOfFactors, object FactorLoadingIndex, object UnderlyingAngleCurves)
		{

			Hashtable ExtendModelWithAngleParameterizationFactorLoadingCurve_args = new Hashtable();
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("ModelName", ModelName);
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("NumberOfFactors", NumberOfFactors);
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("FactorLoadingIndex", FactorLoadingIndex);
			ExtendModelWithAngleParameterizationFactorLoadingCurve_args.Add("UnderlyingAngleCurves", UnderlyingAngleCurves);
			return F3Formatter.f3_style_serialization("ExtendModelWithAngleParameterizationFactorLoadingCurve", ExtendModelWithAngleParameterizationFactorLoadingCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a continuous asset price curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Identifier to be associated with the new curve.</param>
		// <param name="AssetMarketDataTag">Identifier of the market data object providing the asset price quote.</param>
		// <param name="FundingCurveTag">Identifier of the asset funding curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithAssetPriceCurve(object ModelName, object BaseModel, object CurveTag, object AssetMarketDataTag, object FundingCurveTag)
		{

			Hashtable ExtendModelWithAssetPriceCurve_args = new Hashtable();
			ExtendModelWithAssetPriceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithAssetPriceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithAssetPriceCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithAssetPriceCurve_args.Add("AssetMarketDataTag", AssetMarketDataTag);
			ExtendModelWithAssetPriceCurve_args.Add("FundingCurveTag", FundingCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithAssetPriceCurve", ExtendModelWithAssetPriceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a parameterized incremental correlation surface for hybrid modeling.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new surface.</param>
		// <param name="UnderlyingCurveTag">Tag to be associated with the underlying parameterization curve.</param>
		// <param name="Constrained">Flag indicating whether to impose constraints such that curve values are between -1 and 1.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBlackIncrementalCorrelationSurface(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object Constrained)
		{

			Hashtable ExtendModelWithBlackIncrementalCorrelationSurface_args = new Hashtable();
			ExtendModelWithBlackIncrementalCorrelationSurface_args.Add("ModelName", ModelName);
			ExtendModelWithBlackIncrementalCorrelationSurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithBlackIncrementalCorrelationSurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithBlackIncrementalCorrelationSurface_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithBlackIncrementalCorrelationSurface_args.Add("Constrained", Constrained);
			return F3Formatter.f3_style_serialization("ExtendModelWithBlackIncrementalCorrelationSurface", ExtendModelWithBlackIncrementalCorrelationSurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a capped volatility cube.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketConvention">Market convention for the floating leg.</param>
		// <param name="CapData">Cap or floor market data sets.</param>
		// <param name="SwaptionData">Swaption market data sets.</param>
		// <param name="Smoothing">Heaviside smoothing parameter used in joining the caplet volatility surface to the swaption volatility cube. Default value: 20.</param>
		// <param name="InitialCurves">Initial value functions for the stripped caplet volatility surfaces. Default value: 0.5.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility cube. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="VolConvention">Convention of volatility quotes. Default value: Raw.</param>
		// <param name="CalibrationInterpolation">An interpolation method to be used in cap stripping. Default value: Linear.</param>
		// <param name="Optimizer">Calibration method used for stripping caplet volatilities from market quoted cap volatilities. Default value: RootSearch.</param>
		// <param name="SurfaceInterpolation">An interpolation method to be used for the volatility surface created in the model. Default value: Linear.</param>
		// <param name="CubeInterpolation">A three-dimensional interpolation method to be used for the volatility cube created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBlackVolatilityCube(object ModelName, object BaseModel, object MarketConvention, object CapData, object SwaptionData, object Smoothing, object InitialCurves, object CurveTag, object VolConvention, object CalibrationInterpolation,
		object Optimizer, object SurfaceInterpolation, object CubeInterpolation)
		{

			Hashtable ExtendModelWithBlackVolatilityCube_args = new Hashtable();
			ExtendModelWithBlackVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithBlackVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithBlackVolatilityCube_args.Add("MarketConvention", MarketConvention);
			ExtendModelWithBlackVolatilityCube_args.Add("CapData", CapData);
			ExtendModelWithBlackVolatilityCube_args.Add("SwaptionData", SwaptionData);
			ExtendModelWithBlackVolatilityCube_args.Add("Smoothing", Smoothing);
			ExtendModelWithBlackVolatilityCube_args.Add("InitialCurves", InitialCurves);
			ExtendModelWithBlackVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithBlackVolatilityCube_args.Add("VolConvention", VolConvention);
			ExtendModelWithBlackVolatilityCube_args.Add("CalibrationInterpolation", CalibrationInterpolation);
			ExtendModelWithBlackVolatilityCube_args.Add("Optimizer", Optimizer);
			ExtendModelWithBlackVolatilityCube_args.Add("SurfaceInterpolation", SurfaceInterpolation);
			ExtendModelWithBlackVolatilityCube_args.Add("CubeInterpolation", CubeInterpolation);
			return F3Formatter.f3_style_serialization("ExtendModelWithBlackVolatilityCube", ExtendModelWithBlackVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an implied Black volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Underlying one-dimensional curve providing implied Black volatilities.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBlackVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag)
		{

			Hashtable ExtendModelWithBlackVolatilitySurface_args = new Hashtable();
			ExtendModelWithBlackVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithBlackVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithBlackVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithBlackVolatilitySurface_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithBlackVolatilitySurface", ExtendModelWithBlackVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a bond fixings curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FixingsMarketDataTag">Market data tag that identifies the fixings data.</param>
		// <param name="Index">Index containing Bond to which the fixing is applied.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBondFixingsCurve(object ModelName, object BaseModel, object CurveTag, object FixingsMarketDataTag, object Index)
		{

			Hashtable ExtendModelWithBondFixingsCurve_args = new Hashtable();
			ExtendModelWithBondFixingsCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBondFixingsCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBondFixingsCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBondFixingsCurve_args.Add("FixingsMarketDataTag", FixingsMarketDataTag);
			ExtendModelWithBondFixingsCurve_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("ExtendModelWithBondFixingsCurve", ExtendModelWithBondFixingsCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a bond price curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Identifier to be associated with the new curve.</param>
		// <param name="BondMarketDataTag">Identifier of a market data object providing a bond price quote.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBondPriceCurve(object ModelName, object BaseModel, object CurveTag, object BondMarketDataTag)
		{

			Hashtable ExtendModelWithBondPriceCurve_args = new Hashtable();
			ExtendModelWithBondPriceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBondPriceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBondPriceCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBondPriceCurve_args.Add("BondMarketDataTag", BondMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithBondPriceCurve", ExtendModelWithBondPriceCurve_args);
		}

		// <summary>
		// Form a model from an existing model, and add a bootstrapped short rate volatility curve to it using the Hull-White model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with new curve.</param>
		// <param name="InstrumentStrategy">Strategy specifying the instruments to use in bootstrapping.</param>
		// <param name="InterpolationMethod">Methodology for interpolating the curve.</param>
		// <param name="IntegrationMethod">Integration method for integrals of the short rate volatility function. Default value: default-constructed instance of type integration_method.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedHullWhiteVolatilityCurve(object ModelName, object BaseModel, object CurveTag, object InstrumentStrategy, object InterpolationMethod, object IntegrationMethod)
		{

			Hashtable ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args = new Hashtable();
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("InstrumentStrategy", InstrumentStrategy);
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedHullWhiteVolatilityCurve", ExtendModelWithBootstrappedHullWhiteVolatilityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a discount-like curve implicit in a forward rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag that identifies the resulting curve.</param>
		// <param name="RateIndex">Index specifying the discount rate.</param>
		// <param name="SamplingSchedule">Schedule for sampling the discount rate.</param>
		// <param name="InterpolationMethod">Interpolation method for the discount curve. Default value: LogLinear.</param>
		// <param name="InitialGuess">Initial guess for the discount curve. Default value: 1.0.</param>
		// <param name="Constraint">Constraint to be applied to the discount curve. Default value: NoBoundConstraint.</param>
		// <param name="Optimizer">Optimization algorithm for finding the implied discount curve. Default value: RootSearch.</param>
		// <param name="ValuationControl">Valuation methodology for the calibration. Default value: Passthrough.</param>
		// <param name="UseGhosts">Flag indicating whether to take the last successful calibration as the initial guess. Default value: true.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedImpliedDiscountCurve(object ModelName, object BaseModel, object CurveTag, object RateIndex, object SamplingSchedule, object InterpolationMethod, object InitialGuess, object Constraint, object Optimizer, object ValuationControl,
		object UseGhosts)
		{

			Hashtable ExtendModelWithBootstrappedImpliedDiscountCurve_args = new Hashtable();
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("RateIndex", RateIndex);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("SamplingSchedule", SamplingSchedule);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("InitialGuess", InitialGuess);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("Constraint", Constraint);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("Optimizer", Optimizer);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("ValuationControl", ValuationControl);
			ExtendModelWithBootstrappedImpliedDiscountCurve_args.Add("UseGhosts", UseGhosts);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedImpliedDiscountCurve", ExtendModelWithBootstrappedImpliedDiscountCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolation curve, using a bootstrapper.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="BootstrappingObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <param name="AutoSort">Control specifying whether or not to sort the instrument list. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InterpolationMethod, object BootstrappingObjective, object AutoSort)
		{

			Hashtable ExtendModelWithBootstrappedInterpolationCurve_args = new Hashtable();
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("BootstrappingObjective", BootstrappingObjective);
			ExtendModelWithBootstrappedInterpolationCurve_args.Add("AutoSort", AutoSort);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedInterpolationCurve", ExtendModelWithBootstrappedInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a two-dimensional interpolation curve, using a bootstrapper.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="TwoDimInterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="BootstrappingObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedMaturityLevelInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object TwoDimInterpolationMethod, object BootstrappingObjective)
		{

			Hashtable ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args = new Hashtable();
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("TwoDimInterpolationMethod", TwoDimInterpolationMethod);
			ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args.Add("BootstrappingObjective", BootstrappingObjective);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedMaturityLevelInterpolationCurve", ExtendModelWithBootstrappedMaturityLevelInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolation curve based on a single point, using a bootstrapper.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="InstrumentIndex">Zero-based index that selects the instrument to use.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="BootstrappingObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedSinglePointInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InstrumentIndex, object InterpolationMethod, object BootstrappingObjective)
		{

			Hashtable ExtendModelWithBootstrappedSinglePointInterpolationCurve_args = new Hashtable();
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("InstrumentIndex", InstrumentIndex);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedSinglePointInterpolationCurve_args.Add("BootstrappingObjective", BootstrappingObjective);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedSinglePointInterpolationCurve", ExtendModelWithBootstrappedSinglePointInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolation curve, using a bootstrapper and specifying the target values.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="TargetValues">Target values for the bootstrapper.</param>
		// <param name="TargetValuesTag">Tag identifying the target values.</param>
		// <param name="BootstrappingObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedTargetedInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InterpolationMethod, object TargetValues, object TargetValuesTag, object BootstrappingObjective)
		{

			Hashtable ExtendModelWithBootstrappedTargetedInterpolationCurve_args = new Hashtable();
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("TargetValues", TargetValues);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("TargetValuesTag", TargetValuesTag);
			ExtendModelWithBootstrappedTargetedInterpolationCurve_args.Add("BootstrappingObjective", BootstrappingObjective);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedTargetedInterpolationCurve", ExtendModelWithBootstrappedTargetedInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolation curve, using a bootstrapper with no fixed points.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="BootstrappingObjective">Objective for the bootstrapping. Default value: SingleCurrencyValue.</param>
		// <param name="AutoSort">Control specifying whether or not to sort the instrument list. Default value: false.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithBootstrappedUnanchoredInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InterpolationMethod, object BootstrappingObjective, object AutoSort)
		{

			Hashtable ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args = new Hashtable();
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("BootstrappingObjective", BootstrappingObjective);
			ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args.Add("AutoSort", AutoSort);
			return F3Formatter.f3_style_serialization("ExtendModelWithBootstrappedUnanchoredInterpolationCurve", ExtendModelWithBootstrappedUnanchoredInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a set of calibrated factor loading curves for correlating different processes in hybrid Monte Carlo simulations..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="NamedStateVariableTemplates">Indices and the corresponding mathematical models for which the factor loading curves are applied.</param>
		// <param name="NumberOfFactors">Number of underlying stochastic factors for the correlated processes.</param>
		// <param name="InstrumentStrategies">An array of instrument strategy collections for calibrating the factor loading curves.</param>
		// <param name="TargetValSpec">Valuation specification for computing target values during calibration.</param>
		// <param name="Optimizer">Method for calibration.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves(object ModelName, object BaseModel, object NamedStateVariableTemplates, object NumberOfFactors, object InstrumentStrategies, object TargetValSpec, object Optimizer)
		{

			Hashtable ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args = new Hashtable();
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("NamedStateVariableTemplates", NamedStateVariableTemplates);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("NumberOfFactors", NumberOfFactors);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("InstrumentStrategies", InstrumentStrategies);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("TargetValSpec", TargetValSpec);
			ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args.Add("Optimizer", Optimizer);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves", ExtendModelWithCalibratedAngleParameterizationFactorLoadingCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a set of calibrated full-factor parameter curves for correlating different processes in hybrid Monte Carlo simulations.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IndexProcessPairs">Indices and corresponding mathematical models for which the calibrated curves are applied.</param>
		// <param name="CorrelationMarketDataTag">Tag for terminal correlation market data.</param>
		// <param name="TargetValSpec">Valuation specification for computing target values during calibration.</param>
		// <param name="Optimizer">Optimization method for calibration. Default value: DefaultLeastSquares.</param>
		// <param name="InitialGuess">Calibration initial guess for all target curves. Default value: 0.0.</param>
		// <param name="Constraint">Calibration constraint for all target curves. Default value: NoBoundConstraint.</param>
		// <param name="InterpolationMethod">Interpolation method for all target curves. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedCorrelationCurves(object ModelName, object BaseModel, object IndexProcessPairs, object CorrelationMarketDataTag, object TargetValSpec, object Optimizer, object InitialGuess, object Constraint, object InterpolationMethod)
		{

			Hashtable ExtendModelWithCalibratedCorrelationCurves_args = new Hashtable();
			ExtendModelWithCalibratedCorrelationCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("IndexProcessPairs", IndexProcessPairs);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("CorrelationMarketDataTag", CorrelationMarketDataTag);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("TargetValSpec", TargetValSpec);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("Optimizer", Optimizer);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("InitialGuess", InitialGuess);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("Constraint", Constraint);
			ExtendModelWithCalibratedCorrelationCurves_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedCorrelationCurves", ExtendModelWithCalibratedCorrelationCurves_args);
		}

		// <summary>
		// Extend a model with one or more curves formed by calibration.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CalibrationTarget">Calibration targets.</param>
		// <param name="InstrumentStrategy">Instruments to use for calibration.</param>
		// <param name="Optimizer">Method for calibration.</param>
		// <param name="SourceValuationSpecificationBuilder">Valuation specification builder for source values. Default value: Passthrough.</param>
		// <param name="TargetValuationSpecificationBuilder">Valuation specification builder for target values. Default value: Passthrough.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedCurves(object ModelName, object BaseModel, object CalibrationTarget, object InstrumentStrategy, object Optimizer, object SourceValuationSpecificationBuilder, object TargetValuationSpecificationBuilder)
		{

			Hashtable ExtendModelWithCalibratedCurves_args = new Hashtable();
			ExtendModelWithCalibratedCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedCurves_args.Add("CalibrationTarget", CalibrationTarget);
			ExtendModelWithCalibratedCurves_args.Add("InstrumentStrategy", InstrumentStrategy);
			ExtendModelWithCalibratedCurves_args.Add("Optimizer", Optimizer);
			ExtendModelWithCalibratedCurves_args.Add("SourceValuationSpecificationBuilder", SourceValuationSpecificationBuilder);
			ExtendModelWithCalibratedCurves_args.Add("TargetValuationSpecificationBuilder", TargetValuationSpecificationBuilder);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedCurves", ExtendModelWithCalibratedCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a calibrated volatility surface that uses the SABR model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility surface.</param>
		// <param name="InstrumentStrategy">Instruments to use for calibration.</param>
		// <param name="SABRInitialGuesses">Initial guesses for the SABR parameters.</param>
		// <param name="HoldParametersConstant">Parameters to hold constant.</param>
		// <param name="Optimizer">Method for calibration. Default value: DefaultLeastSquares.</param>
		// <param name="Constraints">An optional array of calibration constraints, one per each parameter that is to be calibrated. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="InterpolationMethod">An interpolation method to be used for the curves created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedSABRCapFloorVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object InstrumentStrategy, object SABRInitialGuesses, object HoldParametersConstant, object Optimizer, object Constraints, object InterpolationMethod)
		{

			Hashtable ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args = new Hashtable();
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("InstrumentStrategy", InstrumentStrategy);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("SABRInitialGuesses", SABRInitialGuesses);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("HoldParametersConstant", HoldParametersConstant);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("Optimizer", Optimizer);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("Constraints", Constraints);
			ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedSABRCapFloorVolatilitySurface", ExtendModelWithCalibratedSABRCapFloorVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a calibrated volatility cube that uses the SABR model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility cube.</param>
		// <param name="SourceCurveTag">Curve tag of the existing volatility cube to which the new volatility cube will be calibrated.</param>
		// <param name="UnderlyingMaturities">Underlying swap maturities for which calibrations are performed.</param>
		// <param name="MarketConvention">Market conventions used to convert maturities to year fractions.</param>
		// <param name="InstrumentStrategies">An array of instrument strategy collections, one for each underlying maturity.</param>
		// <param name="BetaGuesses">A single function or an array of functions that determine the values of the beta parameter at each underlying maturity point.</param>
		// <param name="RhoGuesses">A single function or an array of functions that determine the values of the rho parameter at each underlying maturity point.</param>
		// <param name="NuGuesses">A single function or an array of functions that determine the values of the nu parameter at each underlying maturity point.</param>
		// <param name="KeepFixed">An array of indices indicating which parameters must be held fixed.</param>
		// <param name="Optimizer">Optimization algorithm to be applied at each expiry, and for each tenor. Default value: DefaultLeastSquares.</param>
		// <param name="Constraints">An optional array of calibration constraints, one per each parameter that is to be calibrated. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="InterpolationMethod">An interpolation method to be used for all curves created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube(object ModelName, object BaseModel, object CurveTag, object SourceCurveTag, object UnderlyingMaturities, object MarketConvention, object InstrumentStrategies, object BetaGuesses, object RhoGuesses, object NuGuesses,
		object KeepFixed, object Optimizer, object Constraints, object InterpolationMethod)
		{

			Hashtable ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args = new Hashtable();
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("SourceCurveTag", SourceCurveTag);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("UnderlyingMaturities", UnderlyingMaturities);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("MarketConvention", MarketConvention);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("InstrumentStrategies", InstrumentStrategies);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("BetaGuesses", BetaGuesses);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("RhoGuesses", RhoGuesses);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("NuGuesses", NuGuesses);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("KeepFixed", KeepFixed);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("Optimizer", Optimizer);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("Constraints", Constraints);
			ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube", ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a calibrated volatility cube that uses the SABR model.
		// </summary>
		// <param name="ModelName">Name to use for new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility cube.</param>
		// <param name="SourceCurveTag">Curve tag of the existing volatility cube to which the new volatility cube will be calibrated.</param>
		// <param name="UnderlyingMaturities">Underlying swap maturities for which calibrations will be done.</param>
		// <param name="MarketConvention">Market conventions used to convert maturities to year fractions.</param>
		// <param name="InstrumentStrategies">An array of instrument strategy collections, one for each underlying maturity.</param>
		// <param name="AlphaFuncs">A single function or an array of functions that determine the values of alpha parameter at each underlying maturity point.</param>
		// <param name="BetaFuncs">A single function or an array of functions that determine the values of beta parameter at each underlying maturity point.</param>
		// <param name="RhoFuncs">A single function or an array of functions that determine the values of rho parameter at each underlying maturity point.</param>
		// <param name="NuFuncs">A single function or an array of functions that determine the values of nu parameter at each underlying maturity point.</param>
		// <param name="ParameterFlags">An array of 4 flags indicating which parameters must be calibrated (1) and which are to be held fixed (0).</param>
		// <param name="Optimizer">Method for calibration. Default value: DefaultLeastSquares.</param>
		// <param name="Constraints">An optional array of calibration constraints, one per each parameter that is to be calibrated. Default value: default-constructed instance of type calibration_bound_constraints.</param>
		// <param name="InterpolationMethod">An interpolation method to be used for the curves created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCalibratedSABRVolatilityCube(object ModelName, object BaseModel, object CurveTag, object SourceCurveTag, object UnderlyingMaturities, object MarketConvention, object InstrumentStrategies, object AlphaFuncs, object BetaFuncs, object RhoFuncs,
		object NuFuncs, object ParameterFlags, object Optimizer, object Constraints, object InterpolationMethod)
		{

			Hashtable ExtendModelWithCalibratedSABRVolatilityCube_args = new Hashtable();
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("SourceCurveTag", SourceCurveTag);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("UnderlyingMaturities", UnderlyingMaturities);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("MarketConvention", MarketConvention);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("InstrumentStrategies", InstrumentStrategies);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("AlphaFuncs", AlphaFuncs);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("BetaFuncs", BetaFuncs);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("RhoFuncs", RhoFuncs);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("NuFuncs", NuFuncs);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("ParameterFlags", ParameterFlags);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("Optimizer", Optimizer);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("Constraints", Constraints);
			ExtendModelWithCalibratedSABRVolatilityCube_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCalibratedSABRVolatilityCube", ExtendModelWithCalibratedSABRVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a LMM covariance curve obtained by the cascade calibration algorithm.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="RateIndex">LIBOR index.</param>
		// <param name="VolatilityCubeCurve">Volatility cube curve tag.</param>
		// <param name="TerminalCorrelationCurve">LMM terminal correlation curve tag.</param>
		// <param name="InstrumentStrategy">Strategy specifying the instruments to use in calibration.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve(object ModelName, object BaseModel, object RateIndex, object VolatilityCubeCurve, object TerminalCorrelationCurve, object InstrumentStrategy)
		{

			Hashtable ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args = new Hashtable();
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("RateIndex", RateIndex);
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("VolatilityCubeCurve", VolatilityCubeCurve);
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("TerminalCorrelationCurve", TerminalCorrelationCurve);
			ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args.Add("InstrumentStrategy", InstrumentStrategy);
			return F3Formatter.f3_style_serialization("ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve", ExtendModelWithCascadeCalibratedLMMTerminalCovarianceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a cheapest-to-deliver rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag with which the resulting curve will be identified. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="CollateralAgreement">Agreement that specifies the rate that collateral earns in each currency.</param>
		// <param name="NumeraireRate">Index encoding the rate at which posted collateral would earn interest in the numeraire currency.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag. Default value: default-constructed instance of type marketdata_tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCheapestToDeliverRateCurve(object ModelName, object BaseModel, object CurveTag, object CollateralAgreement, object NumeraireRate, object SmoothingParameterTag)
		{

			Hashtable ExtendModelWithCheapestToDeliverRateCurve_args = new Hashtable();
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("ModelName", ModelName);
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("CollateralAgreement", CollateralAgreement);
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("NumeraireRate", NumeraireRate);
			ExtendModelWithCheapestToDeliverRateCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithCheapestToDeliverRateCurve", ExtendModelWithCheapestToDeliverRateCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a cloned curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SourceCurveTag">Tag of the underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithClonedCurve(object ModelName, object BaseModel, object CurveTag, object SourceCurveTag)
		{

			Hashtable ExtendModelWithClonedCurve_args = new Hashtable();
			ExtendModelWithClonedCurve_args.Add("ModelName", ModelName);
			ExtendModelWithClonedCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithClonedCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithClonedCurve_args.Add("SourceCurveTag", SourceCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithClonedCurve", ExtendModelWithClonedCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of the curves needed to price a CDS with the ClosedFormIntegral method.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IntegrationMethod">The method used to evaluate integrals.</param>
		// <param name="DifferentiationMethod">The method used to evaluate derivatives.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCompositeIntegralCDSCurves(object ModelName, object BaseModel, object IntegrationMethod, object DifferentiationMethod, object Currency, object CreditContract)
		{

			Hashtable ExtendModelWithCompositeIntegralCDSCurves_args = new Hashtable();
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("IntegrationMethod", IntegrationMethod);
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("DifferentiationMethod", DifferentiationMethod);
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("Currency", Currency);
			ExtendModelWithCompositeIntegralCDSCurves_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("ExtendModelWithCompositeIntegralCDSCurves", ExtendModelWithCompositeIntegralCDSCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a concatenation curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <param name="TransitionPointCurveTag">Point at which the second curve takes over from the first.</param>
		// <param name="SmoothingParameter">Smoothing parameter constraining the transition zone. Default value: default-constructed instance of type marketdata_tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithConcatenationCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag, object TransitionPointCurveTag, object SmoothingParameter)
		{

			Hashtable ExtendModelWithConcatenationCurve_args = new Hashtable();
			ExtendModelWithConcatenationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithConcatenationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithConcatenationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithConcatenationCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWithConcatenationCurve_args.Add("SecondCurveTag", SecondCurveTag);
			ExtendModelWithConcatenationCurve_args.Add("TransitionPointCurveTag", TransitionPointCurveTag);
			ExtendModelWithConcatenationCurve_args.Add("SmoothingParameter", SmoothingParameter);
			return F3Formatter.f3_style_serialization("ExtendModelWithConcatenationCurve", ExtendModelWithConcatenationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a continuously compounded curve based on a rate term structure.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with new curve.</param>
		// <param name="RatesMarketDataTag">Tag identifying market data object providing rate term structure.</param>
		// <param name="TimeCalculator">Time calculator to use.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithContinuousCompoundingCurve(object ModelName, object BaseModel, object CurveTag, object RatesMarketDataTag, object TimeCalculator)
		{

			Hashtable ExtendModelWithContinuousCompoundingCurve_args = new Hashtable();
			ExtendModelWithContinuousCompoundingCurve_args.Add("ModelName", ModelName);
			ExtendModelWithContinuousCompoundingCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithContinuousCompoundingCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithContinuousCompoundingCurve_args.Add("RatesMarketDataTag", RatesMarketDataTag);
			ExtendModelWithContinuousCompoundingCurve_args.Add("TimeCalculator", TimeCalculator);
			return F3Formatter.f3_style_serialization("ExtendModelWithContinuousCompoundingCurve", ExtendModelWithContinuousCompoundingCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of survival curves adjusted for consistency with a credit portfolio index..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IndexContracts">Contracts specifying the rates and maturities of index trades.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for target instruments.</param>
		// <param name="InterpolationMethod">Interpolation method for the basis adjustment curve.</param>
		// <param name="AdjustmentMethod">Methodology for performing the adjustment.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves(object ModelName, object BaseModel, object IndexContracts, object MarketDataTag, object InterpolationMethod, object AdjustmentMethod)
		{

			Hashtable ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args = new Hashtable();
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("IndexContracts", IndexContracts);
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args.Add("AdjustmentMethod", AdjustmentMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves", ExtendModelWithCreditIndexBasisAdjustedSurvivalCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of curves for pricing portfolio index trades.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IndexContracts">Contracts specifying the rates and maturities of index trades.</param>
		// <param name="MarketDataTag">Tag identifying market data object to use for source points.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the composite curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCreditIndexPortfolioSurvivalCurves(object ModelName, object BaseModel, object IndexContracts, object MarketDataTag, object InterpolationMethod)
		{

			Hashtable ExtendModelWithCreditIndexPortfolioSurvivalCurves_args = new Hashtable();
			ExtendModelWithCreditIndexPortfolioSurvivalCurves_args.Add("ModelName", ModelName);
			ExtendModelWithCreditIndexPortfolioSurvivalCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithCreditIndexPortfolioSurvivalCurves_args.Add("IndexContracts", IndexContracts);
			ExtendModelWithCreditIndexPortfolioSurvivalCurves_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithCreditIndexPortfolioSurvivalCurves_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithCreditIndexPortfolioSurvivalCurves", ExtendModelWithCreditIndexPortfolioSurvivalCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve for the cumulative loss distribution.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <param name="BaseCorrelationMarketDataTag">Tag for the base correlation data.</param>
		// <param name="BaseCorrMarketDataIndex">Index for which base correlation to use.</param>
		// <param name="IntegrationMethod">Integration method.</param>
		// <param name="InterpolationMethodForLossDist">Interpolation method for the loss distribution.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithCumulativeLossDistributionCurveUsingRecursion(object ModelName, object BaseModel, object CreditContract, object BaseCorrelationMarketDataTag, object BaseCorrMarketDataIndex, object IntegrationMethod, object InterpolationMethodForLossDist)
		{

			Hashtable ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args = new Hashtable();
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("ModelName", ModelName);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("BaseModel", BaseModel);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("CreditContract", CreditContract);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("BaseCorrelationMarketDataTag", BaseCorrelationMarketDataTag);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("BaseCorrMarketDataIndex", BaseCorrMarketDataIndex);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("IntegrationMethod", IntegrationMethod);
			ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args.Add("InterpolationMethodForLossDist", InterpolationMethodForLossDist);
			return F3Formatter.f3_style_serialization("ExtendModelWithCumulativeLossDistributionCurveUsingRecursion", ExtendModelWithCumulativeLossDistributionCurveUsingRecursion_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a date adjustment curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="TimeCalculator">Date to time, and converse, calculator.</param>
		// <param name="DateModifier">Date modifier to be applied to the date implied from the input time.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDateAdjustmentCurve(object ModelName, object BaseModel, object CurveTag, object TimeCalculator, object DateModifier)
		{

			Hashtable ExtendModelWithDateAdjustmentCurve_args = new Hashtable();
			ExtendModelWithDateAdjustmentCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDateAdjustmentCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDateAdjustmentCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDateAdjustmentCurve_args.Add("TimeCalculator", TimeCalculator);
			ExtendModelWithDateAdjustmentCurve_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("ExtendModelWithDateAdjustmentCurve", ExtendModelWithDateAdjustmentCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a diagonally sliced two-dimensional function curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Tag identifying the two-dimensional function curve to be sliced.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDiagonalSliceOf2dFunctionCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag)
		{

			Hashtable ExtendModelWithDiagonalSliceOf2dFunctionCurve_args = new Hashtable();
			ExtendModelWithDiagonalSliceOf2dFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDiagonalSliceOf2dFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDiagonalSliceOf2dFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDiagonalSliceOf2dFunctionCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithDiagonalSliceOf2dFunctionCurve", ExtendModelWithDiagonalSliceOf2dFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional difference curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDifferenceCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag)
		{

			Hashtable ExtendModelWithDifferenceCurve_args = new Hashtable();
			ExtendModelWithDifferenceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDifferenceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDifferenceCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDifferenceCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWithDifferenceCurve_args.Add("SecondCurveTag", SecondCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithDifferenceCurve", ExtendModelWithDifferenceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a correlation curve for hybrid modeling using user supplied correlation matrices.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketDataTag">Tag identifying correlation market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDirectHybridModelingCorrelationCurve(object ModelName, object BaseModel, object MarketDataTag)
		{

			Hashtable ExtendModelWithDirectHybridModelingCorrelationCurve_args = new Hashtable();
			ExtendModelWithDirectHybridModelingCorrelationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDirectHybridModelingCorrelationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDirectHybridModelingCorrelationCurve_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithDirectHybridModelingCorrelationCurve", ExtendModelWithDirectHybridModelingCorrelationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a Smith-Wilson                                                                       parameterized curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to use for the Smith-Wilson curve.</param>
		// <param name="RateCurveTag">Zero-dimensional curve representing the ultimate forward rate.</param>
		// <param name="WeightCurveTag">Zero-dimensional curve representing the Smith Wilson weights.</param>
		// <param name="MeanReversionCurveTag">Zero-dimensional curve representing the Smith Wilson mean       reversion speed.</param>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag. Default value: default-constructed instance of type marketdata_tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDirectSmithWilsonCurve(object ModelName, object BaseModel, object CurveTag, object RateCurveTag, object WeightCurveTag, object MeanReversionCurveTag, object InstrumentList, object SmoothingParameterTag)
		{

			Hashtable ExtendModelWithDirectSmithWilsonCurve_args = new Hashtable();
			ExtendModelWithDirectSmithWilsonCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("RateCurveTag", RateCurveTag);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("WeightCurveTag", WeightCurveTag);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("MeanReversionCurveTag", MeanReversionCurveTag);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("InstrumentList", InstrumentList);
			ExtendModelWithDirectSmithWilsonCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithDirectSmithWilsonCurve", ExtendModelWithDirectSmithWilsonCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a discontinuous asset price curve involving relative and absolute discrete price jumps.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Identifier to be associated with the new curve.</param>
		// <param name="ForwardCurveTag">Identifier of the continuous asset price curve.</param>
		// <param name="AbsolutePriceJumpMarketDataTag">Identifier of the market data object providing absolute price jumps.</param>
		// <param name="RelativePriceJumpMarketDataTag">Identifier of the market data object providing relative price jumps.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDiscontinuousAssetPriceCurve(object ModelName, object BaseModel, object CurveTag, object ForwardCurveTag, object AbsolutePriceJumpMarketDataTag, object RelativePriceJumpMarketDataTag)
		{

			Hashtable ExtendModelWithDiscontinuousAssetPriceCurve_args = new Hashtable();
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("ForwardCurveTag", ForwardCurveTag);
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("AbsolutePriceJumpMarketDataTag", AbsolutePriceJumpMarketDataTag);
			ExtendModelWithDiscontinuousAssetPriceCurve_args.Add("RelativePriceJumpMarketDataTag", RelativePriceJumpMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithDiscontinuousAssetPriceCurve", ExtendModelWithDiscontinuousAssetPriceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a Dupire local volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the Dupire local volatility curve.</param>
		// <param name="UnderlyingCurveTag">Tag associated with the implied volatility surface.</param>
		// <param name="TimeDifferentiationMethod">Differentiation method specifying how the time derivative is performed. Default value: <s>2.74e-3</s><s>2.74e-3</s><s>FALSE</s>.</param>
		// <param name="PriceDifferentiationMethod">Differentiation method specifying how the price derivative is performed. Default value: <s>1e-4</s><s>1e-4</s><s>TRUE</s>.</param>
		// <param name="SmoothingStrategy">Smoothing strategy specifying the value of local volatility when its square is negative. Default value: <s>-1e+8</s><s>0</s>.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithDupireLocalVolatilityCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object TimeDifferentiationMethod, object PriceDifferentiationMethod, object SmoothingStrategy)
		{

			Hashtable ExtendModelWithDupireLocalVolatilityCurve_args = new Hashtable();
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("TimeDifferentiationMethod", TimeDifferentiationMethod);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("PriceDifferentiationMethod", PriceDifferentiationMethod);
			ExtendModelWithDupireLocalVolatilityCurve_args.Add("SmoothingStrategy", SmoothingStrategy);
			return F3Formatter.f3_style_serialization("ExtendModelWithDupireLocalVolatilityCurve", ExtendModelWithDupireLocalVolatilityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a exponential decay terminal correlation curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="RateIndex">Forward rate index.</param>
		// <param name="UnderlyingZeroDimCurveTag">The zero-dimensional curve containing the terminal correlations.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithExponentialDecayTerminalCorrelationCurve(object ModelName, object BaseModel, object RateIndex, object UnderlyingZeroDimCurveTag)
		{

			Hashtable ExtendModelWithExponentialDecayTerminalCorrelationCurve_args = new Hashtable();
			ExtendModelWithExponentialDecayTerminalCorrelationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithExponentialDecayTerminalCorrelationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithExponentialDecayTerminalCorrelationCurve_args.Add("RateIndex", RateIndex);
			ExtendModelWithExponentialDecayTerminalCorrelationCurve_args.Add("UnderlyingZeroDimCurveTag", UnderlyingZeroDimCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithExponentialDecayTerminalCorrelationCurve", ExtendModelWithExponentialDecayTerminalCorrelationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional exponential implied rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Underlying curve.</param>
		// <param name="RateMarketConventions">Market conventions for rate.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithExponentialImpliedRateCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object RateMarketConventions)
		{

			Hashtable ExtendModelWithExponentialImpliedRateCurve_args = new Hashtable();
			ExtendModelWithExponentialImpliedRateCurve_args.Add("ModelName", ModelName);
			ExtendModelWithExponentialImpliedRateCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithExponentialImpliedRateCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithExponentialImpliedRateCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithExponentialImpliedRateCurve_args.Add("RateMarketConventions", RateMarketConventions);
			return F3Formatter.f3_style_serialization("ExtendModelWithExponentialImpliedRateCurve", ExtendModelWithExponentialImpliedRateCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an FX rates curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve. Default value: <s>UniqueFXRatesCurve</s><s>FXRates</s>.</param>
		// <param name="FXMarketDataTag">Market data tag that identifies the FX rates data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithFXRatesCurve(object ModelName, object BaseModel, object CurveTag, object FXMarketDataTag)
		{

			Hashtable ExtendModelWithFXRatesCurve_args = new Hashtable();
			ExtendModelWithFXRatesCurve_args.Add("ModelName", ModelName);
			ExtendModelWithFXRatesCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithFXRatesCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithFXRatesCurve_args.Add("FXMarketDataTag", FXMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithFXRatesCurve", ExtendModelWithFXRatesCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a fixings curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FixingsMarketDataTag">Market data tag that identifies the fixings data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithFixingsCurve(object ModelName, object BaseModel, object CurveTag, object FixingsMarketDataTag)
		{

			Hashtable ExtendModelWithFixingsCurve_args = new Hashtable();
			ExtendModelWithFixingsCurve_args.Add("ModelName", ModelName);
			ExtendModelWithFixingsCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithFixingsCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithFixingsCurve_args.Add("FixingsMarketDataTag", FixingsMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithFixingsCurve", ExtendModelWithFixingsCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a flat price correlation structure.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="MarketDataTag">Tag identifying correlation market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithFlatPriceCorrelations(object ModelName, object BaseModel, object CurveTag, object MarketDataTag)
		{

			Hashtable ExtendModelWithFlatPriceCorrelations_args = new Hashtable();
			ExtendModelWithFlatPriceCorrelations_args.Add("ModelName", ModelName);
			ExtendModelWithFlatPriceCorrelations_args.Add("BaseModel", BaseModel);
			ExtendModelWithFlatPriceCorrelations_args.Add("CurveTag", CurveTag);
			ExtendModelWithFlatPriceCorrelations_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithFlatPriceCorrelations", ExtendModelWithFlatPriceCorrelations_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an asset price curve involving discrete price jumps.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Identifier to be associated with the new curve.</param>
		// <param name="AssetMarketDataTag">Identifier of the market data object providing asset price quote.</param>
		// <param name="DiscountingCurveTag">Identifier of the asset discounting curve.</param>
		// <param name="RepoSpreadCurveTag">Identifier of the asset repo spread curve.</param>
		// <param name="AbsolutePriceJumpMarketDataTag">Identifier of the market data object providing absolute price jumps.</param>
		// <param name="RelativePriceJumpMarketDataTag">Identifier of the market data object providing relative price jumps.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithGeneralAssetPriceCurve(object ModelName, object BaseModel, object CurveTag, object AssetMarketDataTag, object DiscountingCurveTag, object RepoSpreadCurveTag, object AbsolutePriceJumpMarketDataTag, object RelativePriceJumpMarketDataTag)
		{

			Hashtable ExtendModelWithGeneralAssetPriceCurve_args = new Hashtable();
			ExtendModelWithGeneralAssetPriceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("AssetMarketDataTag", AssetMarketDataTag);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("DiscountingCurveTag", DiscountingCurveTag);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("RepoSpreadCurveTag", RepoSpreadCurveTag);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("AbsolutePriceJumpMarketDataTag", AbsolutePriceJumpMarketDataTag);
			ExtendModelWithGeneralAssetPriceCurve_args.Add("RelativePriceJumpMarketDataTag", RelativePriceJumpMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithGeneralAssetPriceCurve", ExtendModelWithGeneralAssetPriceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of volatility curves for the Heston model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="AssetCurveIdentifier">Means of unique curve identification.</param>
		// <param name="InitialVarianceMarketDataTag">Tag identifying the market data object to use for the initial variance.</param>
		// <param name="LongTermVarianceMarketDataTag">Tag identifying the market data object to use for the long-term variance.</param>
		// <param name="LongTermVarianceInterpolationMethod">Methodology for constructing and interpolating the long-term variance curve.</param>
		// <param name="SpeedOfMeanReversionMarketDataTag">Tag identifying the market data object to use for the speed of mean reversion.</param>
		// <param name="SpeedOfMeanReversionInterpolationMethod">Methodology for constructing and interpolating the speed of mean reversion curve.</param>
		// <param name="VolatilityOfVarianceMarketDataTag">Tag identifying the market data object to use for the volatility of variance.</param>
		// <param name="VolatilityOfVarianceInterpolationMethod">Methodology for constructing and interpolating the volatility of variance curve.</param>
		// <param name="CorrelationMarketDataTag">Tag identifying the market data object to use for the correlation between the two Wiener processes driving the dynamics.</param>
		// <param name="CorrelationInterpolationMethod">Methodology for constructing and interpolating the correlation curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHestonCurves(object ModelName, object BaseModel, object AssetCurveIdentifier, object InitialVarianceMarketDataTag, object LongTermVarianceMarketDataTag, object LongTermVarianceInterpolationMethod, object SpeedOfMeanReversionMarketDataTag, object SpeedOfMeanReversionInterpolationMethod, object VolatilityOfVarianceMarketDataTag, object VolatilityOfVarianceInterpolationMethod,
		object CorrelationMarketDataTag, object CorrelationInterpolationMethod)
		{

			Hashtable ExtendModelWithHestonCurves_args = new Hashtable();
			ExtendModelWithHestonCurves_args.Add("ModelName", ModelName);
			ExtendModelWithHestonCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithHestonCurves_args.Add("AssetCurveIdentifier", AssetCurveIdentifier);
			ExtendModelWithHestonCurves_args.Add("InitialVarianceMarketDataTag", InitialVarianceMarketDataTag);
			ExtendModelWithHestonCurves_args.Add("LongTermVarianceMarketDataTag", LongTermVarianceMarketDataTag);
			ExtendModelWithHestonCurves_args.Add("LongTermVarianceInterpolationMethod", LongTermVarianceInterpolationMethod);
			ExtendModelWithHestonCurves_args.Add("SpeedOfMeanReversionMarketDataTag", SpeedOfMeanReversionMarketDataTag);
			ExtendModelWithHestonCurves_args.Add("SpeedOfMeanReversionInterpolationMethod", SpeedOfMeanReversionInterpolationMethod);
			ExtendModelWithHestonCurves_args.Add("VolatilityOfVarianceMarketDataTag", VolatilityOfVarianceMarketDataTag);
			ExtendModelWithHestonCurves_args.Add("VolatilityOfVarianceInterpolationMethod", VolatilityOfVarianceInterpolationMethod);
			ExtendModelWithHestonCurves_args.Add("CorrelationMarketDataTag", CorrelationMarketDataTag);
			ExtendModelWithHestonCurves_args.Add("CorrelationInterpolationMethod", CorrelationInterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithHestonCurves", ExtendModelWithHestonCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a discretized Heston model volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="InitialVarianceCurveTag">Underlying curve providing the initial variance.</param>
		// <param name="LongTermVarianceCurveTag">Underlying curve providing the long-term variance.</param>
		// <param name="SpeedOfMeanReversionCurveTag">Underlying curve providing the speed of mean reversion.</param>
		// <param name="VolatilityOfVarianceCurveTag">Underlying curve providing the volatility of variance.</param>
		// <param name="CorrelationCurveTag">Underlying curve providing the correlation.</param>
		// <param name="NumberOfSimulationPoints">Number of points to use in the discretization, in addition to the fixing time points. Default value: 0.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHestonDiscreteVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object InitialVarianceCurveTag, object LongTermVarianceCurveTag, object SpeedOfMeanReversionCurveTag, object VolatilityOfVarianceCurveTag, object CorrelationCurveTag, object NumberOfSimulationPoints)
		{

			Hashtable ExtendModelWithHestonDiscreteVolatilitySurface_args = new Hashtable();
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("InitialVarianceCurveTag", InitialVarianceCurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("LongTermVarianceCurveTag", LongTermVarianceCurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("SpeedOfMeanReversionCurveTag", SpeedOfMeanReversionCurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("VolatilityOfVarianceCurveTag", VolatilityOfVarianceCurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("CorrelationCurveTag", CorrelationCurveTag);
			ExtendModelWithHestonDiscreteVolatilitySurface_args.Add("NumberOfSimulationPoints", NumberOfSimulationPoints);
			return F3Formatter.f3_style_serialization("ExtendModelWithHestonDiscreteVolatilitySurface", ExtendModelWithHestonDiscreteVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a local stochastic volatility curve by calibrating the Heston LSV model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="UnderlyingIndex">Underlying index.</param>
		// <param name="TimeDiscretizationMethod">Discretization method for the time direction.</param>
		// <param name="LogForwardDiscretizationMethod">Discretization method for the log-forward direction.</param>
		// <param name="LogVarianceDiscretizationMethod">Discretization method for the log-variance direction.</param>
		// <param name="TwoDimInterpolationMethod">Interpolation method for the local stochastic volatility surface.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHestonLocalStochasticVolatilityCurve(object ModelName, object BaseModel, object UnderlyingIndex, object TimeDiscretizationMethod, object LogForwardDiscretizationMethod, object LogVarianceDiscretizationMethod, object TwoDimInterpolationMethod)
		{

			Hashtable ExtendModelWithHestonLocalStochasticVolatilityCurve_args = new Hashtable();
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("UnderlyingIndex", UnderlyingIndex);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("TimeDiscretizationMethod", TimeDiscretizationMethod);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("LogForwardDiscretizationMethod", LogForwardDiscretizationMethod);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("LogVarianceDiscretizationMethod", LogVarianceDiscretizationMethod);
			ExtendModelWithHestonLocalStochasticVolatilityCurve_args.Add("TwoDimInterpolationMethod", TwoDimInterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithHestonLocalStochasticVolatilityCurve", ExtendModelWithHestonLocalStochasticVolatilityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of volatility parameters for the Heston model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="AssetCurveIdentifier">Means of unique curve identification.</param>
		// <param name="InitialVarianceMarketDataTag">Tag identifying the market data object to use for the initial variance.</param>
		// <param name="LongTermVarianceMarketDataTag">Tag identifying the market data object to use for the long term variance.</param>
		// <param name="SpeedOfMeanReversionMarketDataTag">Tag identifying the market data object to use for the speed of mean reversion.</param>
		// <param name="VolatilityOfVarianceMarketDataTag">Tag identifying the market data object to use for the volatility of variance.</param>
		// <param name="CorrelationMarketDataTag">Tag identifying the market data object to use for the correlation between the two Wiener processes driving the dynamics.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHestonParameters(object ModelName, object BaseModel, object AssetCurveIdentifier, object InitialVarianceMarketDataTag, object LongTermVarianceMarketDataTag, object SpeedOfMeanReversionMarketDataTag, object VolatilityOfVarianceMarketDataTag, object CorrelationMarketDataTag)
		{

			Hashtable ExtendModelWithHestonParameters_args = new Hashtable();
			ExtendModelWithHestonParameters_args.Add("ModelName", ModelName);
			ExtendModelWithHestonParameters_args.Add("BaseModel", BaseModel);
			ExtendModelWithHestonParameters_args.Add("AssetCurveIdentifier", AssetCurveIdentifier);
			ExtendModelWithHestonParameters_args.Add("InitialVarianceMarketDataTag", InitialVarianceMarketDataTag);
			ExtendModelWithHestonParameters_args.Add("LongTermVarianceMarketDataTag", LongTermVarianceMarketDataTag);
			ExtendModelWithHestonParameters_args.Add("SpeedOfMeanReversionMarketDataTag", SpeedOfMeanReversionMarketDataTag);
			ExtendModelWithHestonParameters_args.Add("VolatilityOfVarianceMarketDataTag", VolatilityOfVarianceMarketDataTag);
			ExtendModelWithHestonParameters_args.Add("CorrelationMarketDataTag", CorrelationMarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithHestonParameters", ExtendModelWithHestonParameters_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a Ho-Lee convexity adjustment curve to it.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="TermVarianceCurveTag">Tag identifying the function specifying term variance of the interest rate.</param>
		// <param name="RateTenor">Tenor in years of rate underlying the futures contract to which the adjustment applies.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHoLeeConvexityAdjustmentCurve(object ModelName, object BaseModel, object CurveTag, object TermVarianceCurveTag, object RateTenor)
		{

			Hashtable ExtendModelWithHoLeeConvexityAdjustmentCurve_args = new Hashtable();
			ExtendModelWithHoLeeConvexityAdjustmentCurve_args.Add("ModelName", ModelName);
			ExtendModelWithHoLeeConvexityAdjustmentCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithHoLeeConvexityAdjustmentCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithHoLeeConvexityAdjustmentCurve_args.Add("TermVarianceCurveTag", TermVarianceCurveTag);
			ExtendModelWithHoLeeConvexityAdjustmentCurve_args.Add("RateTenor", RateTenor);
			return F3Formatter.f3_style_serialization("ExtendModelWithHoLeeConvexityAdjustmentCurve", ExtendModelWithHoLeeConvexityAdjustmentCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a terminal correlation curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketDataTag">Tag identifying correlation market data.</param>
		// <param name="InterpolationMethod">Interpolation method for the terminal correlation market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithHybridTerminalCorrelationCurve(object ModelName, object BaseModel, object MarketDataTag, object InterpolationMethod)
		{

			Hashtable ExtendModelWithHybridTerminalCorrelationCurve_args = new Hashtable();
			ExtendModelWithHybridTerminalCorrelationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithHybridTerminalCorrelationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithHybridTerminalCorrelationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithHybridTerminalCorrelationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithHybridTerminalCorrelationCurve", ExtendModelWithHybridTerminalCorrelationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional implied rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with new curve.</param>
		// <param name="UnderlyingCurveTag">Underlying curve.</param>
		// <param name="RateMarketConventions">Market conventions for rate.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithImpliedRateCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object RateMarketConventions)
		{

			Hashtable ExtendModelWithImpliedRateCurve_args = new Hashtable();
			ExtendModelWithImpliedRateCurve_args.Add("ModelName", ModelName);
			ExtendModelWithImpliedRateCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithImpliedRateCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithImpliedRateCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithImpliedRateCurve_args.Add("RateMarketConventions", RateMarketConventions);
			return F3Formatter.f3_style_serialization("ExtendModelWithImpliedRateCurve", ExtendModelWithImpliedRateCurve_args);
		}

		// <summary>
		// Extend a model with one or more curves formed from the initial guesses for a calibration.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTags">Tags identifying the target curves.</param>
		// <param name="InitialValueCurves">Initial values, one per target curve.</param>
		// <param name="EliminateIndices">Indices indicating which curves to add to the model, because they are not being calibrated. Default value: default-constructed instance of type unsigned_small_integers.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInitialGuessCurves(object ModelName, object BaseModel, object CurveTags, object InitialValueCurves, object EliminateIndices)
		{

			Hashtable ExtendModelWithInitialGuessCurves_args = new Hashtable();
			ExtendModelWithInitialGuessCurves_args.Add("ModelName", ModelName);
			ExtendModelWithInitialGuessCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithInitialGuessCurves_args.Add("CurveTags", CurveTags);
			ExtendModelWithInitialGuessCurves_args.Add("InitialValueCurves", InitialValueCurves);
			ExtendModelWithInitialGuessCurves_args.Add("EliminateIndices", EliminateIndices);
			return F3Formatter.f3_style_serialization("ExtendModelWithInitialGuessCurves", ExtendModelWithInitialGuessCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an integral curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="IntegrandCurveTag">Tag to identify the integrand.</param>
		// <param name="Method">The numerical method to evaluate the integral.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithIntegrationCurve(object ModelName, object BaseModel, object CurveTag, object IntegrandCurveTag, object Method)
		{

			Hashtable ExtendModelWithIntegrationCurve_args = new Hashtable();
			ExtendModelWithIntegrationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithIntegrationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithIntegrationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithIntegrationCurve_args.Add("IntegrandCurveTag", IntegrandCurveTag);
			ExtendModelWithIntegrationCurve_args.Add("Method", Method);
			return F3Formatter.f3_style_serialization("ExtendModelWithIntegrationCurve", ExtendModelWithIntegrationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolated Black volatility cube.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTags">Tags identifying the market data objects to be used for the source points.</param>
		// <param name="ThreeDimInterpolationMethod">A three-dimensional interpolation method.</param>
		// <param name="BlackVolatilityConvention">Type of volatility cube to be       constructed. Default value: Raw.</param>
		// <param name="ThreeDimQuoteSpecOrdering">Source for ordering quote specifications in the       market data. Default value: <s>UnderlyingMaturity</s><s>OptionExpiry</s><s>Strike</s>.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedBlackVolatilityCube(object ModelName, object BaseModel, object CurveTag, object MarketDataTags, object ThreeDimInterpolationMethod, object BlackVolatilityConvention, object ThreeDimQuoteSpecOrdering)
		{

			Hashtable ExtendModelWithInterpolatedBlackVolatilityCube_args = new Hashtable();
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("MarketDataTags", MarketDataTags);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("ThreeDimInterpolationMethod", ThreeDimInterpolationMethod);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("BlackVolatilityConvention", BlackVolatilityConvention);
			ExtendModelWithInterpolatedBlackVolatilityCube_args.Add("ThreeDimQuoteSpecOrdering", ThreeDimQuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedBlackVolatilityCube", ExtendModelWithInterpolatedBlackVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model, add an interpolated volatility surface and a Black volatility surface..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="VolatileIndex">The index used to identify the volatility surface.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="TwoDimInterpolationMethod">Methodology for constructing and interpolating the surface. Default value: Linear.</param>
		// <param name="StrikeSpecificationType">The way in which a strike is interpreted. Default value: ABS.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedBlackVolatilitySurface(object ModelName, object BaseModel, object VolatileIndex, object MarketDataTag, object TwoDimInterpolationMethod, object StrikeSpecificationType)
		{

			Hashtable ExtendModelWithInterpolatedBlackVolatilitySurface_args = new Hashtable();
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("VolatileIndex", VolatileIndex);
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("TwoDimInterpolationMethod", TwoDimInterpolationMethod);
			ExtendModelWithInterpolatedBlackVolatilitySurface_args.Add("StrikeSpecificationType", StrikeSpecificationType);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedBlackVolatilitySurface", ExtendModelWithInterpolatedBlackVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional implied rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Underlying curve.</param>
		// <param name="RateMarketConventions">Market conventions for the rate.</param>
		// <param name="InterpolationMethod">Interpolation method. Default value: Linear.</param>
		// <param name="InterpolationSchedule">Schedule of extra dates used to sample the underlying curve. Default value: default-constructed instance of type date_list.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedImpliedRateCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object RateMarketConventions, object InterpolationMethod, object InterpolationSchedule)
		{

			Hashtable ExtendModelWithInterpolatedImpliedRateCurve_args = new Hashtable();
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("RateMarketConventions", RateMarketConventions);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithInterpolatedImpliedRateCurve_args.Add("InterpolationSchedule", InterpolationSchedule);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedImpliedRateCurve", ExtendModelWithInterpolatedImpliedRateCurve_args);
		}

		// <summary>
		// Extend a model with a loss given default curve for a given entity.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CreditEntity">Credit entity.</param>
		// <param name="EntityLossGivenDefaultMarketDataTag">Tag to identify the entity loss given default market data.</param>
		// <param name="InterpolationMethod">Interpolation method.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedLossGivenDefaultCurve(object ModelName, object BaseModel, object CreditEntity, object EntityLossGivenDefaultMarketDataTag, object InterpolationMethod)
		{

			Hashtable ExtendModelWithInterpolatedLossGivenDefaultCurve_args = new Hashtable();
			ExtendModelWithInterpolatedLossGivenDefaultCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedLossGivenDefaultCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedLossGivenDefaultCurve_args.Add("CreditEntity", CreditEntity);
			ExtendModelWithInterpolatedLossGivenDefaultCurve_args.Add("EntityLossGivenDefaultMarketDataTag", EntityLossGivenDefaultMarketDataTag);
			ExtendModelWithInterpolatedLossGivenDefaultCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedLossGivenDefaultCurve", ExtendModelWithInterpolatedLossGivenDefaultCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional interpolation curve formed from parameters.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="XParameters">Tag indentifying the zero-dimensional curve used to form the abscissae.</param>
		// <param name="YParameters">Tag indentifying the zero-dimensional curve used to form the ordinates.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedParametersCurve(object ModelName, object BaseModel, object CurveTag, object XParameters, object YParameters, object InterpolationMethod)
		{

			Hashtable ExtendModelWithInterpolatedParametersCurve_args = new Hashtable();
			ExtendModelWithInterpolatedParametersCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedParametersCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedParametersCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedParametersCurve_args.Add("XParameters", XParameters);
			ExtendModelWithInterpolatedParametersCurve_args.Add("YParameters", YParameters);
			ExtendModelWithInterpolatedParametersCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedParametersCurve", ExtendModelWithInterpolatedParametersCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a discount-like curve implicit in a forward rate curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag that identifies the resulting curve.</param>
		// <param name="RateIndex">Index specifying the discount rate.</param>
		// <param name="Maturity">Maturity used to form the sampling schedule for the rate index.</param>
		// <param name="SamplingMarketConventions">Market conventions used to form the sampling schedule for the rate index. Default value: default-constructed instance of type market_conventions.</param>
		// <param name="InterpolationMethod">Interpolation method for the discount curve. Default value: LogLinear.</param>
		// <param name="ValuationControl">Valuation methodology for the compounded rate calculation. Default value: default-constructed instance of type calculation_strategy.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedSimpleImpliedDiscountCurve(object ModelName, object BaseModel, object CurveTag, object RateIndex, object Maturity, object SamplingMarketConventions, object InterpolationMethod, object ValuationControl)
		{

			Hashtable ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args = new Hashtable();
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("RateIndex", RateIndex);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("Maturity", Maturity);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("SamplingMarketConventions", SamplingMarketConventions);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args.Add("ValuationControl", ValuationControl);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedSimpleImpliedDiscountCurve", ExtendModelWithInterpolatedSimpleImpliedDiscountCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolated volatility cube.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTags">Tags identifying the market data objects to be used for the source points.</param>
		// <param name="ThreeDimInterpolationMethod">A three-dimensional interpolation method.</param>
		// <param name="VolatilityConvention">Type of volatility cube to be       constructed. Default value: Raw.</param>
		// <param name="ThreeDimQuoteSpecOrdering">Source for ordering quote specifications in the       market data. Default value: <s>UnderlyingMaturity</s><s>OptionExpiry</s><s>Strike</s>.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedVolatilityCube(object ModelName, object BaseModel, object CurveTag, object MarketDataTags, object ThreeDimInterpolationMethod, object VolatilityConvention, object ThreeDimQuoteSpecOrdering)
		{

			Hashtable ExtendModelWithInterpolatedVolatilityCube_args = new Hashtable();
			ExtendModelWithInterpolatedVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("MarketDataTags", MarketDataTags);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("ThreeDimInterpolationMethod", ThreeDimInterpolationMethod);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("VolatilityConvention", VolatilityConvention);
			ExtendModelWithInterpolatedVolatilityCube_args.Add("ThreeDimQuoteSpecOrdering", ThreeDimQuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedVolatilityCube", ExtendModelWithInterpolatedVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolated discount curve deducted from zero coupon bond prices.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Zero coupon bond price market data tag.</param>
		// <param name="InterpolationMethod">Interpolation method for the discount curve. Default value: LogLinear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InterpolationMethod)
		{

			Hashtable ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args = new Hashtable();
			ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve", ExtendModelWithInterpolatedZeroCouponBondPriceDiscountCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolation curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="InterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object InterpolationMethod)
		{

			Hashtable ExtendModelWithInterpolationCurve_args = new Hashtable();
			ExtendModelWithInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithInterpolationCurve", ExtendModelWithInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an interpolated Black volatility cube that includes a caplet or floorlet volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="OneDimCurveTag">Underlying one-dimensional transition curve.</param>
		// <param name="TwoDimCurveTag">Underlying two-dimensional curve.</param>
		// <param name="ThreeDimCurveTag">Underlying three-dimensional curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube(object ModelName, object BaseModel, object CurveTag, object OneDimCurveTag, object TwoDimCurveTag, object ThreeDimCurveTag)
		{

			Hashtable ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args = new Hashtable();
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("OneDimCurveTag", OneDimCurveTag);
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("TwoDimCurveTag", TwoDimCurveTag);
			ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args.Add("ThreeDimCurveTag", ThreeDimCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube", ExtendModelWithJoinedCapletSwaptionBlackVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a transition curve for joining an interpolated Black volatility cube to a caplet/floorlet volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SwaptionVolCubeTag">Tag of the interpolated Black swaption volatility cube to be joined.</param>
		// <param name="SmoothingTag">Tag identifying the smoothing parameter market data.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithJoinedVolatilityCubeTransitionCurve(object ModelName, object BaseModel, object CurveTag, object SwaptionVolCubeTag, object SmoothingTag)
		{

			Hashtable ExtendModelWithJoinedVolatilityCubeTransitionCurve_args = new Hashtable();
			ExtendModelWithJoinedVolatilityCubeTransitionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithJoinedVolatilityCubeTransitionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithJoinedVolatilityCubeTransitionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithJoinedVolatilityCubeTransitionCurve_args.Add("SwaptionVolCubeTag", SwaptionVolCubeTag);
			ExtendModelWithJoinedVolatilityCubeTransitionCurve_args.Add("SmoothingTag", SmoothingTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithJoinedVolatilityCubeTransitionCurve", ExtendModelWithJoinedVolatilityCubeTransitionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of the curves that are needed for pricing a loan-only credit default swap.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="IntegrationMethod">The method used to evaluate integrals.</param>
		// <param name="DifferentiationMethod">The method used to evaluate derivatives.</param>
		// <param name="Currency">Currency.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithLCDSCurves(object ModelName, object BaseModel, object IntegrationMethod, object DifferentiationMethod, object Currency, object CreditContract)
		{

			Hashtable ExtendModelWithLCDSCurves_args = new Hashtable();
			ExtendModelWithLCDSCurves_args.Add("ModelName", ModelName);
			ExtendModelWithLCDSCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithLCDSCurves_args.Add("IntegrationMethod", IntegrationMethod);
			ExtendModelWithLCDSCurves_args.Add("DifferentiationMethod", DifferentiationMethod);
			ExtendModelWithLCDSCurves_args.Add("Currency", Currency);
			ExtendModelWithLCDSCurves_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("ExtendModelWithLCDSCurves", ExtendModelWithLCDSCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a covariance curve used by the LMM.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Index">LIBOR index.</param>
		// <param name="LMMTerminalVarianceCurve">LMM terminal variance curve tag.</param>
		// <param name="LMMTerminalCorrelationCurve">LMM terminal correlation curve tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithLMMTerminalCovarianceCurve(object ModelName, object BaseModel, object Index, object LMMTerminalVarianceCurve, object LMMTerminalCorrelationCurve)
		{

			Hashtable ExtendModelWithLMMTerminalCovarianceCurve_args = new Hashtable();
			ExtendModelWithLMMTerminalCovarianceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithLMMTerminalCovarianceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithLMMTerminalCovarianceCurve_args.Add("Index", Index);
			ExtendModelWithLMMTerminalCovarianceCurve_args.Add("LMMTerminalVarianceCurve", LMMTerminalVarianceCurve);
			ExtendModelWithLMMTerminalCovarianceCurve_args.Add("LMMTerminalCorrelationCurve", LMMTerminalCorrelationCurve);
			return F3Formatter.f3_style_serialization("ExtendModelWithLMMTerminalCovarianceCurve", ExtendModelWithLMMTerminalCovarianceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve which identifies the last relevant point in another curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Curve whose last relevant point is to be identified.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithLastRelevantPointCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag)
		{

			Hashtable ExtendModelWithLastRelevantPointCurve_args = new Hashtable();
			ExtendModelWithLastRelevantPointCurve_args.Add("ModelName", ModelName);
			ExtendModelWithLastRelevantPointCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithLastRelevantPointCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithLastRelevantPointCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithLastRelevantPointCurve", ExtendModelWithLastRelevantPointCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a linear interpolation curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithLinearInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag)
		{

			Hashtable ExtendModelWithLinearInterpolationCurve_args = new Hashtable();
			ExtendModelWithLinearInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithLinearInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithLinearInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithLinearInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithLinearInterpolationCurve", ExtendModelWithLinearInterpolationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve for the cumulative loss distribution constructed from survival probabilities.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CreditContract">A credit contract.</param>
		// <param name="IntegrationMethod">Integration method.</param>
		// <param name="InterpolationMethodForLossDist">Interpolation method for the loss distribution.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithLossDistributionCurve(object ModelName, object BaseModel, object CreditContract, object IntegrationMethod, object InterpolationMethodForLossDist)
		{

			Hashtable ExtendModelWithLossDistributionCurve_args = new Hashtable();
			ExtendModelWithLossDistributionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithLossDistributionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithLossDistributionCurve_args.Add("CreditContract", CreditContract);
			ExtendModelWithLossDistributionCurve_args.Add("IntegrationMethod", IntegrationMethod);
			ExtendModelWithLossDistributionCurve_args.Add("InterpolationMethodForLossDist", InterpolationMethodForLossDist);
			return F3Formatter.f3_style_serialization("ExtendModelWithLossDistributionCurve", ExtendModelWithLossDistributionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an m-times-per-year compounded curve based on a rate term structure.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with new curve.</param>
		// <param name="RatesMarketDataTag">Tag identifying market data object providing rate term structure.</param>
		// <param name="TimeCalculator">Time calculator to use.</param>
		// <param name="CompoundingPeriodsPerYear">Numbers of times per year that the rate is compounded.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithMTimesPerYearCompoundingCurve(object ModelName, object BaseModel, object CurveTag, object RatesMarketDataTag, object TimeCalculator, object CompoundingPeriodsPerYear)
		{

			Hashtable ExtendModelWithMTimesPerYearCompoundingCurve_args = new Hashtable();
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("ModelName", ModelName);
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("RatesMarketDataTag", RatesMarketDataTag);
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("TimeCalculator", TimeCalculator);
			ExtendModelWithMTimesPerYearCompoundingCurve_args.Add("CompoundingPeriodsPerYear", CompoundingPeriodsPerYear);
			return F3Formatter.f3_style_serialization("ExtendModelWithMTimesPerYearCompoundingCurve", ExtendModelWithMTimesPerYearCompoundingCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of market data.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketData">Market data to add.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithMarketData(object ModelName, object BaseModel, object MarketData)
		{

			Hashtable ExtendModelWithMarketData_args = new Hashtable();
			ExtendModelWithMarketData_args.Add("ModelName", ModelName);
			ExtendModelWithMarketData_args.Add("BaseModel", BaseModel);
			ExtendModelWithMarketData_args.Add("MarketData", MarketData);
			return F3Formatter.f3_style_serialization("ExtendModelWithMarketData", ExtendModelWithMarketData_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a monthly inflation seasonality curve.
		// </summary>
		// <param name="ModelName">Name of the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the monthly inflation seasonality curve.</param>
		// <param name="AdjustmentsTag">Tag identifying the monthly seasonality adjustment factors.</param>
		// <param name="ConverterFunctionTag">Curve tag identifying the converter function. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="Normalize">Determines whether to normalize the monthly inflation seasonal adjustment factors. Default value: False.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithMonthlyInflationSeasonalityCurve(object ModelName, object BaseModel, object CurveTag, object AdjustmentsTag, object ConverterFunctionTag, object Normalize)
		{

			Hashtable ExtendModelWithMonthlyInflationSeasonalityCurve_args = new Hashtable();
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("AdjustmentsTag", AdjustmentsTag);
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("ConverterFunctionTag", ConverterFunctionTag);
			ExtendModelWithMonthlyInflationSeasonalityCurve_args.Add("Normalize", Normalize);
			return F3Formatter.f3_style_serialization("ExtendModelWithMonthlyInflationSeasonalityCurve", ExtendModelWithMonthlyInflationSeasonalityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an nth-to-default ptobability curve..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="NthToDefaultContract">Nth to default contract.</param>
		// <param name="CorrelationCurveTag">Curvetag specifying the (constant, time-invariant) correlation between the underlying entities.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag.</param>
		// <param name="Maturities">Vector of maturities for the nth-to-default probability distribution.</param>
		// <param name="MarketConvention">Market conventions for the maturities.</param>
		// <param name="InterpolationMethod">Interpolation method.</param>
		// <param name="Generator">Base generator to use in the nth-to-default simulation. Default value: Sobol.</param>
		// <param name="Iterations">Iteration control. Default value: 1023.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy. Default value: SingleThread.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve(object ModelName, object BaseModel, object NthToDefaultContract, object CorrelationCurveTag, object SmoothingParameterTag, object Maturities, object MarketConvention, object InterpolationMethod, object Generator, object Iterations,
		object CalculationMethod)
		{

			Hashtable ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args = new Hashtable();
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("ModelName", ModelName);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("NthToDefaultContract", NthToDefaultContract);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("CorrelationCurveTag", CorrelationCurveTag);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("Maturities", Maturities);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("MarketConvention", MarketConvention);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("InterpolationMethod", InterpolationMethod);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("Generator", Generator);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("Iterations", Iterations);
			ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args.Add("CalculationMethod", CalculationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve", ExtendModelWithNthToDefaultByGaussianCopulaSurvivalCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve that results from    the subtraction of another curve from unity.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTagToSubtract">Tag associated with the curve to be subtracted from unity.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithOneMinusCurve(object ModelName, object BaseModel, object CurveTagToSubtract, object CurveTag)
		{

			Hashtable ExtendModelWithOneMinusCurve_args = new Hashtable();
			ExtendModelWithOneMinusCurve_args.Add("ModelName", ModelName);
			ExtendModelWithOneMinusCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithOneMinusCurve_args.Add("CurveTagToSubtract", CurveTagToSubtract);
			ExtendModelWithOneMinusCurve_args.Add("CurveTag", CurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithOneMinusCurve", ExtendModelWithOneMinusCurve_args);
		}

		// <summary>
		// Form curves by specifying a parameterization in an apposite language.
		// </summary>
		// <param name="ModelName">Name to use for the updated model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Expressions">A collection of expressions encoding the parameterization of the curves.</param>
		// <param name="TargetCurves">Tags and expressions identifying the parameterized curves.</param>
		// <param name="Parameters">Mapping between parameter names and their location in the model. Default value: default-constructed instance of type model_parameter_identifiers.</param>
		// <param name="Functions">Mapping between function names and their location in the Model. Default value: default-constructed instance of type function_identifiers.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithParameterizedCurves(object ModelName, object BaseModel, object Expressions, object TargetCurves, object Parameters, object Functions)
		{

			Hashtable ExtendModelWithParameterizedCurves_args = new Hashtable();
			ExtendModelWithParameterizedCurves_args.Add("ModelName", ModelName);
			ExtendModelWithParameterizedCurves_args.Add("BaseModel", BaseModel);
			ExtendModelWithParameterizedCurves_args.Add("Expressions", Expressions);
			ExtendModelWithParameterizedCurves_args.Add("TargetCurves", TargetCurves);
			ExtendModelWithParameterizedCurves_args.Add("Parameters", Parameters);
			ExtendModelWithParameterizedCurves_args.Add("Functions", Functions);
			return F3Formatter.f3_style_serialization("ExtendModelWithParameterizedCurves", ExtendModelWithParameterizedCurves_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a periodic fixings curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FixingsMarketDataTag">Market data tag that identifies the fixings data.</param>
		// <param name="DateModifier">Date modifier for defining the reference day of the period. Default value: MonthEnd.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithPeriodicFixingsCurve(object ModelName, object BaseModel, object CurveTag, object FixingsMarketDataTag, object DateModifier)
		{

			Hashtable ExtendModelWithPeriodicFixingsCurve_args = new Hashtable();
			ExtendModelWithPeriodicFixingsCurve_args.Add("ModelName", ModelName);
			ExtendModelWithPeriodicFixingsCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithPeriodicFixingsCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithPeriodicFixingsCurve_args.Add("FixingsMarketDataTag", FixingsMarketDataTag);
			ExtendModelWithPeriodicFixingsCurve_args.Add("DateModifier", DateModifier);
			return F3Formatter.f3_style_serialization("ExtendModelWithPeriodicFixingsCurve", ExtendModelWithPeriodicFixingsCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a product curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithProductCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag)
		{

			Hashtable ExtendModelWithProductCurve_args = new Hashtable();
			ExtendModelWithProductCurve_args.Add("ModelName", ModelName);
			ExtendModelWithProductCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithProductCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithProductCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWithProductCurve_args.Add("SecondCurveTag", SecondCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithProductCurve", ExtendModelWithProductCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a quadratic volatility curve built from three option strategies such as straddle, risk reversal and butterfly.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="UnderlyingIndex">Index to identify the underlying asset of option market data sets.</param>
		// <param name="MarketDataTags">Tags identifying the three market data sets of straddle, risk reversal and butterfly.</param>
		// <param name="InterpolationMethod">An interpolation method for the temporal coordinate.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithQuadraticVolatilityCurve(object ModelName, object BaseModel, object UnderlyingIndex, object MarketDataTags, object InterpolationMethod)
		{

			Hashtable ExtendModelWithQuadraticVolatilityCurve_args = new Hashtable();
			ExtendModelWithQuadraticVolatilityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithQuadraticVolatilityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithQuadraticVolatilityCurve_args.Add("UnderlyingIndex", UnderlyingIndex);
			ExtendModelWithQuadraticVolatilityCurve_args.Add("MarketDataTags", MarketDataTags);
			ExtendModelWithQuadraticVolatilityCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithQuadraticVolatilityCurve", ExtendModelWithQuadraticVolatilityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a quarterly inflation seasonality curve.
		// </summary>
		// <param name="ModelName">Name of the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the quarterly inflation seasonality curve.</param>
		// <param name="AdjustmentsTag">Tag identifying the quarterly seasonality adjustment factors.</param>
		// <param name="ConverterFunctionTag">Curve tag identifying the converter function. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="Normalize">Determines whether to normalize the quarterly inflation seasonal adjustment factors. Default value: False.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithQuarterlyInflationSeasonalityCurve(object ModelName, object BaseModel, object CurveTag, object AdjustmentsTag, object ConverterFunctionTag, object Normalize)
		{

			Hashtable ExtendModelWithQuarterlyInflationSeasonalityCurve_args = new Hashtable();
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("ModelName", ModelName);
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("AdjustmentsTag", AdjustmentsTag);
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("ConverterFunctionTag", ConverterFunctionTag);
			ExtendModelWithQuarterlyInflationSeasonalityCurve_args.Add("Normalize", Normalize);
			return F3Formatter.f3_style_serialization("ExtendModelWithQuarterlyInflationSeasonalityCurve", ExtendModelWithQuarterlyInflationSeasonalityCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a mean reversion curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Currency">Currency of process with mean reversion.</param>
		// <param name="MarketDataTag">Tag identifying mean reversion parameters.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithRatesMeanReversionCurve(object ModelName, object BaseModel, object Currency, object MarketDataTag)
		{

			Hashtable ExtendModelWithRatesMeanReversionCurve_args = new Hashtable();
			ExtendModelWithRatesMeanReversionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithRatesMeanReversionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithRatesMeanReversionCurve_args.Add("Currency", Currency);
			ExtendModelWithRatesMeanReversionCurve_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithRatesMeanReversionCurve", ExtendModelWithRatesMeanReversionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a covariance curve used by the LIBOR Market Model in the Rebonato parameterization.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Index">LIBOR index.</param>
		// <param name="LMMParametersAsZeroDimCurve">The zero dimensional curve containing the vector of parameters..</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithRebonatoLMMCovarianceCurve(object ModelName, object BaseModel, object Index, object LMMParametersAsZeroDimCurve)
		{

			Hashtable ExtendModelWithRebonatoLMMCovarianceCurve_args = new Hashtable();
			ExtendModelWithRebonatoLMMCovarianceCurve_args.Add("ModelName", ModelName);
			ExtendModelWithRebonatoLMMCovarianceCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithRebonatoLMMCovarianceCurve_args.Add("Index", Index);
			ExtendModelWithRebonatoLMMCovarianceCurve_args.Add("LMMParametersAsZeroDimCurve", LMMParametersAsZeroDimCurve);
			return F3Formatter.f3_style_serialization("ExtendModelWithRebonatoLMMCovarianceCurve", ExtendModelWithRebonatoLMMCovarianceCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of the reciprocal of a curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="BaseCurveTag">Underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithReciprocalCurve(object ModelName, object BaseModel, object CurveTag, object BaseCurveTag)
		{

			Hashtable ExtendModelWithReciprocalCurve_args = new Hashtable();
			ExtendModelWithReciprocalCurve_args.Add("ModelName", ModelName);
			ExtendModelWithReciprocalCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithReciprocalCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithReciprocalCurve_args.Add("BaseCurveTag", BaseCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithReciprocalCurve", ExtendModelWithReciprocalCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a shifted exponent curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingMainCurveTag">Tag identifying the main curve.</param>
		// <param name="UnderlyingRateCurveTag">Tag identifying the rate, or exponent, curve.</param>
		// <param name="MainFunction">Function for composition with the main curve. Default value: Identity.</param>
		// <param name="RateFunction">Function for composition with the rate curve. Default value: Identity.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithShiftedExponentSimpleFunctionCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingMainCurveTag, object UnderlyingRateCurveTag, object MainFunction, object RateFunction)
		{

			Hashtable ExtendModelWithShiftedExponentSimpleFunctionCurve_args = new Hashtable();
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("UnderlyingMainCurveTag", UnderlyingMainCurveTag);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("UnderlyingRateCurveTag", UnderlyingRateCurveTag);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("MainFunction", MainFunction);
			ExtendModelWithShiftedExponentSimpleFunctionCurve_args.Add("RateFunction", RateFunction);
			return F3Formatter.f3_style_serialization("ExtendModelWithShiftedExponentSimpleFunctionCurve", ExtendModelWithShiftedExponentSimpleFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of an implied shifted lognormal volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingVolatilityCurveTag">Underlying curve providing implied Black volatility.</param>
		// <param name="UnderlyingOffsetCurveTag">Underlying curve providing strike offsets.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithShiftedLognormalVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object UnderlyingVolatilityCurveTag, object UnderlyingOffsetCurveTag)
		{

			Hashtable ExtendModelWithShiftedLognormalVolatilitySurface_args = new Hashtable();
			ExtendModelWithShiftedLognormalVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithShiftedLognormalVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithShiftedLognormalVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithShiftedLognormalVolatilitySurface_args.Add("UnderlyingVolatilityCurveTag", UnderlyingVolatilityCurveTag);
			ExtendModelWithShiftedLognormalVolatilitySurface_args.Add("UnderlyingOffsetCurveTag", UnderlyingOffsetCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithShiftedLognormalVolatilitySurface", ExtendModelWithShiftedLognormalVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a two-dimensional composition function curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="Simple2dFunction">Simple (parameterless) function on which to base the new curve.</param>
		// <param name="FirstUnderlyingCurveTag">Tag identifying the first one-dimensional curve.</param>
		// <param name="SecondUnderlyingCurveTag">Tag identifying the second one-dimensional curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimple1d2dFunctionCompositionCurve(object ModelName, object BaseModel, object CurveTag, object Simple2dFunction, object FirstUnderlyingCurveTag, object SecondUnderlyingCurveTag)
		{

			Hashtable ExtendModelWithSimple1d2dFunctionCompositionCurve_args = new Hashtable();
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("Simple2dFunction", Simple2dFunction);
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("FirstUnderlyingCurveTag", FirstUnderlyingCurveTag);
			ExtendModelWithSimple1d2dFunctionCompositionCurve_args.Add("SecondUnderlyingCurveTag", SecondUnderlyingCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimple1d2dFunctionCompositionCurve", ExtendModelWithSimple1d2dFunctionCompositionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve based on a simple (parameterless) two-dimensional function.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="Simple2dFunction">Simple (parameterless) function on which to base the new curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimple2dFunctionCurve(object ModelName, object BaseModel, object CurveTag, object Simple2dFunction)
		{

			Hashtable ExtendModelWithSimple2dFunctionCurve_args = new Hashtable();
			ExtendModelWithSimple2dFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimple2dFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimple2dFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimple2dFunctionCurve_args.Add("Simple2dFunction", Simple2dFunction);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimple2dFunctionCurve", ExtendModelWithSimple2dFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve based on a simple (parameterless) three-dimensional function.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="Simple3dFunction">Simple (parameterless) function on which to the base new curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimple3dFunctionCurve(object ModelName, object BaseModel, object CurveTag, object Simple3dFunction)
		{

			Hashtable ExtendModelWithSimple3dFunctionCurve_args = new Hashtable();
			ExtendModelWithSimple3dFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimple3dFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimple3dFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimple3dFunctionCurve_args.Add("Simple3dFunction", Simple3dFunction);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimple3dFunctionCurve", ExtendModelWithSimple3dFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve concatenated from a pair of input curves..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <param name="TransitionPointCurveTag">Point at which the second curve takes over from the first. Default value: default-constructed instance of type curve_tag.</param>
		// <param name="SmoothingParameter">Smoothing parameter constraining the transition zone. Default value: default-constructed instance of type marketdata_tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimpleConcatenationCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag, object TransitionPointCurveTag, object SmoothingParameter)
		{

			Hashtable ExtendModelWithSimpleConcatenationCurve_args = new Hashtable();
			ExtendModelWithSimpleConcatenationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimpleConcatenationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimpleConcatenationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimpleConcatenationCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWithSimpleConcatenationCurve_args.Add("SecondCurveTag", SecondCurveTag);
			ExtendModelWithSimpleConcatenationCurve_args.Add("TransitionPointCurveTag", TransitionPointCurveTag);
			ExtendModelWithSimpleConcatenationCurve_args.Add("SmoothingParameter", SmoothingParameter);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimpleConcatenationCurve", ExtendModelWithSimpleConcatenationCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a convexity adjustment curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="ConvexityFunction">The convexity adjustment function.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimpleConvexityAdjustmentCurve(object ModelName, object BaseModel, object CurveTag, object ConvexityFunction)
		{

			Hashtable ExtendModelWithSimpleConvexityAdjustmentCurve_args = new Hashtable();
			ExtendModelWithSimpleConvexityAdjustmentCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimpleConvexityAdjustmentCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimpleConvexityAdjustmentCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimpleConvexityAdjustmentCurve_args.Add("ConvexityFunction", ConvexityFunction);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimpleConvexityAdjustmentCurve", ExtendModelWithSimpleConvexityAdjustmentCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve based on a simple (parameterless) function.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SimpleFunction">Simple (parameterless) function on which to base the new curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimpleFunctionCurve(object ModelName, object BaseModel, object CurveTag, object SimpleFunction)
		{

			Hashtable ExtendModelWithSimpleFunctionCurve_args = new Hashtable();
			ExtendModelWithSimpleFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimpleFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimpleFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimpleFunctionCurve_args.Add("SimpleFunction", SimpleFunction);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimpleFunctionCurve", ExtendModelWithSimpleFunctionCurve_args);
		}

		// <summary>
		// Add a curve to the model that is constructed by interpolating the provided data.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">UnderlyingModel.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="InterpolationData">A two-column table of maturities and the associated curve values.</param>
		// <param name="InterpolationMethod">Interpolation method to use. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimpleInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object InterpolationData, object InterpolationMethod)
		{

			Hashtable ExtendModelWithSimpleInterpolationCurve_args = new Hashtable();
			ExtendModelWithSimpleInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimpleInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimpleInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSimpleInterpolationCurve_args.Add("InterpolationData", InterpolationData);
			ExtendModelWithSimpleInterpolationCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimpleInterpolationCurve", ExtendModelWithSimpleInterpolationCurve_args);
		}

		// <summary>
		// Add a zero-dimensional curve to the model that contains the provided parameters..
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="ParametersCurveTag">Tag to be associated with the new curve.</param>
		// <param name="Parameters">Parameters that are placed into the zero-dimensional curve.</param>
		// <param name="ParametersLabels">Labels to use as the quote specifications in the risk report. Default value: default-constructed instance of type strings.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSimpleZeroDimensionalCurve(object ModelName, object BaseModel, object ParametersCurveTag, object Parameters, object ParametersLabels)
		{

			Hashtable ExtendModelWithSimpleZeroDimensionalCurve_args = new Hashtable();
			ExtendModelWithSimpleZeroDimensionalCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSimpleZeroDimensionalCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSimpleZeroDimensionalCurve_args.Add("ParametersCurveTag", ParametersCurveTag);
			ExtendModelWithSimpleZeroDimensionalCurve_args.Add("Parameters", Parameters);
			ExtendModelWithSimpleZeroDimensionalCurve_args.Add("ParametersLabels", ParametersLabels);
			return F3Formatter.f3_style_serialization("ExtendModelWithSimpleZeroDimensionalCurve", ExtendModelWithSimpleZeroDimensionalCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a mean reversion curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="Currency">Currency of process with mean reversion.</param>
		// <param name="MarketDataTag">Tag identifying mean reversion parameters.</param>
		// <param name="ShortRatefactorNumber">The number that specifies which factor the mean reversion parameter is associated with.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSingleMeanReversionCurve(object ModelName, object BaseModel, object Currency, object MarketDataTag, object ShortRatefactorNumber)
		{

			Hashtable ExtendModelWithSingleMeanReversionCurve_args = new Hashtable();
			ExtendModelWithSingleMeanReversionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSingleMeanReversionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSingleMeanReversionCurve_args.Add("Currency", Currency);
			ExtendModelWithSingleMeanReversionCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithSingleMeanReversionCurve_args.Add("ShortRatefactorNumber", ShortRatefactorNumber);
			return F3Formatter.f3_style_serialization("ExtendModelWithSingleMeanReversionCurve", ExtendModelWithSingleMeanReversionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a single parameter curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Market data containing the source value.</param>
		// <param name="ValueIndex">Index of value in the market data. Default value: 0.</param>
		// <param name="FunctionBuilder">One-dimensional function builder.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSingleParameterFunctionCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object ValueIndex, object FunctionBuilder)
		{

			Hashtable ExtendModelWithSingleParameterFunctionCurve_args = new Hashtable();
			ExtendModelWithSingleParameterFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSingleParameterFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSingleParameterFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSingleParameterFunctionCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithSingleParameterFunctionCurve_args.Add("ValueIndex", ValueIndex);
			ExtendModelWithSingleParameterFunctionCurve_args.Add("FunctionBuilder", FunctionBuilder);
			return F3Formatter.f3_style_serialization("ExtendModelWithSingleParameterFunctionCurve", ExtendModelWithSingleParameterFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a single parameter curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SourceCurveTag">Curve containing the source value.</param>
		// <param name="ValueIndex">Index of value in the source curve. Default value: 0.</param>
		// <param name="FunctionBuilder">One-dimensional function builder.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSingleValueFunctionCurve(object ModelName, object BaseModel, object CurveTag, object SourceCurveTag, object ValueIndex, object FunctionBuilder)
		{

			Hashtable ExtendModelWithSingleValueFunctionCurve_args = new Hashtable();
			ExtendModelWithSingleValueFunctionCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSingleValueFunctionCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSingleValueFunctionCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSingleValueFunctionCurve_args.Add("SourceCurveTag", SourceCurveTag);
			ExtendModelWithSingleValueFunctionCurve_args.Add("ValueIndex", ValueIndex);
			ExtendModelWithSingleValueFunctionCurve_args.Add("FunctionBuilder", FunctionBuilder);
			return F3Formatter.f3_style_serialization("ExtendModelWithSingleValueFunctionCurve", ExtendModelWithSingleValueFunctionCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a Black caplet surface stripped from flat cap volatilities.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility surface.</param>
		// <param name="InitialValueCurves">Initial value functions for the stripped caplet volatility surfaces.</param>
		// <param name="Strikes">An array of strikes, one for each calibration.</param>
		// <param name="StrikeType">Specification of the type (relative or absolute) of the strike values.</param>
		// <param name="InstrumentStrategies">An array of instrument strategy collections, one for each strike specification.</param>
		// <param name="VolatilityConvention">Convention of Black volatility quotes. Default value: Raw.</param>
		// <param name="CalibrationInterpolationMethod">An interpolation method to be used for each calibration. Default value: Linear.</param>
		// <param name="Optimizer">Method for calibration. Default value: RootSearch.</param>
		// <param name="SurfaceInterpolationMethod">An interpolation method to be used for the surface created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithStrippedCapBlackVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object InitialValueCurves, object Strikes, object StrikeType, object InstrumentStrategies, object VolatilityConvention, object CalibrationInterpolationMethod, object Optimizer,
		object SurfaceInterpolationMethod)
		{

			Hashtable ExtendModelWithStrippedCapBlackVolatilitySurface_args = new Hashtable();
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("InitialValueCurves", InitialValueCurves);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("Strikes", Strikes);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("StrikeType", StrikeType);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("InstrumentStrategies", InstrumentStrategies);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("VolatilityConvention", VolatilityConvention);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("CalibrationInterpolationMethod", CalibrationInterpolationMethod);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("Optimizer", Optimizer);
			ExtendModelWithStrippedCapBlackVolatilitySurface_args.Add("SurfaceInterpolationMethod", SurfaceInterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithStrippedCapBlackVolatilitySurface", ExtendModelWithStrippedCapBlackVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a caplet surface stripped from flat cap volatilities.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Curve tag to use for the new volatility surface.</param>
		// <param name="InitialValueCurves">Initial value functions for the stripped caplet volatility surfaces.</param>
		// <param name="Strikes">An array of strikes, one for each calibration.</param>
		// <param name="StrikeType">Specification of the type (relative or absolute) of the strike values.</param>
		// <param name="InstrumentStrategies">An array of instrument strategy collections, one for each strike specification.</param>
		// <param name="VolatilityConvention">Convention of volatility quotes. Default value: Raw.</param>
		// <param name="CalibrationInterpolationMethod">An interpolation method to be used for each calibration. Default value: Linear.</param>
		// <param name="Optimizer">Method for calibration. Default value: RootSearch.</param>
		// <param name="SurfaceInterpolationMethod">An interpolation method to be used for the surface created in the model. Default value: Linear.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithStrippedCapVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object InitialValueCurves, object Strikes, object StrikeType, object InstrumentStrategies, object VolatilityConvention, object CalibrationInterpolationMethod, object Optimizer,
		object SurfaceInterpolationMethod)
		{

			Hashtable ExtendModelWithStrippedCapVolatilitySurface_args = new Hashtable();
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("InitialValueCurves", InitialValueCurves);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("Strikes", Strikes);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("StrikeType", StrikeType);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("InstrumentStrategies", InstrumentStrategies);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("VolatilityConvention", VolatilityConvention);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("CalibrationInterpolationMethod", CalibrationInterpolationMethod);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("Optimizer", Optimizer);
			ExtendModelWithStrippedCapVolatilitySurface_args.Add("SurfaceInterpolationMethod", SurfaceInterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithStrippedCapVolatilitySurface", ExtendModelWithStrippedCapVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a one-dimensional summed curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="FirstCurveTag">First underlying curve.</param>
		// <param name="SecondCurveTag">Second underlying curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSumCurve(object ModelName, object BaseModel, object CurveTag, object FirstCurveTag, object SecondCurveTag)
		{

			Hashtable ExtendModelWithSumCurve_args = new Hashtable();
			ExtendModelWithSumCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSumCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSumCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSumCurve_args.Add("FirstCurveTag", FirstCurveTag);
			ExtendModelWithSumCurve_args.Add("SecondCurveTag", SecondCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithSumCurve", ExtendModelWithSumCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a Ho-Lee-based swap futures convexity adjustment curve to it.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MeanReversionCurveTag">Tag identifying the zero-dimensional function that specifies the mean reversion parameter.</param>
		// <param name="HWVolatilityCurveTag">Tag identifying the function specifying Hull-White volatility of the the short-rate.</param>
		// <param name="DiscountCurveTag">Tag identifying the discount curve.</param>
		// <param name="SwapLength">Length of the swap underlying the futures contract given as fraction of a year.</param>
		// <param name="FloatingCouponLength">Coupon length of the floating payments.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve(object ModelName, object BaseModel, object CurveTag, object MeanReversionCurveTag, object HWVolatilityCurveTag, object DiscountCurveTag, object SwapLength, object FloatingCouponLength)
		{

			Hashtable ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args = new Hashtable();
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("ModelName", ModelName);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("MeanReversionCurveTag", MeanReversionCurveTag);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("HWVolatilityCurveTag", HWVolatilityCurveTag);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("DiscountCurveTag", DiscountCurveTag);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("SwapLength", SwapLength);
			ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args.Add("FloatingCouponLength", FloatingCouponLength);
			return F3Formatter.f3_style_serialization("ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve", ExtendModelWithSwapFuturesHullWhiteConvexityAdjustmentCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a swaption volatility cube that is derived from another.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="RollTenor">Coupon period length of the fixed leg of the underlying swaps in the new volatility cube.</param>
		// <param name="UnderlyingCurveTag">Tag identifying the underlying curve that describes the base volatility cube.</param>
		// <param name="UnderlyingRollTenor">Coupon period length of the fixed leg of the underlying swaps in the base volatility cube.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTenorAdjustedVolatilityCube(object ModelName, object BaseModel, object CurveTag, object RollTenor, object UnderlyingCurveTag, object UnderlyingRollTenor)
		{

			Hashtable ExtendModelWithTenorAdjustedVolatilityCube_args = new Hashtable();
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("RollTenor", RollTenor);
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithTenorAdjustedVolatilityCube_args.Add("UnderlyingRollTenor", UnderlyingRollTenor);
			return F3Formatter.f3_style_serialization("ExtendModelWithTenorAdjustedVolatilityCube", ExtendModelWithTenorAdjustedVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a testing volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingVolatilityCurveTag">Underlying volatility curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTestingSwaptionVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object UnderlyingVolatilityCurveTag)
		{

			Hashtable ExtendModelWithTestingSwaptionVolatilitySurface_args = new Hashtable();
			ExtendModelWithTestingSwaptionVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithTestingSwaptionVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithTestingSwaptionVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithTestingSwaptionVolatilitySurface_args.Add("UnderlyingVolatilityCurveTag", UnderlyingVolatilityCurveTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithTestingSwaptionVolatilitySurface", ExtendModelWithTestingSwaptionVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve for the value of the tranche pool.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="DiscountCurveTag">Tag to identify the discount factor curve.</param>
		// <param name="LossDistributionCurveTag">Tag to identify the loss distribution curve L(x,t).</param>
		// <param name="TargetCurveTag">Tag to be associated with the tranche accrual curve.</param>
		// <param name="DifferentiationMethodForTime">Differentiation method for time.</param>
		// <param name="IntegrationMethodForLoss">Integration method for loss.</param>
		// <param name="IntegrationMethodForTime">Integration method for time.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTrancheAccrualCurve(object ModelName, object BaseModel, object DiscountCurveTag, object LossDistributionCurveTag, object TargetCurveTag, object DifferentiationMethodForTime, object IntegrationMethodForLoss, object IntegrationMethodForTime)
		{

			Hashtable ExtendModelWithTrancheAccrualCurve_args = new Hashtable();
			ExtendModelWithTrancheAccrualCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTrancheAccrualCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTrancheAccrualCurve_args.Add("DiscountCurveTag", DiscountCurveTag);
			ExtendModelWithTrancheAccrualCurve_args.Add("LossDistributionCurveTag", LossDistributionCurveTag);
			ExtendModelWithTrancheAccrualCurve_args.Add("TargetCurveTag", TargetCurveTag);
			ExtendModelWithTrancheAccrualCurve_args.Add("DifferentiationMethodForTime", DifferentiationMethodForTime);
			ExtendModelWithTrancheAccrualCurve_args.Add("IntegrationMethodForLoss", IntegrationMethodForLoss);
			ExtendModelWithTrancheAccrualCurve_args.Add("IntegrationMethodForTime", IntegrationMethodForTime);
			return F3Formatter.f3_style_serialization("ExtendModelWithTrancheAccrualCurve", ExtendModelWithTrancheAccrualCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve for the value of the tranche pool.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="DiscountCurveTag">Tag to identify the discount factor curve.</param>
		// <param name="LossDistributionCurveTag">Tag to identify the loss distribution curve L(x,t).</param>
		// <param name="TargetCurveTag">Tag to be associated with the tranche default curve.</param>
		// <param name="DifferentiationMethodForTime">Differentiation method for time.</param>
		// <param name="IntegrationMethodForLoss">Integration method for loss.</param>
		// <param name="IntegrationMethodForTime">Integration method for time.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTrancheDefaultCurve(object ModelName, object BaseModel, object DiscountCurveTag, object LossDistributionCurveTag, object TargetCurveTag, object DifferentiationMethodForTime, object IntegrationMethodForLoss, object IntegrationMethodForTime)
		{

			Hashtable ExtendModelWithTrancheDefaultCurve_args = new Hashtable();
			ExtendModelWithTrancheDefaultCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTrancheDefaultCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTrancheDefaultCurve_args.Add("DiscountCurveTag", DiscountCurveTag);
			ExtendModelWithTrancheDefaultCurve_args.Add("LossDistributionCurveTag", LossDistributionCurveTag);
			ExtendModelWithTrancheDefaultCurve_args.Add("TargetCurveTag", TargetCurveTag);
			ExtendModelWithTrancheDefaultCurve_args.Add("DifferentiationMethodForTime", DifferentiationMethodForTime);
			ExtendModelWithTrancheDefaultCurve_args.Add("IntegrationMethodForLoss", IntegrationMethodForLoss);
			ExtendModelWithTrancheDefaultCurve_args.Add("IntegrationMethodForTime", IntegrationMethodForTime);
			return F3Formatter.f3_style_serialization("ExtendModelWithTrancheDefaultCurve", ExtendModelWithTrancheDefaultCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a curve for the value of the tranche pool.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="LossDistributionCurveTag">Tag to identify the loss distribution curve L(x,t).</param>
		// <param name="TargetCurveTag">Tag to be associated with the tranche pool curve.</param>
		// <param name="IntegrationMethod">Integration method for loss.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTranchePoolCurve(object ModelName, object BaseModel, object LossDistributionCurveTag, object TargetCurveTag, object IntegrationMethod)
		{

			Hashtable ExtendModelWithTranchePoolCurve_args = new Hashtable();
			ExtendModelWithTranchePoolCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTranchePoolCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTranchePoolCurve_args.Add("LossDistributionCurveTag", LossDistributionCurveTag);
			ExtendModelWithTranchePoolCurve_args.Add("TargetCurveTag", TargetCurveTag);
			ExtendModelWithTranchePoolCurve_args.Add("IntegrationMethod", IntegrationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithTranchePoolCurve", ExtendModelWithTranchePoolCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a turn pressure curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="TurnPressureMarketDataTag">Turn pressure market data tag.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTurnPressureCurve(object ModelName, object BaseModel, object CurveTag, object TurnPressureMarketDataTag, object SmoothingParameterTag)
		{

			Hashtable ExtendModelWithTurnPressureCurve_args = new Hashtable();
			ExtendModelWithTurnPressureCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTurnPressureCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTurnPressureCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithTurnPressureCurve_args.Add("TurnPressureMarketDataTag", TurnPressureMarketDataTag);
			ExtendModelWithTurnPressureCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithTurnPressureCurve", ExtendModelWithTurnPressureCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a discount factor curve incorporating turn pressure.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTag">Discount factor curve ignoring turn pressure.</param>
		// <param name="TurnPressureMarketDataTag">Turn pressure market data tag.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTurnPressureDiscountCurve(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTag, object TurnPressureMarketDataTag, object SmoothingParameterTag)
		{

			Hashtable ExtendModelWithTurnPressureDiscountCurve_args = new Hashtable();
			ExtendModelWithTurnPressureDiscountCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTurnPressureDiscountCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTurnPressureDiscountCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithTurnPressureDiscountCurve_args.Add("UnderlyingCurveTag", UnderlyingCurveTag);
			ExtendModelWithTurnPressureDiscountCurve_args.Add("TurnPressureMarketDataTag", TurnPressureMarketDataTag);
			ExtendModelWithTurnPressureDiscountCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithTurnPressureDiscountCurve", ExtendModelWithTurnPressureDiscountCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a two-dimensional surface formed from a family of one-dimensional curves.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SourceCurveTags">Curve tags for the family of underlying curves.</param>
		// <param name="SourceCurvePoints">Ordered vector of values, one per underlying curve.</param>
		// <param name="InterpolationMethod">Interpolation method to be used between the curves.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTwoDimConsolidatedCurve(object ModelName, object BaseModel, object CurveTag, object SourceCurveTags, object SourceCurvePoints, object InterpolationMethod)
		{

			Hashtable ExtendModelWithTwoDimConsolidatedCurve_args = new Hashtable();
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("SourceCurveTags", SourceCurveTags);
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("SourceCurvePoints", SourceCurvePoints);
			ExtendModelWithTwoDimConsolidatedCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithTwoDimConsolidatedCurve", ExtendModelWithTwoDimConsolidatedCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a two-dimensional surface formed from a family of one-dimensional curves defined by dates.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="SourceCurveTags">Curve tags for the family of underlying curves.</param>
		// <param name="Maturities">Maturity associated with each underlying curve.</param>
		// <param name="MarketConvention">Market convention describing trade dates and maturity calculator for the curve maturities.</param>
		// <param name="LengthCalculator">Length calculator for converting each trade maturity into a relative length.</param>
		// <param name="InterpolationMethod">Interpolation method to be used between the curves.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTwoDimDateConsolidatedCurve(object ModelName, object BaseModel, object CurveTag, object SourceCurveTags, object Maturities, object MarketConvention, object LengthCalculator, object InterpolationMethod)
		{

			Hashtable ExtendModelWithTwoDimDateConsolidatedCurve_args = new Hashtable();
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("SourceCurveTags", SourceCurveTags);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("Maturities", Maturities);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("MarketConvention", MarketConvention);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("LengthCalculator", LengthCalculator);
			ExtendModelWithTwoDimDateConsolidatedCurve_args.Add("InterpolationMethod", InterpolationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithTwoDimDateConsolidatedCurve", ExtendModelWithTwoDimDateConsolidatedCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a two-dimensional interpolation surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the market data object to use for source points.</param>
		// <param name="TwoDimInterpolationMethod">Methodology for constructing and interpolating the curve.</param>
		// <param name="TwoDimQuoteSpecOrdering">Source for ordering quote specifications in the market data. Default value: <s>Level</s><s>SimpleMaturity</s>.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithTwoDimInterpolationCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object TwoDimInterpolationMethod, object TwoDimQuoteSpecOrdering)
		{

			Hashtable ExtendModelWithTwoDimInterpolationCurve_args = new Hashtable();
			ExtendModelWithTwoDimInterpolationCurve_args.Add("ModelName", ModelName);
			ExtendModelWithTwoDimInterpolationCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithTwoDimInterpolationCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithTwoDimInterpolationCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithTwoDimInterpolationCurve_args.Add("TwoDimInterpolationMethod", TwoDimInterpolationMethod);
			ExtendModelWithTwoDimInterpolationCurve_args.Add("TwoDimQuoteSpecOrdering", TwoDimQuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("ExtendModelWithTwoDimInterpolationCurve", ExtendModelWithTwoDimInterpolationCurve_args);
		}

		// <summary>
		// Replace the calibration valuation specification in a model.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="SourceModel">UnderlyingModel.</param>
		// <param name="ValuationMethod">Replacement valuation methodology. Default value: Default.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithValuationSpecification(object ModelName, object SourceModel, object ValuationMethod)
		{

			Hashtable ExtendModelWithValuationSpecification_args = new Hashtable();
			ExtendModelWithValuationSpecification_args.Add("ModelName", ModelName);
			ExtendModelWithValuationSpecification_args.Add("SourceModel", SourceModel);
			ExtendModelWithValuationSpecification_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("ExtendModelWithValuationSpecification", ExtendModelWithValuationSpecification_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a volatility cube.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurves">Tags identifying underlying curves describing volatility surfaces.</param>
		// <param name="VolatilityType">Type of volatility surfaces to be constructed.</param>
		// <param name="LengthCalculator">Calculation method for determining the length of underlying trade.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithVolatilityCube(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurves, object VolatilityType, object LengthCalculator)
		{

			Hashtable ExtendModelWithVolatilityCube_args = new Hashtable();
			ExtendModelWithVolatilityCube_args.Add("ModelName", ModelName);
			ExtendModelWithVolatilityCube_args.Add("BaseModel", BaseModel);
			ExtendModelWithVolatilityCube_args.Add("CurveTag", CurveTag);
			ExtendModelWithVolatilityCube_args.Add("UnderlyingCurves", UnderlyingCurves);
			ExtendModelWithVolatilityCube_args.Add("VolatilityType", VolatilityType);
			ExtendModelWithVolatilityCube_args.Add("LengthCalculator", LengthCalculator);
			return F3Formatter.f3_style_serialization("ExtendModelWithVolatilityCube", ExtendModelWithVolatilityCube_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a volatility surface.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="UnderlyingCurveTags">Tags identifying curves to be used to form the volatility surface.</param>
		// <param name="VolatilityType">Type of volatility surface to be constructed.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithVolatilitySurface(object ModelName, object BaseModel, object CurveTag, object UnderlyingCurveTags, object VolatilityType)
		{

			Hashtable ExtendModelWithVolatilitySurface_args = new Hashtable();
			ExtendModelWithVolatilitySurface_args.Add("ModelName", ModelName);
			ExtendModelWithVolatilitySurface_args.Add("BaseModel", BaseModel);
			ExtendModelWithVolatilitySurface_args.Add("CurveTag", CurveTag);
			ExtendModelWithVolatilitySurface_args.Add("UnderlyingCurveTags", UnderlyingCurveTags);
			ExtendModelWithVolatilitySurface_args.Add("VolatilityType", VolatilityType);
			return F3Formatter.f3_style_serialization("ExtendModelWithVolatilitySurface", ExtendModelWithVolatilitySurface_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a                                                                               Smith-Wilson curve deduced from zero-coupon bond prices.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to use for the Smith-Wilson curve.</param>
		// <param name="RateCurveTag">Zero-dimensional curve representing the ultimate forward rate.</param>
		// <param name="ZeroCouponBondPriceTag">Zero-coupon bond price market data tag.</param>
		// <param name="MeanReversionCurveTag">Zero-dimensional curve representing the Smith Wilson mean       reversion speed.</param>
		// <param name="SmoothingParameterTag">Smoothing parameter market data tag. Default value: default-constructed instance of type marketdata_tag.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithZeroCouponBondSmithWilsonCurve(object ModelName, object BaseModel, object CurveTag, object RateCurveTag, object ZeroCouponBondPriceTag, object MeanReversionCurveTag, object SmoothingParameterTag)
		{

			Hashtable ExtendModelWithZeroCouponBondSmithWilsonCurve_args = new Hashtable();
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("ModelName", ModelName);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("RateCurveTag", RateCurveTag);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("ZeroCouponBondPriceTag", ZeroCouponBondPriceTag);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("MeanReversionCurveTag", MeanReversionCurveTag);
			ExtendModelWithZeroCouponBondSmithWilsonCurve_args.Add("SmoothingParameterTag", SmoothingParameterTag);
			return F3Formatter.f3_style_serialization("ExtendModelWithZeroCouponBondSmithWilsonCurve", ExtendModelWithZeroCouponBondSmithWilsonCurve_args);
		}

		// <summary>
		// Create a model from an existing model with the addition of a zero-dimensional curve.
		// </summary>
		// <param name="ModelName">Name to use for the new model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Tag to be associated with the new curve.</param>
		// <param name="MarketDataTag">Tag identifying the parameters that provide the basis for the zero-dimensional curves.</param>
		// <param name="MarketDataIndex">Vector of indices identifying the parameters to be added to the model as zero-dimensional curves. Default value: default-constructed instance of type unsigned_small_integer_vector.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object ExtendModelWithZeroDimensionalCurve(object ModelName, object BaseModel, object CurveTag, object MarketDataTag, object MarketDataIndex)
		{

			Hashtable ExtendModelWithZeroDimensionalCurve_args = new Hashtable();
			ExtendModelWithZeroDimensionalCurve_args.Add("ModelName", ModelName);
			ExtendModelWithZeroDimensionalCurve_args.Add("BaseModel", BaseModel);
			ExtendModelWithZeroDimensionalCurve_args.Add("CurveTag", CurveTag);
			ExtendModelWithZeroDimensionalCurve_args.Add("MarketDataTag", MarketDataTag);
			ExtendModelWithZeroDimensionalCurve_args.Add("MarketDataIndex", MarketDataIndex);
			return F3Formatter.f3_style_serialization("ExtendModelWithZeroDimensionalCurve", ExtendModelWithZeroDimensionalCurve_args);
		}

		// <summary>
		// Extract the quotes present in a given market data set.
		// </summary>
		// <param name="MarketDataSet">Market data from which to extract a full quote list.</param>
		// <param name="CondenseQuoteSpecs">Flag indicating whether to condense composite quote specifications into a single string. Default value: true.</param>
		public object ExtractAllMarketDataQuotes(object MarketDataSet, object CondenseQuoteSpecs)
		{

			Hashtable ExtractAllMarketDataQuotes_args = new Hashtable();
			ExtractAllMarketDataQuotes_args.Add("MarketDataSet", MarketDataSet);
			ExtractAllMarketDataQuotes_args.Add("CondenseQuoteSpecs", CondenseQuoteSpecs);
			return F3Formatter.f3_style_serialization("ExtractAllMarketDataQuotes", ExtractAllMarketDataQuotes_args);
		}

		// <summary>
		// Extract the correlation matrices from the user supplied hybrid modeling correlation curve.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="Indices">Indices specifying the marginal distributions for which the correlation matrices are to be extracted.</param>
		// <param name="RemoveDualStateVariableTemplates">Array of flags indicating whether dual state variable templates must be removed (1) or not (0) from the market data. Default value: default-constructed instance of type unsigned_small_integer_vector.</param>
		// <param name="EvaluationPoints">Points at which the correlation matrices are to be extracted.</param>
		public object ExtractDirectHybridModelingCorrelationCurveValue(object Model, object Indices, object RemoveDualStateVariableTemplates, object EvaluationPoints)
		{

			Hashtable ExtractDirectHybridModelingCorrelationCurveValue_args = new Hashtable();
			ExtractDirectHybridModelingCorrelationCurveValue_args.Add("Model", Model);
			ExtractDirectHybridModelingCorrelationCurveValue_args.Add("Indices", Indices);
			ExtractDirectHybridModelingCorrelationCurveValue_args.Add("RemoveDualStateVariableTemplates", RemoveDualStateVariableTemplates);
			ExtractDirectHybridModelingCorrelationCurveValue_args.Add("EvaluationPoints", EvaluationPoints);
			return F3Formatter.f3_style_serialization("ExtractDirectHybridModelingCorrelationCurveValue", ExtractDirectHybridModelingCorrelationCurveValue_args);
		}

		// <summary>
		// Extract the quotes present in a given market data element.
		// </summary>
		// <param name="MarketDataSet">Market data from which to extract an element's quote list.</param>
		// <param name="MarketDataTag">Tag identifying the market data element whose quotes are to be extracted.</param>
		// <param name="CondenseQuoteSpecs">Flag indicating whether to condense composite quote specifications into a single string. Default value: true.</param>
		public object ExtractElementMarketDataQuotes(object MarketDataSet, object MarketDataTag, object CondenseQuoteSpecs)
		{

			Hashtable ExtractElementMarketDataQuotes_args = new Hashtable();
			ExtractElementMarketDataQuotes_args.Add("MarketDataSet", MarketDataSet);
			ExtractElementMarketDataQuotes_args.Add("MarketDataTag", MarketDataTag);
			ExtractElementMarketDataQuotes_args.Add("CondenseQuoteSpecs", CondenseQuoteSpecs);
			return F3Formatter.f3_style_serialization("ExtractElementMarketDataQuotes", ExtractElementMarketDataQuotes_args);
		}

		// <summary>
		// Compute an FX rate from a curve in a model.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model. Default value: <s>UniqueFXRatesCurve</s><s>FXRates</s>.</param>
		// <param name="AssetCurrency">Asset currency.</param>
		// <param name="NumeraireCurrency">Numeraire currency.</param>
		// <param name="DoRisk">True if risk of FX rate is to be evaluated. Default value: false.</param>
		// <param name="OptionalRiskWeighting">Optional weight to be applied to risk output. Default value: 1.0.</param>
		public object ExtractFXRate(object Model, object CurveTag, object AssetCurrency, object NumeraireCurrency, object DoRisk, object OptionalRiskWeighting)
		{

			Hashtable ExtractFXRate_args = new Hashtable();
			ExtractFXRate_args.Add("Model", Model);
			ExtractFXRate_args.Add("CurveTag", CurveTag);
			ExtractFXRate_args.Add("AssetCurrency", AssetCurrency);
			ExtractFXRate_args.Add("NumeraireCurrency", NumeraireCurrency);
			ExtractFXRate_args.Add("DoRisk", DoRisk);
			ExtractFXRate_args.Add("OptionalRiskWeighting", OptionalRiskWeighting);
			return F3Formatter.f3_style_serialization("ExtractFXRate", ExtractFXRate_args);
		}

		// <summary>
		// Extract the alpha parameter from a SABR calibration.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="Beta">Tag identifying one-dimensional beta curve.</param>
		// <param name="Rho">Tag identifying one-dimensional rho curve.</param>
		// <param name="Nu">Tag identifying one-dimensional nu curve.</param>
		// <param name="Volatility">Tag identifying Black volatility cube or surface.</param>
		// <param name="SwapTenor">Swap tenor for slicing the volatility cube. Default value: default-constructed instance of type length_set.</param>
		// <param name="Forward">Forward value of the underlying asset.</param>
		// <param name="Expiry">Expiry time.</param>
		// <param name="DoRisk">True if risk is to be evaluated. Default value: false.</param>
		public object ExtractImpliedSABRAlphaATM(object Model, object Beta, object Rho, object Nu, object Volatility, object SwapTenor, object Forward, object Expiry, object DoRisk)
		{

			Hashtable ExtractImpliedSABRAlphaATM_args = new Hashtable();
			ExtractImpliedSABRAlphaATM_args.Add("Model", Model);
			ExtractImpliedSABRAlphaATM_args.Add("Beta", Beta);
			ExtractImpliedSABRAlphaATM_args.Add("Rho", Rho);
			ExtractImpliedSABRAlphaATM_args.Add("Nu", Nu);
			ExtractImpliedSABRAlphaATM_args.Add("Volatility", Volatility);
			ExtractImpliedSABRAlphaATM_args.Add("SwapTenor", SwapTenor);
			ExtractImpliedSABRAlphaATM_args.Add("Forward", Forward);
			ExtractImpliedSABRAlphaATM_args.Add("Expiry", Expiry);
			ExtractImpliedSABRAlphaATM_args.Add("DoRisk", DoRisk);
			return F3Formatter.f3_style_serialization("ExtractImpliedSABRAlphaATM", ExtractImpliedSABRAlphaATM_args);
		}

		// <summary>
		// Extract the instrument type name for a set of instruments.
		// </summary>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		public object ExtractInstrumentTypeName(object InstrumentList)
		{

			Hashtable ExtractInstrumentTypeName_args = new Hashtable();
			ExtractInstrumentTypeName_args.Add("InstrumentList", InstrumentList);
			return F3Formatter.f3_style_serialization("ExtractInstrumentTypeName", ExtractInstrumentTypeName_args);
		}

		// <summary>
		// Get the covariance matrices out of a model, given the simulation observation points.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying the covariance curve within the model.</param>
		// <param name="LiborIndex">LIBOR index.</param>
		// <param name="ObservationTimes">Observation time points.</param>
		public object ExtractLMMCovarianceMatrices(object Model, object CurveTag, object LiborIndex, object ObservationTimes)
		{

			Hashtable ExtractLMMCovarianceMatrices_args = new Hashtable();
			ExtractLMMCovarianceMatrices_args.Add("Model", Model);
			ExtractLMMCovarianceMatrices_args.Add("CurveTag", CurveTag);
			ExtractLMMCovarianceMatrices_args.Add("LiborIndex", LiborIndex);
			ExtractLMMCovarianceMatrices_args.Add("ObservationTimes", ObservationTimes);
			return F3Formatter.f3_style_serialization("ExtractLMMCovarianceMatrices", ExtractLMMCovarianceMatrices_args);
		}

		// <summary>
		// Extract the LMM fixing dates from a model, given the simulation observation dates.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying the covariance curve within the model.</param>
		// <param name="LiborIndex">LIBOR Index.</param>
		// <param name="ObservationTimes">Observation time points.</param>
		public object ExtractLMMFixingDates(object Model, object CurveTag, object LiborIndex, object ObservationTimes)
		{

			Hashtable ExtractLMMFixingDates_args = new Hashtable();
			ExtractLMMFixingDates_args.Add("Model", Model);
			ExtractLMMFixingDates_args.Add("CurveTag", CurveTag);
			ExtractLMMFixingDates_args.Add("LiborIndex", LiborIndex);
			ExtractLMMFixingDates_args.Add("ObservationTimes", ObservationTimes);
			return F3Formatter.f3_style_serialization("ExtractLMMFixingDates", ExtractLMMFixingDates_args);
		}

		// <summary>
		// Extract the LMM start dates from a model, given the simulation observation dates.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying the covariance curve within the model.</param>
		// <param name="LiborIndex">LIBOR Index.</param>
		// <param name="ObservationTimes">Observation time points.</param>
		public object ExtractLMMStartDates(object Model, object CurveTag, object LiborIndex, object ObservationTimes)
		{

			Hashtable ExtractLMMStartDates_args = new Hashtable();
			ExtractLMMStartDates_args.Add("Model", Model);
			ExtractLMMStartDates_args.Add("CurveTag", CurveTag);
			ExtractLMMStartDates_args.Add("LiborIndex", LiborIndex);
			ExtractLMMStartDates_args.Add("ObservationTimes", ObservationTimes);
			return F3Formatter.f3_style_serialization("ExtractLMMStartDates", ExtractLMMStartDates_args);
		}

		// <summary>
		// Extract the market data quotes (and quote specifications) for a set of instruments.
		// </summary>
		// <param name="InstrumentList">Vector of market data instruments.</param>
		// <param name="CondenseQuoteSpecs">Flag indicating whether to condense composite quote specifications into a single string. Default value: false.</param>
		public object ExtractMarketDataQuotes(object InstrumentList, object CondenseQuoteSpecs)
		{

			Hashtable ExtractMarketDataQuotes_args = new Hashtable();
			ExtractMarketDataQuotes_args.Add("InstrumentList", InstrumentList);
			ExtractMarketDataQuotes_args.Add("CondenseQuoteSpecs", CondenseQuoteSpecs);
			return F3Formatter.f3_style_serialization("ExtractMarketDataQuotes", ExtractMarketDataQuotes_args);
		}

		// <summary>
		// Compute the value of a one-dimensional curve in a model at a given point.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		// <param name="EvaluationPoint">Point at which curve is to be evaluated.</param>
		// <param name="DoRisk">True if risk of curve point is to be evaluated. Default value: false.</param>
		// <param name="OptionalRiskWeighting">Optional weight to be applied to risk output. Default value: 1.0.</param>
		public object ExtractOneDimensionalCurveValue(object Model, object CurveTag, object EvaluationPoint, object DoRisk, object OptionalRiskWeighting)
		{

			Hashtable ExtractOneDimensionalCurveValue_args = new Hashtable();
			ExtractOneDimensionalCurveValue_args.Add("Model", Model);
			ExtractOneDimensionalCurveValue_args.Add("CurveTag", CurveTag);
			ExtractOneDimensionalCurveValue_args.Add("EvaluationPoint", EvaluationPoint);
			ExtractOneDimensionalCurveValue_args.Add("DoRisk", DoRisk);
			ExtractOneDimensionalCurveValue_args.Add("OptionalRiskWeighting", OptionalRiskWeighting);
			return F3Formatter.f3_style_serialization("ExtractOneDimensionalCurveValue", ExtractOneDimensionalCurveValue_args);
		}

		// <summary>
		// Compute the values of a one-dimensional curve in a model at a set of points.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		// <param name="EvaluationPoints">Points at which curve is to be evaluated, as model times. Default value: default-constructed instance of type vector.</param>
		public object ExtractOneDimensionalCurveValues(object Model, object CurveTag, object EvaluationPoints)
		{

			Hashtable ExtractOneDimensionalCurveValues_args = new Hashtable();
			ExtractOneDimensionalCurveValues_args.Add("Model", Model);
			ExtractOneDimensionalCurveValues_args.Add("CurveTag", CurveTag);
			ExtractOneDimensionalCurveValues_args.Add("EvaluationPoints", EvaluationPoints);
			return F3Formatter.f3_style_serialization("ExtractOneDimensionalCurveValues", ExtractOneDimensionalCurveValues_args);
		}

		// <summary>
		// Compute the value of a three-dimensional curve in a model at a given point.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		// <param name="EvaluationPointX">First point at which curve is to be evaluated.</param>
		// <param name="EvaluationPointY">Second point at which curve is to be evaluated.</param>
		// <param name="EvaluationPointZ">Third point at which curve is to be evaluated.</param>
		// <param name="DoRisk">True if risk of curve point is to be evaluated. Default value: false.</param>
		// <param name="OptionalRiskWeighting">Optional weight to be applied to risk output. Default value: 1.0.</param>
		public object ExtractThreeDimensionalCurveValue(object Model, object CurveTag, object EvaluationPointX, object EvaluationPointY, object EvaluationPointZ, object DoRisk, object OptionalRiskWeighting)
		{

			Hashtable ExtractThreeDimensionalCurveValue_args = new Hashtable();
			ExtractThreeDimensionalCurveValue_args.Add("Model", Model);
			ExtractThreeDimensionalCurveValue_args.Add("CurveTag", CurveTag);
			ExtractThreeDimensionalCurveValue_args.Add("EvaluationPointX", EvaluationPointX);
			ExtractThreeDimensionalCurveValue_args.Add("EvaluationPointY", EvaluationPointY);
			ExtractThreeDimensionalCurveValue_args.Add("EvaluationPointZ", EvaluationPointZ);
			ExtractThreeDimensionalCurveValue_args.Add("DoRisk", DoRisk);
			ExtractThreeDimensionalCurveValue_args.Add("OptionalRiskWeighting", OptionalRiskWeighting);
			return F3Formatter.f3_style_serialization("ExtractThreeDimensionalCurveValue", ExtractThreeDimensionalCurveValue_args);
		}

		// <summary>
		// Compute the value of a two-dimensional curve in a model at a given point.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		// <param name="EvaluationPointX">First point at which curve is to be evaluated.</param>
		// <param name="EvaluationPointY">Second point at which curve is to be evaluated.</param>
		// <param name="DoRisk">True if risk of curve point is to be evaluated. Default value: false.</param>
		// <param name="OptionalRiskWeighting">Optional weight to be applied to risk output. Default value: 1.0.</param>
		public object ExtractTwoDimensionalCurveValue(object Model, object CurveTag, object EvaluationPointX, object EvaluationPointY, object DoRisk, object OptionalRiskWeighting)
		{

			Hashtable ExtractTwoDimensionalCurveValue_args = new Hashtable();
			ExtractTwoDimensionalCurveValue_args.Add("Model", Model);
			ExtractTwoDimensionalCurveValue_args.Add("CurveTag", CurveTag);
			ExtractTwoDimensionalCurveValue_args.Add("EvaluationPointX", EvaluationPointX);
			ExtractTwoDimensionalCurveValue_args.Add("EvaluationPointY", EvaluationPointY);
			ExtractTwoDimensionalCurveValue_args.Add("DoRisk", DoRisk);
			ExtractTwoDimensionalCurveValue_args.Add("OptionalRiskWeighting", OptionalRiskWeighting);
			return F3Formatter.f3_style_serialization("ExtractTwoDimensionalCurveValue", ExtractTwoDimensionalCurveValue_args);
		}

		// <summary>
		// Extract the points underlying an interpolated 1d curve.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		public object ExtractUnderlyingInterpolationPoints(object Model, object CurveTag)
		{

			Hashtable ExtractUnderlyingInterpolationPoints_args = new Hashtable();
			ExtractUnderlyingInterpolationPoints_args.Add("Model", Model);
			ExtractUnderlyingInterpolationPoints_args.Add("CurveTag", CurveTag);
			return F3Formatter.f3_style_serialization("ExtractUnderlyingInterpolationPoints", ExtractUnderlyingInterpolationPoints_args);
		}

		// <summary>
		// Extract the constant parameter of a zero-dimensional curve in a model.
		// </summary>
		// <param name="Model">Model to use.</param>
		// <param name="CurveTag">Tag identifying curve within the model.</param>
		// <param name="ParameterIndex">Zero-based index identifying which parameter to output. Default value: 0.</param>
		// <param name="DoRisk">True if risk of curve point is to be evaluated. Default value: false.</param>
		// <param name="OptionalRiskWeighting">Optional weight to be applied to risk output. Default value: 1.0.</param>
		public object ExtractZeroDimensionalCurveValue(object Model, object CurveTag, object ParameterIndex, object DoRisk, object OptionalRiskWeighting)
		{

			Hashtable ExtractZeroDimensionalCurveValue_args = new Hashtable();
			ExtractZeroDimensionalCurveValue_args.Add("Model", Model);
			ExtractZeroDimensionalCurveValue_args.Add("CurveTag", CurveTag);
			ExtractZeroDimensionalCurveValue_args.Add("ParameterIndex", ParameterIndex);
			ExtractZeroDimensionalCurveValue_args.Add("DoRisk", DoRisk);
			ExtractZeroDimensionalCurveValue_args.Add("OptionalRiskWeighting", OptionalRiskWeighting);
			return F3Formatter.f3_style_serialization("ExtractZeroDimensionalCurveValue", ExtractZeroDimensionalCurveValue_args);
		}

		// <summary>
		// Return the input argument.
		// </summary>
		// <param name="Input">The object that will be returned.</param>
		public object F3Echo(object Input)
		{

			Hashtable F3Echo_args = new Hashtable();
			F3Echo_args.Add("Input", Input);
			return F3Formatter.f3_style_serialization("F3Echo", F3Echo_args);
		}

		// <summary>
		// Form a curve tag for the unique FX rates curve in a model.
		// </summary>
		// <param name="DummyArg">Dummy argument for flow control.</param>
		public object FXRatesCurveTag(object DummyArg)
		{

			Hashtable FXRatesCurveTag_args = new Hashtable();
			FXRatesCurveTag_args.Add("DummyArg", DummyArg);
			return F3Formatter.f3_style_serialization("FXRatesCurveTag", FXRatesCurveTag_args);
		}

		// <summary>
		// Evaluate the discrete Fourier transform of a one-dimensional complex vector.
		// </summary>
		// <param name="Data">Vector of complex data.</param>
		// <param name="TransformNotInverse">A specification of whether to perform the transform or the inverse transform.</param>
		// <param name="FractionalTransform">A specification of whether to perform fractional transform. Default value: False.</param>
		// <param name="Fraction">Fractional fast Fourier transform parameter. Default value: default-constructed instance of type real.</param>
		public object FastFourierTransform(object Data, object TransformNotInverse, object FractionalTransform, object Fraction)
		{

			Hashtable FastFourierTransform_args = new Hashtable();
			FastFourierTransform_args.Add("Data", Data);
			FastFourierTransform_args.Add("TransformNotInverse", TransformNotInverse);
			FastFourierTransform_args.Add("FractionalTransform", FractionalTransform);
			FastFourierTransform_args.Add("Fraction", Fraction);
			return F3Formatter.f3_style_serialization("FastFourierTransform", FastFourierTransform_args);
		}

		// <summary>
		// Extract a cached value.
		// </summary>
		// <param name="CacheIdentifier">Unique identifier for cache entry.</param>
		// <param name="SplitLongString">If true, long strings fetched from the Cache will be split. Default value: False.</param>
		public object FetchFunctionValueCacheMember(object CacheIdentifier, object SplitLongString)
		{

			Hashtable FetchFunctionValueCacheMember_args = new Hashtable();
			FetchFunctionValueCacheMember_args.Add("CacheIdentifier", CacheIdentifier);
			FetchFunctionValueCacheMember_args.Add("SplitLongString", SplitLongString);
			return F3Formatter.f3_style_serialization("FetchFunctionValueCacheMember", FetchFunctionValueCacheMember_args);
		}

		// <summary>
		// Find a maturity descriptor.
		// </summary>
		// <param name="StartDate">Start date.</param>
		// <param name="EndDate">End date.</param>
		// <param name="MaturityCalculator">Maturity calculator.</param>
		// <param name="ClosestBeforeEndDate">Flag indicating how to shift the end date if it is not valid.</param>
		// <param name="ToleranceInDays">Flag indicating tolerance (in days) for rounding to the nearest month. Default value: 0.</param>
		public object FindMaturityDescriptorAsString(object StartDate, object EndDate, object MaturityCalculator, object ClosestBeforeEndDate, object ToleranceInDays)
		{

			Hashtable FindMaturityDescriptorAsString_args = new Hashtable();
			FindMaturityDescriptorAsString_args.Add("StartDate", StartDate);
			FindMaturityDescriptorAsString_args.Add("EndDate", EndDate);
			FindMaturityDescriptorAsString_args.Add("MaturityCalculator", MaturityCalculator);
			FindMaturityDescriptorAsString_args.Add("ClosestBeforeEndDate", ClosestBeforeEndDate);
			FindMaturityDescriptorAsString_args.Add("ToleranceInDays", ToleranceInDays);
			return F3Formatter.f3_style_serialization("FindMaturityDescriptorAsString", FindMaturityDescriptorAsString_args);
		}

		// <summary>
		// Searches all objects for matches to the given search expression.
		// </summary>
		// <param name="SearchExpression">The search expression to use.</param>
		public object FindObject(object SearchExpression)
		{

			Hashtable FindObject_args = new Hashtable();
			FindObject_args.Add("SearchExpression", SearchExpression);
			return F3Formatter.f3_style_serialization("FindObject", FindObject_args);
		}

		// <summary>
		// Form a curve tag for a curve that represents a user-defined fixed coupon of a trade.
		// </summary>
		// <param name="FixedCouponIndex">The index defining the fixed coupon.</param>
		public object FixedCouponCurveTag(object FixedCouponIndex)
		{

			Hashtable FixedCouponCurveTag_args = new Hashtable();
			FixedCouponCurveTag_args.Add("FixedCouponIndex", FixedCouponIndex);
			return F3Formatter.f3_style_serialization("FixedCouponCurveTag", FixedCouponCurveTag_args);
		}

		// <summary>
		// Form a fixings curve tag from an index.
		// </summary>
		// <param name="Index">Index for which a fixings curve is to be formed.</param>
		public object FixingsCurveTag(object Index)
		{

			Hashtable FixingsCurveTag_args = new Hashtable();
			FixingsCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("FixingsCurveTag", FixingsCurveTag_args);
		}

		// <summary>
		// Form a curve tag for pairwise index time-independent correlations.
		// </summary>
		// <param name="DummyArg">Dummy argument for flow control.</param>
		public object FlatCorrelationCurveTag(object DummyArg)
		{

			Hashtable FlatCorrelationCurveTag_args = new Hashtable();
			FlatCorrelationCurveTag_args.Add("DummyArg", DummyArg);
			return F3Formatter.f3_style_serialization("FlatCorrelationCurveTag", FlatCorrelationCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a flat volatility provider.
		// </summary>
		// <param name="VolatileIndex">The index which is being modeled.</param>
		public object FlatVolatilityProviderCurveTag(object VolatileIndex)
		{

			Hashtable FlatVolatilityProviderCurveTag_args = new Hashtable();
			FlatVolatilityProviderCurveTag_args.Add("VolatileIndex", VolatileIndex);
			return F3Formatter.f3_style_serialization("FlatVolatilityProviderCurveTag", FlatVolatilityProviderCurveTag_args);
		}

		// <summary>
		// Reverse the order of the columns of a 2d array.
		// </summary>
		// <param name="InputArray">Array of variants.</param>
		public object FlipColumns(object InputArray)
		{

			Hashtable FlipColumns_args = new Hashtable();
			FlipColumns_args.Add("InputArray", InputArray);
			return F3Formatter.f3_style_serialization("FlipColumns", FlipColumns_args);
		}

		// <summary>
		// Reverse the order of the rows of a 2d array.
		// </summary>
		// <param name="InputArray">Array of variants.</param>
		public object FlipRows(object InputArray)
		{

			Hashtable FlipRows_args = new Hashtable();
			FlipRows_args.Add("InputArray", InputArray);
			return F3Formatter.f3_style_serialization("FlipRows", FlipRows_args);
		}

		// <summary>
		// Form an index representing an overnight rate.
		// </summary>
		// <param name="IndexName">Name to use for the created index.</param>
		// <param name="Currency">Currency to which the rate applies.</param>
		// <param name="OvernightRateSettlementDelay">Settlement delay of the overnight rate.</param>
		// <param name="OvernightRateDayCountType">Day count convention for daily compounding.</param>
		// <param name="PaymentHolidays">Holiday convention specifying valid payment days.</param>
		// <param name="FixingHolidays">Holiday convention specifying valid fixing days. Default value: default-constructed instance of type holidays.</param>
		// <returns>Retuns the name of the constructed object of type Index.</returns>
		public object FormBasicOvernightRateIndex(object IndexName, object Currency, object OvernightRateSettlementDelay, object OvernightRateDayCountType, object PaymentHolidays, object FixingHolidays)
		{

			Hashtable FormBasicOvernightRateIndex_args = new Hashtable();
			FormBasicOvernightRateIndex_args.Add("IndexName", IndexName);
			FormBasicOvernightRateIndex_args.Add("Currency", Currency);
			FormBasicOvernightRateIndex_args.Add("OvernightRateSettlementDelay", OvernightRateSettlementDelay);
			FormBasicOvernightRateIndex_args.Add("OvernightRateDayCountType", OvernightRateDayCountType);
			FormBasicOvernightRateIndex_args.Add("PaymentHolidays", PaymentHolidays);
			FormBasicOvernightRateIndex_args.Add("FixingHolidays", FixingHolidays);
			return F3Formatter.f3_style_serialization("FormBasicOvernightRateIndex", FormBasicOvernightRateIndex_args);
		}

		// <summary>
		// Form a market data set containing a set of cash deposit rates.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="MaturityQuotePairs">A two-column table specifying maturities and rates.</param>
		// <param name="MarketConventions">Market Conventions for deposit dates.</param>
		// <param name="Currency">Currency of deposits.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object FormCashDepoMarketData(object MarketDataSetName, object MaturityQuotePairs, object MarketConventions, object Currency)
		{

			Hashtable FormCashDepoMarketData_args = new Hashtable();
			FormCashDepoMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			FormCashDepoMarketData_args.Add("MaturityQuotePairs", MaturityQuotePairs);
			FormCashDepoMarketData_args.Add("MarketConventions", MarketConventions);
			FormCashDepoMarketData_args.Add("Currency", Currency);
			return F3Formatter.f3_style_serialization("FormCashDepoMarketData", FormCashDepoMarketData_args);
		}

		// <summary>
		// Form a market data set containing a set of forward rate agreements.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="MaturityQuotePairs">A two-column table specifying the FRA start maturities and the corresponding contract rates.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object FormFRAMarketData(object MarketDataSetName, object MaturityQuotePairs, object FloatingIndex)
		{

			Hashtable FormFRAMarketData_args = new Hashtable();
			FormFRAMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			FormFRAMarketData_args.Add("MaturityQuotePairs", MaturityQuotePairs);
			FormFRAMarketData_args.Add("FloatingIndex", FloatingIndex);
			return F3Formatter.f3_style_serialization("FormFRAMarketData", FormFRAMarketData_args);
		}

		// <summary>
		// Form a market data set containing a set of interest rate futures positions.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="MaturityQuotePairs">A two-column table specifying the futures expiries and the corresponding prices.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FuturesContractType">Type of futures contract. Default value: Standard.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object FormFuturesMarketData(object MarketDataSetName, object MaturityQuotePairs, object FloatingIndex, object FuturesContractType)
		{

			Hashtable FormFuturesMarketData_args = new Hashtable();
			FormFuturesMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			FormFuturesMarketData_args.Add("MaturityQuotePairs", MaturityQuotePairs);
			FormFuturesMarketData_args.Add("FloatingIndex", FloatingIndex);
			FormFuturesMarketData_args.Add("FuturesContractType", FuturesContractType);
			return F3Formatter.f3_style_serialization("FormFuturesMarketData", FormFuturesMarketData_args);
		}

		// <summary>
		// Form market convention applying a settlement delay.
		// </summary>
		// <param name="Name">Name to use for created market convention.</param>
		// <param name="Delay">Settlement delay.</param>
		// <param name="Holidays">Holiday convention specifying valid settlement days.</param>
		// <returns>Retuns the name of the constructed object of type MarketConventions.</returns>
		public object FormSimpleDelaySettlementMarketConvention(object Name, object Delay, object Holidays)
		{

			Hashtable FormSimpleDelaySettlementMarketConvention_args = new Hashtable();
			FormSimpleDelaySettlementMarketConvention_args.Add("Name", Name);
			FormSimpleDelaySettlementMarketConvention_args.Add("Delay", Delay);
			FormSimpleDelaySettlementMarketConvention_args.Add("Holidays", Holidays);
			return F3Formatter.f3_style_serialization("FormSimpleDelaySettlementMarketConvention", FormSimpleDelaySettlementMarketConvention_args);
		}

		// <summary>
		// Form a market data set containing a set of vanilla interest rate swaps.
		// </summary>
		// <param name="MarketDataSetName">Name of the market data set.</param>
		// <param name="MaturityQuotePairs">A two-column table specifying swap maturities and the corresponding market quoted par swap rates.</param>
		// <param name="FloatingIndex">Floating rate index.</param>
		// <param name="FixedLegMarketConventions">Market conventions for the fixed leg.</param>
		// <param name="FloatingLegMarketConventions">Market conventions for the floating leg. Default value: default-constructed instance of type market_conventions.</param>
		// <returns>Retuns the name of the constructed object of type MarketDataSet.</returns>
		public object FormVanillaIRSMarketData(object MarketDataSetName, object MaturityQuotePairs, object FloatingIndex, object FixedLegMarketConventions, object FloatingLegMarketConventions)
		{

			Hashtable FormVanillaIRSMarketData_args = new Hashtable();
			FormVanillaIRSMarketData_args.Add("MarketDataSetName", MarketDataSetName);
			FormVanillaIRSMarketData_args.Add("MaturityQuotePairs", MaturityQuotePairs);
			FormVanillaIRSMarketData_args.Add("FloatingIndex", FloatingIndex);
			FormVanillaIRSMarketData_args.Add("FixedLegMarketConventions", FixedLegMarketConventions);
			FormVanillaIRSMarketData_args.Add("FloatingLegMarketConventions", FloatingLegMarketConventions);
			return F3Formatter.f3_style_serialization("FormVanillaIRSMarketData", FormVanillaIRSMarketData_args);
		}

		// <summary>
		// Create a variance swap product given a strike contract rate as the fixed leg and realized variance defined in terms of an underlying index as the floating leg..
		// </summary>
		// <param name="ProductName">Name to use for the created product.</param>
		// <param name="StartDate">Date for which the variance swap starts.</param>
		// <param name="MaturityDate">Maturity of the variance swap.</param>
		// <param name="Notional">Notional amount of the variance swap.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="ContractStrike">Strike price of the variance swap, expressed as a volatility.</param>
		// <param name="StrikeMarketConvention">Market convention for the contract strike observation.</param>
		// <param name="StrikeScaleIndex">Index scaling the strike cash flow payment.</param>
		// <param name="UnderlyingIndex">Underlying index used to calculate the realized variance accumulated from the start date to the maturity date.</param>
		// <param name="ObservationMarketConvention">Market convention for the realized variance observation.</param>
		// <param name="Margin">Margin over the realized variance index paid on each flow date.</param>
		// <param name="VarianceScaleIndex">Index scaling the realized variance cash flow payment, including any margin over the variance index.</param>
		// <param name="MeanAdjusted">True if the variance is mean-adjusted.</param>
		// <param name="Position">Indicator of payment or receipt of the realized variance.</param>
		// <returns>Retuns the name of the constructed object of type Product.</returns>
		public object FormVanillaVarianceSwapProduct(object ProductName, object StartDate, object MaturityDate, object Notional, object Currency, object ContractStrike, object StrikeMarketConvention, object StrikeScaleIndex, object UnderlyingIndex, object ObservationMarketConvention,
		object Margin, object VarianceScaleIndex, object MeanAdjusted, object Position)
		{

			Hashtable FormVanillaVarianceSwapProduct_args = new Hashtable();
			FormVanillaVarianceSwapProduct_args.Add("ProductName", ProductName);
			FormVanillaVarianceSwapProduct_args.Add("StartDate", StartDate);
			FormVanillaVarianceSwapProduct_args.Add("MaturityDate", MaturityDate);
			FormVanillaVarianceSwapProduct_args.Add("Notional", Notional);
			FormVanillaVarianceSwapProduct_args.Add("Currency", Currency);
			FormVanillaVarianceSwapProduct_args.Add("ContractStrike", ContractStrike);
			FormVanillaVarianceSwapProduct_args.Add("StrikeMarketConvention", StrikeMarketConvention);
			FormVanillaVarianceSwapProduct_args.Add("StrikeScaleIndex", StrikeScaleIndex);
			FormVanillaVarianceSwapProduct_args.Add("UnderlyingIndex", UnderlyingIndex);
			FormVanillaVarianceSwapProduct_args.Add("ObservationMarketConvention", ObservationMarketConvention);
			FormVanillaVarianceSwapProduct_args.Add("Margin", Margin);
			FormVanillaVarianceSwapProduct_args.Add("VarianceScaleIndex", VarianceScaleIndex);
			FormVanillaVarianceSwapProduct_args.Add("MeanAdjusted", MeanAdjusted);
			FormVanillaVarianceSwapProduct_args.Add("Position", Position);
			return F3Formatter.f3_style_serialization("FormVanillaVarianceSwapProduct", FormVanillaVarianceSwapProduct_args);
		}

		// <summary>
		// Generate a digital signature for the content of the stream.
		// </summary>
		// <param name="InputSource">Input file, or other stream-based resource.</param>
		// <param name="SigningKey">The secret character string used for signing the content of the input stream.</param>
		public object FunctionFileSignature(object InputSource, object SigningKey)
		{

			Hashtable FunctionFileSignature_args = new Hashtable();
			FunctionFileSignature_args.Add("InputSource", InputSource);
			FunctionFileSignature_args.Add("SigningKey", SigningKey);
			return F3Formatter.f3_style_serialization("FunctionFileSignature", FunctionFileSignature_args);
		}

		// <summary>
		// Return information about a repository member.
		// </summary>
		// <param name="Function">The function to interrogate.</param>
		// <param name="Requests">Array of requests.</param>
		public object FunctionObjectInfo(object Function_name, object Requests)
		{

			Hashtable FunctionObjectInfo_args = new Hashtable();
			FunctionObjectInfo_args.Add("Function", Function_name);
			FunctionObjectInfo_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("FunctionObjectInfo", FunctionObjectInfo_args);
		}

		// <summary>
		// Calculate the convexity-adjusted futures rate for a forward rate.
		// </summary>
		// <param name="ForwardRate">Expected value of the forward rate at the expiry time.</param>
		// <param name="ValuationTime">Observation time of the futures rate. Default value: 0.0.</param>
		// <param name="ExpiryTime">Expiry time of the futures contract.</param>
		// <param name="ConvexityFunction">Convexity function.</param>
		public object FuturesConvexity(object ForwardRate, object ValuationTime, object ExpiryTime, object ConvexityFunction)
		{

			Hashtable FuturesConvexity_args = new Hashtable();
			FuturesConvexity_args.Add("ForwardRate", ForwardRate);
			FuturesConvexity_args.Add("ValuationTime", ValuationTime);
			FuturesConvexity_args.Add("ExpiryTime", ExpiryTime);
			FuturesConvexity_args.Add("ConvexityFunction", ConvexityFunction);
			return F3Formatter.f3_style_serialization("FuturesConvexity", FuturesConvexity_args);
		}

		// <summary>
		// Form a general collateral funding curve tag from a general collateral name.
		// </summary>
		// <param name="FundingCurveName">General collateral funding curve name. Default value: NoName.</param>
		public object GeneralCollateralFundingCurveTag(object FundingCurveName)
		{

			Hashtable GeneralCollateralFundingCurveTag_args = new Hashtable();
			GeneralCollateralFundingCurveTag_args.Add("FundingCurveName", FundingCurveName);
			return F3Formatter.f3_style_serialization("GeneralCollateralFundingCurveTag", GeneralCollateralFundingCurveTag_args);
		}

		// <summary>
		// Generate a FITR string array representing a capped variance swap on an underlying index.
		// </summary>
		// <param name="StartDate">Start date of the variance swap.</param>
		// <param name="Maturity">Maturity of the variance swap.</param>
		// <param name="Notional">Notional amount of the variance swap per squared volatility point.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Strike">Strike price of the variance swap, expressed as a volatility.</param>
		// <param name="Cap">Cap on variance. Default value: default-constructed instance of type real.</param>
		// <param name="UnderlyingIndex">Underlying index for which to calculate realized variance.</param>
		// <param name="ObservationMarketConvention">Market conventions for the realized variance observation.</param>
		public object GenerateCappedVarianceSwapFITR(object StartDate, object Maturity, object Notional, object Currency, object Strike, object Cap, object UnderlyingIndex, object ObservationMarketConvention)
		{

			Hashtable GenerateCappedVarianceSwapFITR_args = new Hashtable();
			GenerateCappedVarianceSwapFITR_args.Add("StartDate", StartDate);
			GenerateCappedVarianceSwapFITR_args.Add("Maturity", Maturity);
			GenerateCappedVarianceSwapFITR_args.Add("Notional", Notional);
			GenerateCappedVarianceSwapFITR_args.Add("Currency", Currency);
			GenerateCappedVarianceSwapFITR_args.Add("Strike", Strike);
			GenerateCappedVarianceSwapFITR_args.Add("Cap", Cap);
			GenerateCappedVarianceSwapFITR_args.Add("UnderlyingIndex", UnderlyingIndex);
			GenerateCappedVarianceSwapFITR_args.Add("ObservationMarketConvention", ObservationMarketConvention);
			return F3Formatter.f3_style_serialization("GenerateCappedVarianceSwapFITR", GenerateCappedVarianceSwapFITR_args);
		}

		// <summary>
		// Generate sampling roll schedule between two dates.
		// </summary>
		// <param name="Product">Product for which a sampling roll schedule is to be calculated.</param>
		// <param name="StartDate">Sampling start date.</param>
		// <param name="SamplingStrategy">Strategy to generate sampling dates.</param>
		public object GenerateSamplingRollSchedule(object Product, object StartDate, object SamplingStrategy)
		{

			Hashtable GenerateSamplingRollSchedule_args = new Hashtable();
			GenerateSamplingRollSchedule_args.Add("Product", Product);
			GenerateSamplingRollSchedule_args.Add("StartDate", StartDate);
			GenerateSamplingRollSchedule_args.Add("SamplingStrategy", SamplingStrategy);
			return F3Formatter.f3_style_serialization("GenerateSamplingRollSchedule", GenerateSamplingRollSchedule_args);
		}

		// <summary>
		// Generate a FITR string array representing a volatility swap on an underlying index.
		// </summary>
		// <param name="StartDate">Start date of the volatility swap.</param>
		// <param name="Maturity">Maturity of the volatility swap.</param>
		// <param name="Notional">Notional amount of the volatility swap per volatility point.</param>
		// <param name="Currency">Currency of the notional amount.</param>
		// <param name="Strike">Strike price of the volatility swap.</param>
		// <param name="UnderlyingIndex">Underlying index for which to calculate realized volatility.</param>
		// <param name="ObservationMarketConvention">Market conventions for the realized volatility observation.</param>
		public object GenerateVolatilitySwapFITR(object StartDate, object Maturity, object Notional, object Currency, object Strike, object UnderlyingIndex, object ObservationMarketConvention)
		{

			Hashtable GenerateVolatilitySwapFITR_args = new Hashtable();
			GenerateVolatilitySwapFITR_args.Add("StartDate", StartDate);
			GenerateVolatilitySwapFITR_args.Add("Maturity", Maturity);
			GenerateVolatilitySwapFITR_args.Add("Notional", Notional);
			GenerateVolatilitySwapFITR_args.Add("Currency", Currency);
			GenerateVolatilitySwapFITR_args.Add("Strike", Strike);
			GenerateVolatilitySwapFITR_args.Add("UnderlyingIndex", UnderlyingIndex);
			GenerateVolatilitySwapFITR_args.Add("ObservationMarketConvention", ObservationMarketConvention);
			return F3Formatter.f3_style_serialization("GenerateVolatilitySwapFITR", GenerateVolatilitySwapFITR_args);
		}

		// <summary>
		// Bin data according to a specific histogram source.
		// </summary>
		// <param name="HistogramSource">Histogram source.</param>
		// <param name="Values">Values to bin.</param>
		// <param name="Weights">Weights of values. Default value: default-constructed instance of type vector.</param>
		public object Histogram(object HistogramSource, object Values, object Weights)
		{

			Hashtable Histogram_args = new Hashtable();
			Histogram_args.Add("HistogramSource", HistogramSource);
			Histogram_args.Add("Values", Values);
			Histogram_args.Add("Weights", Weights);
			return F3Formatter.f3_style_serialization("Histogram", Histogram_args);
		}

		// <summary>
		// Form a curve tag for the mean reversion parameter in the Hull-White model.
		// </summary>
		// <param name="RateCurveIdentifier">Means of unique curve identification.</param>
		public object HullWhiteMeanReversionCurveTag(object RateCurveIdentifier)
		{

			Hashtable HullWhiteMeanReversionCurveTag_args = new Hashtable();
			HullWhiteMeanReversionCurveTag_args.Add("RateCurveIdentifier", RateCurveIdentifier);
			return F3Formatter.f3_style_serialization("HullWhiteMeanReversionCurveTag", HullWhiteMeanReversionCurveTag_args);
		}

		// <summary>
		// Form a curve tag for the short rate volatility in the (multi-dimensional) Hull-White model.
		// </summary>
		// <param name="RateCurveIdentifier">Means of unique curve identification.</param>
		// <param name="Dimension">Optional zero-based index for the dimensionality of the short rate volatility. Default value: 0.</param>
		public object HullWhiteVolatilityCurveTag(object RateCurveIdentifier, object Dimension)
		{

			Hashtable HullWhiteVolatilityCurveTag_args = new Hashtable();
			HullWhiteVolatilityCurveTag_args.Add("RateCurveIdentifier", RateCurveIdentifier);
			HullWhiteVolatilityCurveTag_args.Add("Dimension", Dimension);
			return F3Formatter.f3_style_serialization("HullWhiteVolatilityCurveTag", HullWhiteVolatilityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for pairwise index terminal correlations.
		// </summary>
		// <param name="DummyArg">Dummy argument for flow control.</param>
		public object HybridTerminalCorrelationCurveTag(object DummyArg)
		{

			Hashtable HybridTerminalCorrelationCurveTag_args = new Hashtable();
			HybridTerminalCorrelationCurveTag_args.Add("DummyArg", DummyArg);
			return F3Formatter.f3_style_serialization("HybridTerminalCorrelationCurveTag", HybridTerminalCorrelationCurveTag_args);
		}

		// <summary>
		// Form a curve tag for an implicit compounding rate.
		// </summary>
		// <param name="CompoundingRateIndex">The index which is being compounded.</param>
		public object ImplicitCompoundingRateCurveTag(object CompoundingRateIndex)
		{

			Hashtable ImplicitCompoundingRateCurveTag_args = new Hashtable();
			ImplicitCompoundingRateCurveTag_args.Add("CompoundingRateIndex", CompoundingRateIndex);
			return F3Formatter.f3_style_serialization("ImplicitCompoundingRateCurveTag", ImplicitCompoundingRateCurveTag_args);
		}

		// <summary>
		// Evaluate the implied Black-Scholes correlation given a volatility term structure.
		// </summary>
		// <param name="Function">One-dimensional volatility term structure.</param>
		// <param name="TimeA">First time point.</param>
		// <param name="TimeB">Second time point.</param>
		public object ImpliedBlackCorrelation(object Function_name, object TimeA, object TimeB)
		{

			Hashtable ImpliedBlackCorrelation_args = new Hashtable();
			ImpliedBlackCorrelation_args.Add("Function", Function_name);
			ImpliedBlackCorrelation_args.Add("TimeA", TimeA);
			ImpliedBlackCorrelation_args.Add("TimeB", TimeB);
			return F3Formatter.f3_style_serialization("ImpliedBlackCorrelation", ImpliedBlackCorrelation_args);
		}

		// <summary>
		// Import objects from file (or other stream-based resource).
		// </summary>
		// <param name="InputSource">Input file, or other stream-based resource.</param>
		// <param name="OutputTarget">Output file, or other stream-based resource, for function logging the results of the import. Default value: default-constructed instance of type outputstream.</param>
		public object ImportObjects(object InputSource, object OutputTarget)
		{

			Hashtable ImportObjects_args = new Hashtable();
			ImportObjects_args.Add("InputSource", InputSource);
			ImportObjects_args.Add("OutputTarget", OutputTarget);
			return F3Formatter.f3_style_serialization("ImportObjects", ImportObjects_args);
		}

		// <summary>
		// Form a curve tag for a parameterized surface to be used for specifying incremental copula correlations between two correlated underlying indices in hybrid modeling.
		// </summary>
		// <param name="FirstIndexProcessPair">The first index and its stochastic process.</param>
		// <param name="SecondIndexProcessPair">The second index and its stochastic process.</param>
		public object IncrementalCopulaCorrelationCurveTag(object FirstIndexProcessPair, object SecondIndexProcessPair)
		{

			Hashtable IncrementalCopulaCorrelationCurveTag_args = new Hashtable();
			IncrementalCopulaCorrelationCurveTag_args.Add("FirstIndexProcessPair", FirstIndexProcessPair);
			IncrementalCopulaCorrelationCurveTag_args.Add("SecondIndexProcessPair", SecondIndexProcessPair);
			return F3Formatter.f3_style_serialization("IncrementalCopulaCorrelationCurveTag", IncrementalCopulaCorrelationCurveTag_args);
		}

		// <summary>
		// Form a curve tag for an inflation index curve.
		// </summary>
		// <param name="InflationIndex">Unique curve identifier.</param>
		public object InflationCurveTag(object InflationIndex)
		{

			Hashtable InflationCurveTag_args = new Hashtable();
			InflationCurveTag_args.Add("InflationIndex", InflationIndex);
			return F3Formatter.f3_style_serialization("InflationCurveTag", InflationCurveTag_args);
		}

		// <summary>
		// Form a curve tag for an inflation rate curve.
		// </summary>
		// <param name="InflationIndex">Unique curve identifier.</param>
		public object InflationRateCurveTag(object InflationIndex)
		{

			Hashtable InflationRateCurveTag_args = new Hashtable();
			InflationRateCurveTag_args.Add("InflationIndex", InflationIndex);
			return F3Formatter.f3_style_serialization("InflationRateCurveTag", InflationRateCurveTag_args);
		}

		// <summary>
		// Form a curve tag for an inflation seasonality curve.
		// </summary>
		// <param name="InflationIndex">Unique curve identifier.</param>
		public object InflationSeasonalityCurveTag(object InflationIndex)
		{

			Hashtable InflationSeasonalityCurveTag_args = new Hashtable();
			InflationSeasonalityCurveTag_args.Add("InflationIndex", InflationIndex);
			return F3Formatter.f3_style_serialization("InflationSeasonalityCurveTag", InflationSeasonalityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for an initial variance curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object InitialVarianceCurveTag(object Index)
		{

			Hashtable InitialVarianceCurveTag_args = new Hashtable();
			InitialVarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("InitialVarianceCurveTag", InitialVarianceCurveTag_args);
		}

		// <summary>
		// Insert a function call for object creation.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		// <param name="ObjectName">Name of the object.</param>
		// <param name="ConstructionCall">Construction call in F3ML file format.</param>
		// <param name="DirectDependents">Dependent objects.</param>
		// <param name="AllowSideEffects">Allow side effects of the construction call to affect the context. Default value: true.</param>
		public object InsertObjectCreationCall(object RepositoryName, object ObjectName, object ConstructionCall, object DirectDependents, object AllowSideEffects)
		{

			Hashtable InsertObjectCreationCall_args = new Hashtable();
			InsertObjectCreationCall_args.Add("RepositoryName", RepositoryName);
			InsertObjectCreationCall_args.Add("ObjectName", ObjectName);
			InsertObjectCreationCall_args.Add("ConstructionCall", ConstructionCall);
			InsertObjectCreationCall_args.Add("DirectDependents", DirectDependents);
			InsertObjectCreationCall_args.Add("AllowSideEffects", AllowSideEffects);
			return F3Formatter.f3_style_serialization("InsertObjectCreationCall", InsertObjectCreationCall_args);
		}

		// <summary>
		// Compare two instruments for equality.
		// </summary>
		// <param name="Model">The model.</param>
		// <param name="FirstInstrument">The first instrument.</param>
		// <param name="SecondInstrument">The second instrument.</param>
		// <param name="QuoteSpecOrdering">Quote ordering source.</param>
		public object InstrumentOrderEqual(object Model, object FirstInstrument, object SecondInstrument, object QuoteSpecOrdering)
		{

			Hashtable InstrumentOrderEqual_args = new Hashtable();
			InstrumentOrderEqual_args.Add("Model", Model);
			InstrumentOrderEqual_args.Add("FirstInstrument", FirstInstrument);
			InstrumentOrderEqual_args.Add("SecondInstrument", SecondInstrument);
			InstrumentOrderEqual_args.Add("QuoteSpecOrdering", QuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("InstrumentOrderEqual", InstrumentOrderEqual_args);
		}

		// <summary>
		// Compare two instruments and check if one precedes the other.
		// </summary>
		// <param name="Model">The model.</param>
		// <param name="FirstInstrument">The first instrument.</param>
		// <param name="SecondInstrument">The second instrument.</param>
		// <param name="QuoteSpecOrdering">Quote ordering source.</param>
		public object InstrumentOrderLessThan(object Model, object FirstInstrument, object SecondInstrument, object QuoteSpecOrdering)
		{

			Hashtable InstrumentOrderLessThan_args = new Hashtable();
			InstrumentOrderLessThan_args.Add("Model", Model);
			InstrumentOrderLessThan_args.Add("FirstInstrument", FirstInstrument);
			InstrumentOrderLessThan_args.Add("SecondInstrument", SecondInstrument);
			InstrumentOrderLessThan_args.Add("QuoteSpecOrdering", QuoteSpecOrdering);
			return F3Formatter.f3_style_serialization("InstrumentOrderLessThan", InstrumentOrderLessThan_args);
		}

		// <summary>
		// Return an array of integers.
		// </summary>
		// <param name="Count">Required number of integers. Default value: 10.</param>
		public object Integers(object Count)
		{

			Hashtable Integers_args = new Hashtable();
			Integers_args.Add("Count", Count);
			return F3Formatter.f3_style_serialization("Integers", Integers_args);
		}

		// <summary>
		// Form a curve tag for an interest rate curve.
		// </summary>
		// <param name="InterestRateIndex">Index representing a rate.</param>
		public object InterestRateCurveTag(object InterestRateIndex)
		{

			Hashtable InterestRateCurveTag_args = new Hashtable();
			InterestRateCurveTag_args.Add("InterestRateIndex", InterestRateIndex);
			return F3Formatter.f3_style_serialization("InterestRateCurveTag", InterestRateCurveTag_args);
		}

		// <summary>
		// Calculate the interpolation weights for a set of market data maturities.
		// </summary>
		// <param name="AnchorDate">Date from which to base the length calculation.</param>
		// <param name="LengthSetOfTrade">Length set of the trade.</param>
		// <param name="LengthCalculatorForTrade">Length calculator to use for the trade.</param>
		// <param name="LengthCalculatorForMarketData">Length calculator to use for the market data.</param>
		// <param name="MarketDataMaturities">Collection of market data maturities.</param>
		public object InterpolationWeights(object AnchorDate, object LengthSetOfTrade, object LengthCalculatorForTrade, object LengthCalculatorForMarketData, object MarketDataMaturities)
		{

			Hashtable InterpolationWeights_args = new Hashtable();
			InterpolationWeights_args.Add("AnchorDate", AnchorDate);
			InterpolationWeights_args.Add("LengthSetOfTrade", LengthSetOfTrade);
			InterpolationWeights_args.Add("LengthCalculatorForTrade", LengthCalculatorForTrade);
			InterpolationWeights_args.Add("LengthCalculatorForMarketData", LengthCalculatorForMarketData);
			InterpolationWeights_args.Add("MarketDataMaturities", MarketDataMaturities);
			return F3Formatter.f3_style_serialization("InterpolationWeights", InterpolationWeights_args);
		}

		// <summary>
		// Return the natural name for the fixings table associated with a simple interest rate.
		// </summary>
		// <param name="Currency">The currency of the interest rate.</param>
		// <param name="Tenor">Maturity description of the rate tenor.</param>
		public object IntrinsicLiborFixingsName(object Currency, object Tenor)
		{

			Hashtable IntrinsicLiborFixingsName_args = new Hashtable();
			IntrinsicLiborFixingsName_args.Add("Currency", Currency);
			IntrinsicLiborFixingsName_args.Add("Tenor", Tenor);
			return F3Formatter.f3_style_serialization("IntrinsicLiborFixingsName", IntrinsicLiborFixingsName_args);
		}

		// <summary>
		// Return the natural name for a simple interest rate.
		// </summary>
		// <param name="Currency">The currency of the interest rate.</param>
		// <param name="Tenor">Maturity description of the rate tenor.</param>
		public object IntrinsicLiborName(object Currency, object Tenor)
		{

			Hashtable IntrinsicLiborName_args = new Hashtable();
			IntrinsicLiborName_args.Add("Currency", Currency);
			IntrinsicLiborName_args.Add("Tenor", Tenor);
			return F3Formatter.f3_style_serialization("IntrinsicLiborName", IntrinsicLiborName_args);
		}

		// <summary>
		// Return the natural name for the fixings table associated with an overnight interest rate.
		// </summary>
		// <param name="Currency">The currency of the interest rate.</param>
		public object IntrinsicOvernightFixingsName(object Currency)
		{

			Hashtable IntrinsicOvernightFixingsName_args = new Hashtable();
			IntrinsicOvernightFixingsName_args.Add("Currency", Currency);
			return F3Formatter.f3_style_serialization("IntrinsicOvernightFixingsName", IntrinsicOvernightFixingsName_args);
		}

		// <summary>
		// Return the natural name for an overnight interest rate.
		// </summary>
		// <param name="Currency">The currency of the interest rate.</param>
		public object IntrinsicOvernightRateName(object Currency)
		{

			Hashtable IntrinsicOvernightRateName_args = new Hashtable();
			IntrinsicOvernightRateName_args.Add("Currency", Currency);
			return F3Formatter.f3_style_serialization("IntrinsicOvernightRateName", IntrinsicOvernightRateName_args);
		}

		// <summary>
		// Invert the specification of the direction of flows in a trade.
		// </summary>
		// <param name="PRBS">Flow direction.</param>
		public object InversePRBS(object PRBS)
		{

			Hashtable InversePRBS_args = new Hashtable();
			InversePRBS_args.Add("PRBS", PRBS);
			return F3Formatter.f3_style_serialization("InversePRBS", InversePRBS_args);
		}

		// <summary>
		// Invoke a callback function.
		// </summary>
		// <param name="Function">Callback function to be invoked.</param>
		// <param name="Argument">Text to be passed to callback function.</param>
		public object InvokeCallback(object Function_name, object Argument)
		{

			Hashtable InvokeCallback_args = new Hashtable();
			InvokeCallback_args.Add("Function", Function_name);
			InvokeCallback_args.Add("Argument", Argument);
			return F3Formatter.f3_style_serialization("InvokeCallback", InvokeCallback_args);
		}

		// <summary>
		// Determines if the two given values are absolutely equal within the given tolerance.
		// </summary>
		// <param name="Value1">The first value to compare.</param>
		// <param name="Value2">The second value to compare.</param>
		// <param name="Tolerance">Tolerance used in the comparison.</param>
		public object IsAbsolutelyClose(object Value1, object Value2, object Tolerance)
		{

			Hashtable IsAbsolutelyClose_args = new Hashtable();
			IsAbsolutelyClose_args.Add("Value1", Value1);
			IsAbsolutelyClose_args.Add("Value2", Value2);
			IsAbsolutelyClose_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("IsAbsolutelyClose", IsAbsolutelyClose_args);
		}

		// <summary>
		// Returns true if the input is an error string.
		// </summary>
		// <param name="InputString">Input to test.</param>
		public object IsErrorString(object InputString)
		{

			Hashtable IsErrorString_args = new Hashtable();
			IsErrorString_args.Add("InputString", InputString);
			return F3Formatter.f3_style_serialization("IsErrorString", IsErrorString_args);
		}

		// <summary>
		// Determine if a date is a good business day.
		// </summary>
		// <param name="Date">Date.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		public object IsGoodBusinessDay(object Date_, object HolidayConventions)
		{

			Hashtable IsGoodBusinessDay_args = new Hashtable();
			IsGoodBusinessDay_args.Add("Date", Date_);
			IsGoodBusinessDay_args.Add("HolidayConventions", HolidayConventions);
			return F3Formatter.f3_style_serialization("IsGoodBusinessDay", IsGoodBusinessDay_args);
		}

		// <summary>
		// Determines if the two given values are relatively equal within the given tolerance.
		// </summary>
		// <param name="Value1">The first value to compare.</param>
		// <param name="Value2">The second value to compare.</param>
		// <param name="Tolerance">Tolerance used in the comparison.</param>
		public object IsRelativelyClose(object Value1, object Value2, object Tolerance)
		{

			Hashtable IsRelativelyClose_args = new Hashtable();
			IsRelativelyClose_args.Add("Value1", Value1);
			IsRelativelyClose_args.Add("Value2", Value2);
			IsRelativelyClose_args.Add("Tolerance", Tolerance);
			return F3Formatter.f3_style_serialization("IsRelativelyClose", IsRelativelyClose_args);
		}

		// <summary>
		// Returns true if the input is a warning string.
		// </summary>
		// <param name="InputString">Input to test.</param>
		public object IsWarningString(object InputString)
		{

			Hashtable IsWarningString_args = new Hashtable();
			IsWarningString_args.Add("InputString", InputString);
			return F3Formatter.f3_style_serialization("IsWarningString", IsWarningString_args);
		}

		// <summary>
		// Form a LIBOR Market Model covariance curve tag from a LIBOR index.
		// </summary>
		// <param name="Index">Index for which the LMM covariance curve is to be formed.</param>
		public object LMMCovarianceCurveTag(object Index)
		{

			Hashtable LMMCovarianceCurveTag_args = new Hashtable();
			LMMCovarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("LMMCovarianceCurveTag", LMMCovarianceCurveTag_args);
		}

		// <summary>
		// Form a LIBOR Market Model terminal correlation curve tag from a LIBOR index.
		// </summary>
		// <param name="Index">Index for which the LMM terminal correlation curve is to be formed.</param>
		public object LMMTerminalCorrelationCurveTag(object Index)
		{

			Hashtable LMMTerminalCorrelationCurveTag_args = new Hashtable();
			LMMTerminalCorrelationCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("LMMTerminalCorrelationCurveTag", LMMTerminalCorrelationCurveTag_args);
		}

		// <summary>
		// Form a LIBOR Market Model terminal variance curve tag from a LIBOR index.
		// </summary>
		// <param name="Index">Index for which the LMM covariance curve is to be formed.</param>
		public object LMMTerminalVarianceCurveTag(object Index)
		{

			Hashtable LMMTerminalVarianceCurveTag_args = new Hashtable();
			LMMTerminalVarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("LMMTerminalVarianceCurveTag", LMMTerminalVarianceCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a LIBOR rate curve.
		// </summary>
		// <param name="LiborIndex">Index representing LIBOR.</param>
		public object LiborRateCurveTag(object LiborIndex)
		{

			Hashtable LiborRateCurveTag_args = new Hashtable();
			LiborRateCurveTag_args.Add("LiborIndex", LiborIndex);
			return F3Formatter.f3_style_serialization("LiborRateCurveTag", LiborRateCurveTag_args);
		}

		// <summary>
		// Return directory used for local license files.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object LicenceFileDirectory(object DummyArgument)
		{

			Hashtable LicenceFileDirectory_args = new Hashtable();
			LicenceFileDirectory_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("LicenceFileDirectory", LicenceFileDirectory_args);
		}

		// <summary>
		// Return the number of days remaining for the current license.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object LicenceLifetime(object DummyArgument)
		{

			Hashtable LicenceLifetime_args = new Hashtable();
			LicenceLifetime_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("LicenceLifetime", LicenceLifetime_args);
		}

		// <summary>
		// Return the current licensing information.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object LicencingInformation(object DummyArgument)
		{

			Hashtable LicencingInformation_args = new Hashtable();
			LicencingInformation_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("LicencingInformation", LicencingInformation_args);
		}

		// <summary>
		// Calculates the solution for the vector of regression parameters given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object LinearRegression(object RegressionSumsVector)
		{

			Hashtable LinearRegression_args = new Hashtable();
			LinearRegression_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("LinearRegression", LinearRegression_args);
		}

		// <summary>
		// Calculates the solution for the matrix of regression parameters given a vector of the sums needed for linear regression.
		// </summary>
		// <param name="NumberOfDatasets">Number of data sets.</param>
		// <param name="RegressionSumsVector">Vector of sums in Regression Product modifier format.</param>
		public object LinearRegressionForMultipleDatasets(object NumberOfDatasets, object RegressionSumsVector)
		{

			Hashtable LinearRegressionForMultipleDatasets_args = new Hashtable();
			LinearRegressionForMultipleDatasets_args.Add("NumberOfDatasets", NumberOfDatasets);
			LinearRegressionForMultipleDatasets_args.Add("RegressionSumsVector", RegressionSumsVector);
			return F3Formatter.f3_style_serialization("LinearRegressionForMultipleDatasets", LinearRegressionForMultipleDatasets_args);
		}

		// <summary>
		// List indices for compare-exchange sorting.
		// </summary>
		// <param name="SortSize">Size of the sort.</param>
		public object ListCompareSortIndices(object SortSize)
		{

			Hashtable ListCompareSortIndices_args = new Hashtable();
			ListCompareSortIndices_args.Add("SortSize", SortSize);
			return F3Formatter.f3_style_serialization("ListCompareSortIndices", ListCompareSortIndices_args);
		}

		// <summary>
		// Returns the list of types (repositories) in which objects can be constructed using object constructors..
		// </summary>
		// <param name="Dummy">A Dummy argument.</param>
		public object ListConstructableTypes(object Dummy)
		{

			Hashtable ListConstructableTypes_args = new Hashtable();
			ListConstructableTypes_args.Add("Dummy", Dummy);
			return F3Formatter.f3_style_serialization("ListConstructableTypes", ListConstructableTypes_args);
		}

		// <summary>
		// Explicit list of good business days for the given holiday conventions.
		// </summary>
		// <param name="StartDate">The first date in the desired range.</param>
		// <param name="EndDate">The last date in the desired range.</param>
		// <param name="Conventions">List of holiday conventions from which to retrieve the good business days.</param>
		public object ListExplicitGoodBusinessDays(object StartDate, object EndDate, object Conventions)
		{

			Hashtable ListExplicitGoodBusinessDays_args = new Hashtable();
			ListExplicitGoodBusinessDays_args.Add("StartDate", StartDate);
			ListExplicitGoodBusinessDays_args.Add("EndDate", EndDate);
			ListExplicitGoodBusinessDays_args.Add("Conventions", Conventions);
			return F3Formatter.f3_style_serialization("ListExplicitGoodBusinessDays", ListExplicitGoodBusinessDays_args);
		}

		// <summary>
		// Explicit list of holidays for the given holiday conventions.
		// </summary>
		// <param name="StartDate">The first date in the desired range.</param>
		// <param name="EndDate">The last date in the desired range.</param>
		// <param name="Conventions">List of holiday conventions from which to retrieve the holidays.</param>
		public object ListExplicitHolidayDates(object StartDate, object EndDate, object Conventions)
		{

			Hashtable ListExplicitHolidayDates_args = new Hashtable();
			ListExplicitHolidayDates_args.Add("StartDate", StartDate);
			ListExplicitHolidayDates_args.Add("EndDate", EndDate);
			ListExplicitHolidayDates_args.Add("Conventions", Conventions);
			return F3Formatter.f3_style_serialization("ListExplicitHolidayDates", ListExplicitHolidayDates_args);
		}

		// <summary>
		// Return a two-column array containing names and default values of parameters for a function call.
		// </summary>
		// <param name="FunctionName">Name of function.</param>
		public object ListFunctionArguments(object FunctionName)
		{

			Hashtable ListFunctionArguments_args = new Hashtable();
			ListFunctionArguments_args.Add("FunctionName", FunctionName);
			return F3Formatter.f3_style_serialization("ListFunctionArguments", ListFunctionArguments_args);
		}

		// <summary>
		// List members of the Function repository.
		// </summary>
		// <param name="DummyArg">Dummy argument for flow control.</param>
		public object ListFunctions(object DummyArg)
		{

			Hashtable ListFunctions_args = new Hashtable();
			ListFunctions_args.Add("DummyArg", DummyArg);
			return F3Formatter.f3_style_serialization("ListFunctions", ListFunctions_args);
		}

		// <summary>
		// List members of a repository.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		public object ListMembers(object RepositoryName)
		{

			Hashtable ListMembers_args = new Hashtable();
			ListMembers_args.Add("RepositoryName", RepositoryName);
			return F3Formatter.f3_style_serialization("ListMembers", ListMembers_args);
		}

		// <summary>
		// Returns the subset of object constructors for the given repository.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		public object ListObjectConstructors(object RepositoryName)
		{

			Hashtable ListObjectConstructors_args = new Hashtable();
			ListObjectConstructors_args.Add("RepositoryName", RepositoryName);
			return F3Formatter.f3_style_serialization("ListObjectConstructors", ListObjectConstructors_args);
		}

		// <summary>
		// List all objects used in the construction of the specified object.
		// </summary>
		// <param name="RepositoryName">List of repository names.</param>
		// <param name="ObjectName">List of object names.</param>
		// <param name="OutputConstructionCalls">Flag indicating whether to output the object construction calls. Default value: false.</param>
		public object ListObjectDependents(object RepositoryName, object ObjectName, object OutputConstructionCalls)
		{

			Hashtable ListObjectDependents_args = new Hashtable();
			ListObjectDependents_args.Add("RepositoryName", RepositoryName);
			ListObjectDependents_args.Add("ObjectName", ObjectName);
			ListObjectDependents_args.Add("OutputConstructionCalls", OutputConstructionCalls);
			return F3Formatter.f3_style_serialization("ListObjectDependents", ListObjectDependents_args);
		}

		// <summary>
		// Return list of permitted network addresses for F3 Platform.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object ListPlatformPermittedNetworkAddresses(object DummyArgument)
		{

			Hashtable ListPlatformPermittedNetworkAddresses_args = new Hashtable();
			ListPlatformPermittedNetworkAddresses_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("ListPlatformPermittedNetworkAddresses", ListPlatformPermittedNetworkAddresses_args);
		}

		// <summary>
		// Return a list of recently-used cache identifiers.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object ListRecentValueCacheIdentifiers(object DummyArgument)
		{

			Hashtable ListRecentValueCacheIdentifiers_args = new Hashtable();
			ListRecentValueCacheIdentifiers_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("ListRecentValueCacheIdentifiers", ListRecentValueCacheIdentifiers_args);
		}

		// <summary>
		// Return a list of all repositories.
		// </summary>
		// <param name="DummyArg">Dummy argument for flow control.</param>
		public object ListRepositories(object DummyArg)
		{

			Hashtable ListRepositories_args = new Hashtable();
			ListRepositories_args.Add("DummyArg", DummyArg);
			return F3Formatter.f3_style_serialization("ListRepositories", ListRepositories_args);
		}

		// <summary>
		// List the output requests for the type stored in a given repository.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		public object ListRequests(object RepositoryName)
		{

			Hashtable ListRequests_args = new Hashtable();
			ListRequests_args.Add("RepositoryName", RepositoryName);
			return F3Formatter.f3_style_serialization("ListRequests", ListRequests_args);
		}

		// <summary>
		// Form a curve tag for a local stochastic volatility surface curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object LocalStochasticVolatilityCurveTag(object UnderlyingIndex)
		{

			Hashtable LocalStochasticVolatilityCurveTag_args = new Hashtable();
			LocalStochasticVolatilityCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("LocalStochasticVolatilityCurveTag", LocalStochasticVolatilityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a local volatility surface curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object LocalVolatilityCurveTag(object UnderlyingIndex)
		{

			Hashtable LocalVolatilityCurveTag_args = new Hashtable();
			LocalVolatilityCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("LocalVolatilityCurveTag", LocalVolatilityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a local volatility term structure curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object LocalVolatilityTermStructureCurveTag(object UnderlyingIndex)
		{

			Hashtable LocalVolatilityTermStructureCurveTag_args = new Hashtable();
			LocalVolatilityTermStructureCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("LocalVolatilityTermStructureCurveTag", LocalVolatilityTermStructureCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a long-term variance curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object LongTermVarianceCurveTag(object Index)
		{

			Hashtable LongTermVarianceCurveTag_args = new Hashtable();
			LongTermVarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("LongTermVarianceCurveTag", LongTermVarianceCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a loss distribution curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object LossDistributionCurveTag(object CreditContract)
		{

			Hashtable LossDistributionCurveTag_args = new Hashtable();
			LossDistributionCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("LossDistributionCurveTag", LossDistributionCurveTag_args);
		}

		// <summary>
		// Build a loss distribution for a pool of credits using a recursive algorithm.
		// </summary>
		// <param name="Notionals">A vector of notional amounts for each credit in the pool.</param>
		// <param name="LossGivenDefault">A vector of losses given default for each credit in the pool.</param>
		// <param name="SurvivalProbabilityFunctions">A vector of survival probability functions.</param>
		// <param name="TimePoints">A vector of time points at which to evaluate the loss distribution.</param>
		// <param name="Correlations">A vector of correlations between each credit in the pool and a common driving factor.</param>
		// <param name="LossQuantization">Size of each unit of loss.</param>
		// <param name="IntegrationMethod">Integration method used for integrating over the common driving factor.</param>
		// <param name="DoRisk">Boolean switch to turn on calculation of risk.</param>
		// <param name="SupressZeros">Boolean switch to supress loss probabilities equal to zero.</param>
		public object LossDistributionUsingRecursion(object Notionals, object LossGivenDefault, object SurvivalProbabilityFunctions, object TimePoints, object Correlations, object LossQuantization, object IntegrationMethod, object DoRisk, object SupressZeros)
		{

			Hashtable LossDistributionUsingRecursion_args = new Hashtable();
			LossDistributionUsingRecursion_args.Add("Notionals", Notionals);
			LossDistributionUsingRecursion_args.Add("LossGivenDefault", LossGivenDefault);
			LossDistributionUsingRecursion_args.Add("SurvivalProbabilityFunctions", SurvivalProbabilityFunctions);
			LossDistributionUsingRecursion_args.Add("TimePoints", TimePoints);
			LossDistributionUsingRecursion_args.Add("Correlations", Correlations);
			LossDistributionUsingRecursion_args.Add("LossQuantization", LossQuantization);
			LossDistributionUsingRecursion_args.Add("IntegrationMethod", IntegrationMethod);
			LossDistributionUsingRecursion_args.Add("DoRisk", DoRisk);
			LossDistributionUsingRecursion_args.Add("SupressZeros", SupressZeros);
			return F3Formatter.f3_style_serialization("LossDistributionUsingRecursion", LossDistributionUsingRecursion_args);
		}

		// <summary>
		// Calculate a maturity date.
		// </summary>
		// <param name="StartDate">Base date.</param>
		// <param name="Maturity">Maturity string.</param>
		// <param name="MaturityConvention">Maturity calculator.</param>
		public object MaturityDate(object StartDate, object Maturity, object MaturityConvention)
		{

			Hashtable MaturityDate_args = new Hashtable();
			MaturityDate_args.Add("StartDate", StartDate);
			MaturityDate_args.Add("Maturity", Maturity);
			MaturityDate_args.Add("MaturityConvention", MaturityConvention);
			return F3Formatter.f3_style_serialization("MaturityDate", MaturityDate_args);
		}

		// <summary>
		// Return the total number of milliseconds since January 1, 2009.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object MillisecondTime(object DummyArgument)
		{

			Hashtable MillisecondTime_args = new Hashtable();
			MillisecondTime_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("MillisecondTime", MillisecondTime_args);
		}

		// <summary>
		// List the curves that the given curve depends on directly, in the given model.
		// </summary>
		// <param name="Model">Model whose dependency tree is to be probed.</param>
		// <param name="CurveTag">Curve whose dependent curves are to be returned.</param>
		public object ModelCurveDependentCurves(object Model, object CurveTag)
		{

			Hashtable ModelCurveDependentCurves_args = new Hashtable();
			ModelCurveDependentCurves_args.Add("Model", Model);
			ModelCurveDependentCurves_args.Add("CurveTag", CurveTag);
			return F3Formatter.f3_style_serialization("ModelCurveDependentCurves", ModelCurveDependentCurves_args);
		}

		// <summary>
		// List the market data elements that the given curve depends on directly, in the given model.
		// </summary>
		// <param name="Model">Model whose dependency tree is to be probed.</param>
		// <param name="CurveTag">Curve whose dependent market data elements are to be returned.</param>
		public object ModelCurveDependentMarketData(object Model, object CurveTag)
		{

			Hashtable ModelCurveDependentMarketData_args = new Hashtable();
			ModelCurveDependentMarketData_args.Add("Model", Model);
			ModelCurveDependentMarketData_args.Add("CurveTag", CurveTag);
			return F3Formatter.f3_style_serialization("ModelCurveDependentMarketData", ModelCurveDependentMarketData_args);
		}

		// <summary>
		// Return the full dependency tree of curves starting at the given curve, in the given model.
		// </summary>
		// <param name="Model">Model whose dependency tree is to be probed.</param>
		// <param name="CurveTag">Curve marking the root of the dependency tree to be returned.</param>
		// <param name="ConciseFormat">Indicator for whether the tree is returned in a concise format. Default value: true.</param>
		public object ModelCurveTree(object Model, object CurveTag, object ConciseFormat)
		{

			Hashtable ModelCurveTree_args = new Hashtable();
			ModelCurveTree_args.Add("Model", Model);
			ModelCurveTree_args.Add("CurveTag", CurveTag);
			ModelCurveTree_args.Add("ConciseFormat", ConciseFormat);
			return F3Formatter.f3_style_serialization("ModelCurveTree", ModelCurveTree_args);
		}

		// <summary>
		// List the curves that use a specified curve in a model.
		// </summary>
		// <param name="Model">Model whose dependency tree is to be probed.</param>
		// <param name="CurveTag">Curve whose users are to be returned.</param>
		public object ModelCurveUsers(object Model, object CurveTag)
		{

			Hashtable ModelCurveUsers_args = new Hashtable();
			ModelCurveUsers_args.Add("Model", Model);
			ModelCurveUsers_args.Add("CurveTag", CurveTag);
			return F3Formatter.f3_style_serialization("ModelCurveUsers", ModelCurveUsers_args);
		}

		// <summary>
		// List the curves that use a specified piece of market data in a model.
		// </summary>
		// <param name="Model">Model whose dependency tree is to be probed.</param>
		// <param name="MarketDataTag">Market data whose users are to be returned.</param>
		public object ModelMarketDataUsers(object Model, object MarketDataTag)
		{

			Hashtable ModelMarketDataUsers_args = new Hashtable();
			ModelMarketDataUsers_args.Add("Model", Model);
			ModelMarketDataUsers_args.Add("MarketDataTag", MarketDataTag);
			return F3Formatter.f3_style_serialization("ModelMarketDataUsers", ModelMarketDataUsers_args);
		}

		// <summary>
		// Convert a time point into model time.
		// </summary>
		// <param name="Model">Model providing time calculation.</param>
		// <param name="TimePoint">Time point.</param>
		public object ModelTime(object Model, object TimePoint)
		{

			Hashtable ModelTime_args = new Hashtable();
			ModelTime_args.Add("Model", Model);
			ModelTime_args.Add("TimePoint", TimePoint);
			return F3Formatter.f3_style_serialization("ModelTime", ModelTime_args);
		}

		// <summary>
		// Move a specified number of business days.
		// </summary>
		// <param name="StartDate">Starting date to be moved.</param>
		// <param name="HolidayConventions">Holiday conventions to use.</param>
		// <param name="NumberOfDays">Number of business days.</param>
		public object MoveBusinessDays(object StartDate, object HolidayConventions, object NumberOfDays)
		{

			Hashtable MoveBusinessDays_args = new Hashtable();
			MoveBusinessDays_args.Add("StartDate", StartDate);
			MoveBusinessDays_args.Add("HolidayConventions", HolidayConventions);
			MoveBusinessDays_args.Add("NumberOfDays", NumberOfDays);
			return F3Formatter.f3_style_serialization("MoveBusinessDays", MoveBusinessDays_args);
		}

		// <summary>
		// Form a curve tag for a no-loan-cancellation curve.
		// </summary>
		// <param name="LoanOnlyCreditContract">The loan-only contract with which the curve should be associated.</param>
		public object NoLoanCancellationCurveTag(object LoanOnlyCreditContract)
		{

			Hashtable NoLoanCancellationCurveTag_args = new Hashtable();
			NoLoanCancellationCurveTag_args.Add("LoanOnlyCreditContract", LoanOnlyCreditContract);
			return F3Formatter.f3_style_serialization("NoLoanCancellationCurveTag", NoLoanCancellationCurveTag_args);
		}

		// <summary>
		// Return the unique identifier for the specified object..
		// </summary>
		// <param name="Type">Object Type.</param>
		// <param name="Name">Object Name.</param>
		// <param name="RecursionLevel">Recursion level, up to a maximum of 5. Default value: 2.</param>
		public object ObjectIdentifiers(object Type, object Name, object RecursionLevel)
		{

			Hashtable ObjectIdentifiers_args = new Hashtable();
			ObjectIdentifiers_args.Add("Type", Type);
			ObjectIdentifiers_args.Add("Name", Name);
			ObjectIdentifiers_args.Add("RecursionLevel", RecursionLevel);
			return F3Formatter.f3_style_serialization("ObjectIdentifiers", ObjectIdentifiers_args);
		}

		// <summary>
		// Return information about a repository member.
		// </summary>
		// <param name="RepositoryName">Name of the repository.</param>
		// <param name="ObjectName">Name of the object.</param>
		// <param name="Requests">Array of requests.</param>
		public object ObjectInfo(object RepositoryName, object ObjectName, object Requests)
		{

			Hashtable ObjectInfo_args = new Hashtable();
			ObjectInfo_args.Add("RepositoryName", RepositoryName);
			ObjectInfo_args.Add("ObjectName", ObjectName);
			ObjectInfo_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("ObjectInfo", ObjectInfo_args);
		}

		// <summary>
		// Calculate the Black implied volatility for a European option.
		// </summary>
		// <param name="Model">Model containing the parameterization of volatility to use for option pricing.</param>
		// <param name="Underlying">The option's underlying.</param>
		// <param name="Strike">Specification of the strike of the option.</param>
		// <param name="Expiry">The point in time at which the option expires.</param>
		// <param name="ValuationMethod">The valuation methodology for the option pricing. Default value: Default.</param>
		public object OptionImpliedVolatility(object Model, object Underlying, object Strike, object Expiry, object ValuationMethod)
		{

			Hashtable OptionImpliedVolatility_args = new Hashtable();
			OptionImpliedVolatility_args.Add("Model", Model);
			OptionImpliedVolatility_args.Add("Underlying", Underlying);
			OptionImpliedVolatility_args.Add("Strike", Strike);
			OptionImpliedVolatility_args.Add("Expiry", Expiry);
			OptionImpliedVolatility_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("OptionImpliedVolatility", OptionImpliedVolatility_args);
		}

		// <summary>
		// Form a curve tag for an overnight rate curve.
		// </summary>
		// <param name="OvernightRateIndex">Index representing overnight rate.</param>
		public object OvernightRateCurveTag(object OvernightRateIndex)
		{

			Hashtable OvernightRateCurveTag_args = new Hashtable();
			OvernightRateCurveTag_args.Add("OvernightRateIndex", OvernightRateIndex);
			return F3Formatter.f3_style_serialization("OvernightRateCurveTag", OvernightRateCurveTag_args);
		}

		// <summary>
		// Output the abstract syntax tree for parameterized curves.
		// </summary>
		// <param name="Expressions">An collection of expressions encoding the parameterization of the curves.</param>
		// <param name="TargetCurves">Tags and expressions identifying the parameterized curves.</param>
		// <param name="Parameters">Mapping between parameter names and their location in the Model. Default value: default-constructed instance of type model_parameter_identifiers.</param>
		// <param name="Functions">Mapping between function names and their location in the Model. Default value: default-constructed instance of type function_identifiers.</param>
		// <param name="FullSemantic">Flag to indicate whether full semantic analysis should be performed. Default value: false.</param>
		public object ParameterizedCurveDiagnostics(object Expressions, object TargetCurves, object Parameters, object Functions, object FullSemantic)
		{

			Hashtable ParameterizedCurveDiagnostics_args = new Hashtable();
			ParameterizedCurveDiagnostics_args.Add("Expressions", Expressions);
			ParameterizedCurveDiagnostics_args.Add("TargetCurves", TargetCurves);
			ParameterizedCurveDiagnostics_args.Add("Parameters", Parameters);
			ParameterizedCurveDiagnostics_args.Add("Functions", Functions);
			ParameterizedCurveDiagnostics_args.Add("FullSemantic", FullSemantic);
			return F3Formatter.f3_style_serialization("ParameterizedCurveDiagnostics", ParameterizedCurveDiagnostics_args);
		}

		// <summary>
		// Perform FITR parse and output the resultant tree.
		// </summary>
		// <param name="FITRSpecification">FITR specification, as a string or array of strings.</param>
		public object ParseFITR(object FITRSpecification)
		{

			Hashtable ParseFITR_args = new Hashtable();
			ParseFITR_args.Add("FITRSpecification", FITRSpecification);
			return F3Formatter.f3_style_serialization("ParseFITR", ParseFITR_args);
		}

		// <summary>
		// Parse a string describing a function of indices, and return its decomposition.
		// </summary>
		// <param name="IndexSpecificationString">Index expression.</param>
		public object ParseIndexSpecificationString(object IndexSpecificationString)
		{

			Hashtable ParseIndexSpecificationString_args = new Hashtable();
			ParseIndexSpecificationString_args.Add("IndexSpecificationString", IndexSpecificationString);
			return F3Formatter.f3_style_serialization("ParseIndexSpecificationString", ParseIndexSpecificationString_args);
		}

		// <summary>
		// Perform potential future exposure analysis on a product or a portfolio of products.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product for which PFE is to be calculated.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ScenarioGenerator">Scenario generator.</param>
		// <param name="NumberOfScenarios">Number of scenarios to use.</param>
		// <param name="Percentile">Specification for computing a percentile of the distribution.</param>
		// <param name="Histogram">Methodology for sample collection and histogram formation. Default value: AutoSize50UniformBins.</param>
		// <param name="CalculationMethod">Computational method and strategy. Default value: Default.</param>
		// <param name="Requests">Array of information requests. Default value: PeakExposure.</param>
		public object PotentialFutureExposure(object Model, object Product, object ValuationMethod, object ScenarioGenerator, object NumberOfScenarios, object Percentile, object Histogram, object CalculationMethod, object Requests)
		{

			Hashtable PotentialFutureExposure_args = new Hashtable();
			PotentialFutureExposure_args.Add("Model", Model);
			PotentialFutureExposure_args.Add("Product", Product);
			PotentialFutureExposure_args.Add("ValuationMethod", ValuationMethod);
			PotentialFutureExposure_args.Add("ScenarioGenerator", ScenarioGenerator);
			PotentialFutureExposure_args.Add("NumberOfScenarios", NumberOfScenarios);
			PotentialFutureExposure_args.Add("Percentile", Percentile);
			PotentialFutureExposure_args.Add("Histogram", Histogram);
			PotentialFutureExposure_args.Add("CalculationMethod", CalculationMethod);
			PotentialFutureExposure_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("PotentialFutureExposure", PotentialFutureExposure_args);
		}

		// <summary>
		// Form a collection of curve tags for the volatility of the given price process and index.
		// </summary>
		// <param name="PriceProcess">Specification of the stochastic process for the given index.</param>
		// <param name="Index">Simulated index.</param>
		public object PriceProcessCurveTags(object PriceProcess, object Index)
		{

			Hashtable PriceProcessCurveTags_args = new Hashtable();
			PriceProcessCurveTags_args.Add("PriceProcess", PriceProcess);
			PriceProcessCurveTags_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("PriceProcessCurveTags", PriceProcessCurveTags_args);
		}

		// <summary>
		// Determine risk for a product or portfolio of products.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		public object ProductRisk(object Model, object Product, object ValuationMethod, object SortLexically)
		{

			Hashtable ProductRisk_args = new Hashtable();
			ProductRisk_args.Add("Model", Model);
			ProductRisk_args.Add("Product", Product);
			ProductRisk_args.Add("ValuationMethod", ValuationMethod);
			ProductRisk_args.Add("SortLexically", SortLexically);
			return F3Formatter.f3_style_serialization("ProductRisk", ProductRisk_args);
		}

		// <summary>
		// Extract the date list collection that is formed by a product sequencing strategy.
		// </summary>
		// <param name="Product">Product to which the sequencing strategy is applied.</param>
		// <param name="StartTimePoint">Start time point of the range over which the sequencing strategy is applied.</param>
		// <param name="SequencingStrategy">Product sequencing strategy from which to extract the date list collection.</param>
		public object ProductSequenceDates(object Product, object StartTimePoint, object SequencingStrategy)
		{

			Hashtable ProductSequenceDates_args = new Hashtable();
			ProductSequenceDates_args.Add("Product", Product);
			ProductSequenceDates_args.Add("StartTimePoint", StartTimePoint);
			ProductSequenceDates_args.Add("SequencingStrategy", SequencingStrategy);
			return F3Formatter.f3_style_serialization("ProductSequenceDates", ProductSequenceDates_args);
		}

		// <summary>
		// Perform profit-and-loss attribution analysis on a product or a portfolio of products.
		// </summary>
		// <param name="LeftModel">Model at the beginning of the profit-and-loss attribution period.</param>
		// <param name="RightModel">Model at the end of the profit-and-loss attribution period.</param>
		// <param name="LeftProduct">Product at the beginning of the profit-and-loss attribution period.</param>
		// <param name="LeftValSpec">Valuation specification at the beginning of the profit-and-loss attribution period.</param>
		// <param name="Operations">Profit-and-loss operations to apply.</param>
		// <param name="RightProduct">Product at the end of the profit-and-loss attribution period. Default value: default-constructed instance of type product.</param>
		// <param name="RightValSpec">Valuation specification at the end of the profit-and-loss attribution period. Default value: default-constructed instance of type valuation_specification.</param>
		// <param name="PredictionStrategy">Strategy specifying if gammas are to be used in the calculation of model predicted portfolio value, and how bumping is performed. Default value: <b>T</b><d>1.0e-5</d><d>1.0e-5</d><b>T</b>.</param>
		// <param name="Requests">A list of profit-and-loss requests. Default value: DefaultReport.</param>
		// <param name="Metric">Metric specifying what type of valuation result to report. Default value: default-constructed instance of type valuation_metric.</param>
		public object ProfitAndLoss(object LeftModel, object RightModel, object LeftProduct, object LeftValSpec, object Operations, object RightProduct, object RightValSpec, object PredictionStrategy, object Requests, object Metric)
		{

			Hashtable ProfitAndLoss_args = new Hashtable();
			ProfitAndLoss_args.Add("LeftModel", LeftModel);
			ProfitAndLoss_args.Add("RightModel", RightModel);
			ProfitAndLoss_args.Add("LeftProduct", LeftProduct);
			ProfitAndLoss_args.Add("LeftValSpec", LeftValSpec);
			ProfitAndLoss_args.Add("Operations", Operations);
			ProfitAndLoss_args.Add("RightProduct", RightProduct);
			ProfitAndLoss_args.Add("RightValSpec", RightValSpec);
			ProfitAndLoss_args.Add("PredictionStrategy", PredictionStrategy);
			ProfitAndLoss_args.Add("Requests", Requests);
			ProfitAndLoss_args.Add("Metric", Metric);
			return F3Formatter.f3_style_serialization("ProfitAndLoss", ProfitAndLoss_args);
		}

		// <summary>
		// Form a curve tag for a quadratic volatility curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object QuadraticVolatilityCurveTag(object UnderlyingIndex)
		{

			Hashtable QuadraticVolatilityCurveTag_args = new Hashtable();
			QuadraticVolatilityCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("QuadraticVolatilityCurveTag", QuadraticVolatilityCurveTag_args);
		}

		// <summary>
		// Form a roll schedule given the quote date of an instrument.
		// </summary>
		// <param name="QuoteDate">Quote date of instrument.</param>
		// <param name="Maturity">Maturity string.</param>
		// <param name="MarketConvention">Market conventions to use for schedule.</param>
		public object QuoteRollSchedule(object QuoteDate, object Maturity, object MarketConvention)
		{

			Hashtable QuoteRollSchedule_args = new Hashtable();
			QuoteRollSchedule_args.Add("QuoteDate", QuoteDate);
			QuoteRollSchedule_args.Add("Maturity", Maturity);
			QuoteRollSchedule_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("QuoteRollSchedule", QuoteRollSchedule_args);
		}

		// <summary>
		// Form a curve tag for a recovery rate curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object RecoveryRateCurveTag(object CreditContract)
		{

			Hashtable RecoveryRateCurveTag_args = new Hashtable();
			RecoveryRateCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("RecoveryRateCurveTag", RecoveryRateCurveTag_args);
		}

		// <summary>
		// Form a curve tag for the individual factor loading curve in reduced-factor hybrid Monte Carlo simulations.
		// </summary>
		// <param name="NamedStateVariableTemplate">Index and the corresponding mathematical model.</param>
		// <param name="Factor">Factor loading component.</param>
		public object ReducedFactorModelingCurveTag(object NamedStateVariableTemplate, object Factor)
		{

			Hashtable ReducedFactorModelingCurveTag_args = new Hashtable();
			ReducedFactorModelingCurveTag_args.Add("NamedStateVariableTemplate", NamedStateVariableTemplate);
			ReducedFactorModelingCurveTag_args.Add("Factor", Factor);
			return F3Formatter.f3_style_serialization("ReducedFactorModelingCurveTag", ReducedFactorModelingCurveTag_args);
		}

		// <summary>
		// Return information from a referenced index.
		// </summary>
		// <param name="Index">Index.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <param name="Requests">Array of requests.</param>
		// <param name="EvaluationPoint">Index evaluation point for expression processing. Default value: default-constructed instance of type evaluation_point.</param>
		public object ReferencedIndexInfo(object Index, object RefSpec, object Requests, object EvaluationPoint)
		{

			Hashtable ReferencedIndexInfo_args = new Hashtable();
			ReferencedIndexInfo_args.Add("Index", Index);
			ReferencedIndexInfo_args.Add("RefSpec", RefSpec);
			ReferencedIndexInfo_args.Add("Requests", Requests);
			ReferencedIndexInfo_args.Add("EvaluationPoint", EvaluationPoint);
			return F3Formatter.f3_style_serialization("ReferencedIndexInfo", ReferencedIndexInfo_args);
		}

		// <summary>
		// Register an external location for function execution.
		// </summary>
		// <param name="ExternalExecutor">Connection to external location. Default value: default-constructed instance of type bound_outbound_socket.</param>
		public object RegisterExternalExecutor(object ExternalExecutor)
		{

			Hashtable RegisterExternalExecutor_args = new Hashtable();
			RegisterExternalExecutor_args.Add("ExternalExecutor", ExternalExecutor);
			return F3Formatter.f3_style_serialization("RegisterExternalExecutor", RegisterExternalExecutor_args);
		}

		// <summary>
		// Register a processor for managing cached values.
		// </summary>
		// <param name="CacheProcessor">Processor to set as cache handler for function values.</param>
		public object RegisterFunctionValueCacheProcessor(object CacheProcessor)
		{

			Hashtable RegisterFunctionValueCacheProcessor_args = new Hashtable();
			RegisterFunctionValueCacheProcessor_args.Add("CacheProcessor", CacheProcessor);
			return F3Formatter.f3_style_serialization("RegisterFunctionValueCacheProcessor", RegisterFunctionValueCacheProcessor_args);
		}

		// <summary>
		// Register an HTTP server with a name server.
		// </summary>
		// <param name="HTTPServer">An HTTP server.</param>
		// <param name="SuggestedName">The suggested name for an F3 instance.</param>
		// <param name="ServerAddress">Address of the name server.</param>
		public object RegisterWithNameServer(object HTTPServer, object SuggestedName, object ServerAddress)
		{

			Hashtable RegisterWithNameServer_args = new Hashtable();
			RegisterWithNameServer_args.Add("HTTPServer", HTTPServer);
			RegisterWithNameServer_args.Add("SuggestedName", SuggestedName);
			RegisterWithNameServer_args.Add("ServerAddress", ServerAddress);
			return F3Formatter.f3_style_serialization("RegisterWithNameServer", RegisterWithNameServer_args);
		}

		// <summary>
		// Relicense this library instance using supplied F3 Platform licensing information.
		// </summary>
		// <param name="LicenceInformation">Licensing information token.</param>
		// <param name="VersionNumber">Licensing version number.</param>
		public object RelicencePlatform(object LicenceInformation, object VersionNumber)
		{

			Hashtable RelicencePlatform_args = new Hashtable();
			RelicencePlatform_args.Add("LicenceInformation", LicenceInformation);
			RelicencePlatform_args.Add("VersionNumber", VersionNumber);
			return F3Formatter.f3_style_serialization("RelicencePlatform", RelicencePlatform_args);
		}

		// <summary>
		// Reloads the license for this library instance using supplied licensing information.
		// </summary>
		// <param name="LicenceInformation">Licensing information token.</param>
		// <param name="VersionNumber">Licensing version number.</param>
		public object ReloadLicence(object LicenceInformation, object VersionNumber)
		{

			Hashtable ReloadLicence_args = new Hashtable();
			ReloadLicence_args.Add("LicenceInformation", LicenceInformation);
			ReloadLicence_args.Add("VersionNumber", VersionNumber);
			return F3Formatter.f3_style_serialization("ReloadLicence", ReloadLicence_args);
		}

		// <summary>
		// Run commands from a function log file.
		// </summary>
		// <param name="InputSource">Input file, or other stream-based resource.</param>
		// <param name="ExcludedFunctions">The set of functions that will be suppressed when encountered in the input stream. Default value: <s>InvokeCallback</s><s>SetCallLoggingTarget</s><s>SetResultLoggingTarget</s><s>CreateTCPSocket</s><s>CreateZMQSocket</s><s>CreateOutboundTCPConnection</s><s>CreateOutboundZMQConnection</s><s>CreateHTTPServer</s><s>CreateNameServiceRegistration</s><s>CreateNameServer</s><s>CreateServerConnection</s><s>BrowseServer</s>.</param>
		// <param name="OutputTarget">Output file, or other stream-based resource, for function result logging.</param>
		// <param name="OptionalSigningKey">Key string for unlocking signed input streams. Default value: default-constructed instance of type password.</param>
		public object ReplayLog(object InputSource, object ExcludedFunctions, object OutputTarget, object OptionalSigningKey)
		{

			Hashtable ReplayLog_args = new Hashtable();
			ReplayLog_args.Add("InputSource", InputSource);
			ReplayLog_args.Add("ExcludedFunctions", ExcludedFunctions);
			ReplayLog_args.Add("OutputTarget", OutputTarget);
			ReplayLog_args.Add("OptionalSigningKey", OptionalSigningKey);
			return F3Formatter.f3_style_serialization("ReplayLog", ReplayLog_args);
		}

		// <summary>
		// Determine a set of option replicating weights for the defined payoff function.
		// </summary>
		// <param name="ReplicationStrategy">Replication strategy methodology.</param>
		// <param name="PayoffFunction">Payoff function.</param>
		// <param name="NumeraireWeightingFunction">Numeraire function of the underlying.</param>
		// <param name="LowerCutoff">Lower replication cutoff. Default value: 0.0.</param>
		// <param name="UpperCutoff">Upper replication cutoff.</param>
		// <param name="CutoverPoint">Cutover point from puts to calls.</param>
		// <param name="TreateCutoverAsForward">Boolean flag for risk calculations to indicate if the CutoverPoint is assumed as the forward. Default value: false.</param>
		// <param name="Forward">Forward value for determining strike bounds. Default value: 0.0.</param>
		public object ReplicatingWeights(object ReplicationStrategy, object PayoffFunction, object NumeraireWeightingFunction, object LowerCutoff, object UpperCutoff, object CutoverPoint, object TreateCutoverAsForward, object Forward)
		{

			Hashtable ReplicatingWeights_args = new Hashtable();
			ReplicatingWeights_args.Add("ReplicationStrategy", ReplicationStrategy);
			ReplicatingWeights_args.Add("PayoffFunction", PayoffFunction);
			ReplicatingWeights_args.Add("NumeraireWeightingFunction", NumeraireWeightingFunction);
			ReplicatingWeights_args.Add("LowerCutoff", LowerCutoff);
			ReplicatingWeights_args.Add("UpperCutoff", UpperCutoff);
			ReplicatingWeights_args.Add("CutoverPoint", CutoverPoint);
			ReplicatingWeights_args.Add("TreateCutoverAsForward", TreateCutoverAsForward);
			ReplicatingWeights_args.Add("Forward", Forward);
			return F3Formatter.f3_style_serialization("ReplicatingWeights", ReplicatingWeights_args);
		}

		// <summary>
		// Searches all repositories and their members for matches to the given search expression.
		// </summary>
		// <param name="Repositories">Array of names for the repositories to search.</param>
		// <param name="SearchExpression">The expression to search the repositories for.</param>
		public object RepositorySearch(object Repositories, object SearchExpression)
		{

			Hashtable RepositorySearch_args = new Hashtable();
			RepositorySearch_args.Add("Repositories", Repositories);
			RepositorySearch_args.Add("SearchExpression", SearchExpression);
			return F3Formatter.f3_style_serialization("RepositorySearch", RepositorySearch_args);
		}

		// <summary>
		// Reset current call usage and timing statistics.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object ResetCallStatistics(object DummyArgument)
		{

			Hashtable ResetCallStatistics_args = new Hashtable();
			ResetCallStatistics_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("ResetCallStatistics", ResetCallStatistics_args);
		}

		// <summary>
		// Form a curve tag for a risk reversal strategy quote curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object RiskReversalCurveTag(object UnderlyingIndex)
		{

			Hashtable RiskReversalCurveTag_args = new Hashtable();
			RiskReversalCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("RiskReversalCurveTag", RiskReversalCurveTag_args);
		}

		// <summary>
		// Form a roll schedule.
		// </summary>
		// <param name="StartDate">Base date.</param>
		// <param name="Maturity">Maturity string.</param>
		// <param name="MarketConvention">Market conventions to use for schedule.</param>
		public object RollSchedule(object StartDate, object Maturity, object MarketConvention)
		{

			Hashtable RollSchedule_args = new Hashtable();
			RollSchedule_args.Add("StartDate", StartDate);
			RollSchedule_args.Add("Maturity", Maturity);
			RollSchedule_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("RollSchedule", RollSchedule_args);
		}

		// <summary>
		// Run a backward evolution calculation.
		// </summary>
		// <param name="TreeElement">The resulting node in the evolution tree.</param>
		// <param name="CalculationDetails">Details specifying the evolution calculation.</param>
		// <param name="Requests">Array of information requests.</param>
		public object RunEvolution(object TreeElement, object CalculationDetails, object Requests)
		{

			Hashtable RunEvolution_args = new Hashtable();
			RunEvolution_args.Add("TreeElement", TreeElement);
			RunEvolution_args.Add("CalculationDetails", CalculationDetails);
			RunEvolution_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("RunEvolution", RunEvolution_args);
		}

		// <summary>
		// Run a numeric simulation.
		// </summary>
		// <param name="GeneratorName">Generator to use.</param>
		// <param name="Iterations">Number of iterations. Default value: 1023.</param>
		// <param name="Size">Number of required dimensions.</param>
		// <param name="AddRisk">Generate risk exposures in addition to expectations. Default value: false.</param>
		// <param name="AccumulatorType">Type of accumulator to use.</param>
		// <param name="CalculationMethod">Computational calculation method and strategy.</param>
		// <param name="SortRiskLexically">Indicator for whether or not to order the risk output lexically. Default value: true.</param>
		public object RunGeneration(object GeneratorName, object Iterations, object Size, object AddRisk, object AccumulatorType, object CalculationMethod, object SortRiskLexically)
		{

			Hashtable RunGeneration_args = new Hashtable();
			RunGeneration_args.Add("GeneratorName", GeneratorName);
			RunGeneration_args.Add("Iterations", Iterations);
			RunGeneration_args.Add("Size", Size);
			RunGeneration_args.Add("AddRisk", AddRisk);
			RunGeneration_args.Add("AccumulatorType", AccumulatorType);
			RunGeneration_args.Add("CalculationMethod", CalculationMethod);
			RunGeneration_args.Add("SortRiskLexically", SortRiskLexically);
			return F3Formatter.f3_style_serialization("RunGeneration", RunGeneration_args);
		}

		// <summary>
		// Calculate an accrual fraction for a roll schedule.
		// </summary>
		// <param name="RollSchedule">Roll schedule.</param>
		// <param name="SettlementDetails">Settlement details.</param>
		// <param name="AccrualConvention">Accrual convention to use.</param>
		// <param name="SettlementConvention">Convention for expanding settlement details. Default value: CashCash.</param>
		public object ScheduleAccrualFraction(object RollSchedule, object SettlementDetails, object AccrualConvention, object SettlementConvention)
		{

			Hashtable ScheduleAccrualFraction_args = new Hashtable();
			ScheduleAccrualFraction_args.Add("RollSchedule", RollSchedule);
			ScheduleAccrualFraction_args.Add("SettlementDetails", SettlementDetails);
			ScheduleAccrualFraction_args.Add("AccrualConvention", AccrualConvention);
			ScheduleAccrualFraction_args.Add("SettlementConvention", SettlementConvention);
			return F3Formatter.f3_style_serialization("ScheduleAccrualFraction", ScheduleAccrualFraction_args);
		}

		// <summary>
		// Set function call logging target.
		// </summary>
		// <param name="CallTarget">Output file, or other stream-based resource, for function call logging.</param>
		public object SetCallLoggingTarget(object CallTarget)
		{

			Hashtable SetCallLoggingTarget_args = new Hashtable();
			SetCallLoggingTarget_args.Add("CallTarget", CallTarget);
			return F3Formatter.f3_style_serialization("SetCallLoggingTarget", SetCallLoggingTarget_args);
		}

		// <summary>
		// Store a cached value.
		// </summary>
		// <param name="CacheIdentifier">Name to use for callback.</param>
		// <param name="Value">Cached value to store.</param>
		public object SetFunctionValueCacheEntry(object CacheIdentifier, object Value)
		{

			Hashtable SetFunctionValueCacheEntry_args = new Hashtable();
			SetFunctionValueCacheEntry_args.Add("CacheIdentifier", CacheIdentifier);
			SetFunctionValueCacheEntry_args.Add("Value", Value);
			return F3Formatter.f3_style_serialization("SetFunctionValueCacheEntry", SetFunctionValueCacheEntry_args);
		}

		// <summary>
		// Set function result logging targets.
		// </summary>
		// <param name="ResultTarget">Output file, or other stream-based resource, for function result logging.</param>
		public object SetResultLoggingTarget(object ResultTarget)
		{

			Hashtable SetResultLoggingTarget_args = new Hashtable();
			SetResultLoggingTarget_args.Add("ResultTarget", ResultTarget);
			return F3Formatter.f3_style_serialization("SetResultLoggingTarget", SetResultLoggingTarget_args);
		}

		// <summary>
		// Calculate a start and end date for a short-term cash deposit.
		// </summary>
		// <param name="TradeDate">Date on which a cash deposit is quoted.</param>
		// <param name="SpotDate">Spot date for a cash deposit.</param>
		// <param name="Maturity">Cash deposit maturity descriptor, such as o/n, t/n and s/w.</param>
		// <param name="MarketConventions">Rule for determining valid business days.</param>
		public object ShortTermCashDates(object TradeDate, object SpotDate, object Maturity, object MarketConventions)
		{

			Hashtable ShortTermCashDates_args = new Hashtable();
			ShortTermCashDates_args.Add("TradeDate", TradeDate);
			ShortTermCashDates_args.Add("SpotDate", SpotDate);
			ShortTermCashDates_args.Add("Maturity", Maturity);
			ShortTermCashDates_args.Add("MarketConventions", MarketConventions);
			return F3Formatter.f3_style_serialization("ShortTermCashDates", ShortTermCashDates_args);
		}

		// <summary>
		// Stack two or more values together horizontally.
		// </summary>
		// <param name="Argument1">Array 1 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument2">Array 2 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument3">Array 3 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument4">Array 4 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument5">Array 5 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument6">Array 6 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument7">Array 7 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument8">Array 8 to be stacked. Default value: default-constructed instance of type object.</param>
		// <param name="Argument9">Array 9 to be stacked. Default value: default-constructed instance of type object.</param>
		public object SideBySideStack(object Argument1, object Argument2, object Argument3, object Argument4, object Argument5, object Argument6, object Argument7, object Argument8, object Argument9)
		{

			Hashtable SideBySideStack_args = new Hashtable();
			SideBySideStack_args.Add("Argument1", Argument1);
			SideBySideStack_args.Add("Argument2", Argument2);
			SideBySideStack_args.Add("Argument3", Argument3);
			SideBySideStack_args.Add("Argument4", Argument4);
			SideBySideStack_args.Add("Argument5", Argument5);
			SideBySideStack_args.Add("Argument6", Argument6);
			SideBySideStack_args.Add("Argument7", Argument7);
			SideBySideStack_args.Add("Argument8", Argument8);
			SideBySideStack_args.Add("Argument9", Argument9);
			return F3Formatter.f3_style_serialization("SideBySideStack", SideBySideStack_args);
		}

		// <summary>
		// Form a curve tag for a volatility curve in a numerical simulation.
		// </summary>
		// <param name="Index">Simulated index.</param>
		public object SimulationVolatilityCurveTag(object Index)
		{

			Hashtable SimulationVolatilityCurveTag_args = new Hashtable();
			SimulationVolatilityCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("SimulationVolatilityCurveTag", SimulationVolatilityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a volatility exponent curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object SimulationVolatilityExponentCurveTag(object Index)
		{

			Hashtable SimulationVolatilityExponentCurveTag_args = new Hashtable();
			SimulationVolatilityExponentCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("SimulationVolatilityExponentCurveTag", SimulationVolatilityExponentCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a volatility offset curve in a numerical simulation.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object SimulationVolatilityOffsetCurveTag(object Index)
		{

			Hashtable SimulationVolatilityOffsetCurveTag_args = new Hashtable();
			SimulationVolatilityOffsetCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("SimulationVolatilityOffsetCurveTag", SimulationVolatilityOffsetCurveTag_args);
		}

		// <summary>
		// Return the list of files that are used to add data to repositories at start-up.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object StaticDataFiles(object DummyArgument)
		{

			Hashtable StaticDataFiles_args = new Hashtable();
			StaticDataFiles_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("StaticDataFiles", StaticDataFiles_args);
		}

		// <summary>
		// Form a curve tag for a straddle strategy quote curve.
		// </summary>
		// <param name="UnderlyingIndex">Underlying index that is being modeled.</param>
		public object StraddleCurveTag(object UnderlyingIndex)
		{

			Hashtable StraddleCurveTag_args = new Hashtable();
			StraddleCurveTag_args.Add("UnderlyingIndex", UnderlyingIndex);
			return F3Formatter.f3_style_serialization("StraddleCurveTag", StraddleCurveTag_args);
		}

		// <summary>
		// Return a subset of an input argument.
		// </summary>
		// <param name="InputRange">Input range.</param>
		// <param name="StartRow">Starting row number, with 1 the top-most row. Default value: 1.</param>
		// <param name="StartColumn">Starting column number, with 1 the left-most column. Default value: 1.</param>
		// <param name="NumberOfRows">Number of rows to use, or 0 for all rows. Default value: 0.</param>
		// <param name="NumberOfColumns">Number of columns to use, or 0 for all columns. Default value: 0.</param>
		public object SubArray(object InputRange, object StartRow, object StartColumn, object NumberOfRows, object NumberOfColumns)
		{

			Hashtable SubArray_args = new Hashtable();
			SubArray_args.Add("InputRange", InputRange);
			SubArray_args.Add("StartRow", StartRow);
			SubArray_args.Add("StartColumn", StartColumn);
			SubArray_args.Add("NumberOfRows", NumberOfRows);
			SubArray_args.Add("NumberOfColumns", NumberOfColumns);
			return F3Formatter.f3_style_serialization("SubArray", SubArray_args);
		}

		// <summary>
		// Form a curve tag for a credit survival curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		// <param name="ValuationMethod">The valuation method used. Default value: DefaultClosedForm.</param>
		public object SurvivalCurveTag(object CreditContract, object ValuationMethod)
		{

			Hashtable SurvivalCurveTag_args = new Hashtable();
			SurvivalCurveTag_args.Add("CreditContract", CreditContract);
			SurvivalCurveTag_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("SurvivalCurveTag", SurvivalCurveTag_args);
		}

		// <summary>
		// Calculate the par rate of a swap.
		// </summary>
		// <param name="Model">Model providing the curves used by the par swap rate calculation.</param>
		// <param name="StartDate">Date on which interest begins to accrue in the swap.</param>
		// <param name="Maturity">Maturity of the swap.</param>
		// <param name="FixedLegConventions">Market conventions for generating the fixed leg schedule.</param>
		// <param name="FloatingRateIndex">Index representing the rate paid on the floating leg.</param>
		// <param name="FloatingLegConventions">Market conventions for generating the fixed leg schedule.</param>
		// <param name="DoRisk">Flag indicating whether to calculate the risk exposure of the par swap rate. Default value: false.</param>
		// <param name="ValuationMethod">Valuation methodology for the swap rate calculation. Default value: Default.</param>
		// <param name="CollateralAgreement">Agreement by which the swap is collateralized. Default value: ZeroCollateral.</param>
		public object SwapRate(object Model, object StartDate, object Maturity, object FixedLegConventions, object FloatingRateIndex, object FloatingLegConventions, object DoRisk, object ValuationMethod, object CollateralAgreement)
		{

			Hashtable SwapRate_args = new Hashtable();
			SwapRate_args.Add("Model", Model);
			SwapRate_args.Add("StartDate", StartDate);
			SwapRate_args.Add("Maturity", Maturity);
			SwapRate_args.Add("FixedLegConventions", FixedLegConventions);
			SwapRate_args.Add("FloatingRateIndex", FloatingRateIndex);
			SwapRate_args.Add("FloatingLegConventions", FloatingLegConventions);
			SwapRate_args.Add("DoRisk", DoRisk);
			SwapRate_args.Add("ValuationMethod", ValuationMethod);
			SwapRate_args.Add("CollateralAgreement", CollateralAgreement);
			return F3Formatter.f3_style_serialization("SwapRate", SwapRate_args);
		}

		// <summary>
		// Calculate the Black implied volatility for a European swaption.
		// </summary>
		// <param name="Model">Model containing the parameterization of volatility to use for swaption pricing.</param>
		// <param name="SwapMaturity">Maturity of the underlying swap.</param>
		// <param name="FixedLegConventions">Market conventions for generating the underlying swap's fixed leg schedule.</param>
		// <param name="FloatingRateIndex">Index representing the rate paid on the underlying swap's floating leg.</param>
		// <param name="FloatingLegConventions">Market conventions for generating the underlying swap's fixed leg schedule.</param>
		// <param name="Strike">Specification of the strike of the swaption.</param>
		// <param name="Expiry">The point in time at which the swaption expires.</param>
		// <param name="ValuationMethod">The valuation methodology for the swaption pricing. Default value: Default.</param>
		public object SwaptionImpliedVolatility(object Model, object SwapMaturity, object FixedLegConventions, object FloatingRateIndex, object FloatingLegConventions, object Strike, object Expiry, object ValuationMethod)
		{

			Hashtable SwaptionImpliedVolatility_args = new Hashtable();
			SwaptionImpliedVolatility_args.Add("Model", Model);
			SwaptionImpliedVolatility_args.Add("SwapMaturity", SwapMaturity);
			SwaptionImpliedVolatility_args.Add("FixedLegConventions", FixedLegConventions);
			SwaptionImpliedVolatility_args.Add("FloatingRateIndex", FloatingRateIndex);
			SwaptionImpliedVolatility_args.Add("FloatingLegConventions", FloatingLegConventions);
			SwaptionImpliedVolatility_args.Add("Strike", Strike);
			SwaptionImpliedVolatility_args.Add("Expiry", Expiry);
			SwaptionImpliedVolatility_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("SwaptionImpliedVolatility", SwaptionImpliedVolatility_args);
		}

		// <summary>
		// Compare the results of the library's clean single currency forward value risk calculation with a bump and grind approach.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ForwardBump">Amount by which to bump forward. Default value: 1e-5.</param>
		// <param name="BackwardBump">Amount by which to bump backward. Default value: 0.0.</param>
		// <param name="BumpsAreRelative">Flag indicating whether the given bump values are relative or absolute. Default value: true.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		// <param name="ExpectedAccrued">Flag indicating whether to calculate expected accrued interest, or accrued. Default value: false.</param>
		public object TestCleanSingleCurrencyForwardValueRiskByBumping(object Model, object Product, object ValuationMethod, object ForwardBump, object BackwardBump, object BumpsAreRelative, object SortLexically, object ExpectedAccrued)
		{

			Hashtable TestCleanSingleCurrencyForwardValueRiskByBumping_args = new Hashtable();
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("Model", Model);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("Product", Product);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("ValuationMethod", ValuationMethod);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("ForwardBump", ForwardBump);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("BackwardBump", BackwardBump);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("BumpsAreRelative", BumpsAreRelative);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("SortLexically", SortLexically);
			TestCleanSingleCurrencyForwardValueRiskByBumping_args.Add("ExpectedAccrued", ExpectedAccrued);
			return F3Formatter.f3_style_serialization("TestCleanSingleCurrencyForwardValueRiskByBumping", TestCleanSingleCurrencyForwardValueRiskByBumping_args);
		}

		// <summary>
		// Compare the results of the library's clean single currency value risk calculation with a bump and grind approach.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ForwardBump">Amount by which to bump forward. Default value: 1e-5.</param>
		// <param name="BackwardBump">Amount by which to bump backward. Default value: 0.0.</param>
		// <param name="BumpsAreRelative">Flag indicating whether the given bump values are relative or absolute. Default value: true.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		// <param name="ExpectedAccrued">Flag indicating whether to calculate expected accrued interest, or accrued. Default value: false.</param>
		public object TestCleanSingleCurrencyValueRiskByBumping(object Model, object Product, object ValuationMethod, object ForwardBump, object BackwardBump, object BumpsAreRelative, object SortLexically, object ExpectedAccrued)
		{

			Hashtable TestCleanSingleCurrencyValueRiskByBumping_args = new Hashtable();
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("Model", Model);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("Product", Product);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("ValuationMethod", ValuationMethod);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("ForwardBump", ForwardBump);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("BackwardBump", BackwardBump);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("BumpsAreRelative", BumpsAreRelative);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("SortLexically", SortLexically);
			TestCleanSingleCurrencyValueRiskByBumping_args.Add("ExpectedAccrued", ExpectedAccrued);
			return F3Formatter.f3_style_serialization("TestCleanSingleCurrencyValueRiskByBumping", TestCleanSingleCurrencyValueRiskByBumping_args);
		}

		// <summary>
		// Compare the results of the library's forward date risk calculation with a bump and grind approach.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ForwardBump">Amount by which to bump forward. Default value: 1e-5.</param>
		// <param name="BackwardBump">Amount by which to bump backward. Default value: 0.0.</param>
		// <param name="BumpsAreRelative">Flag indicating whether the given bump values are relative or absolute. Default value: true.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		public object TestForwardDateRiskByBumping(object Model, object Product, object ValuationMethod, object ForwardBump, object BackwardBump, object BumpsAreRelative, object SortLexically)
		{

			Hashtable TestForwardDateRiskByBumping_args = new Hashtable();
			TestForwardDateRiskByBumping_args.Add("Model", Model);
			TestForwardDateRiskByBumping_args.Add("Product", Product);
			TestForwardDateRiskByBumping_args.Add("ValuationMethod", ValuationMethod);
			TestForwardDateRiskByBumping_args.Add("ForwardBump", ForwardBump);
			TestForwardDateRiskByBumping_args.Add("BackwardBump", BackwardBump);
			TestForwardDateRiskByBumping_args.Add("BumpsAreRelative", BumpsAreRelative);
			TestForwardDateRiskByBumping_args.Add("SortLexically", SortLexically);
			return F3Formatter.f3_style_serialization("TestForwardDateRiskByBumping", TestForwardDateRiskByBumping_args);
		}

		// <summary>
		// Compare the results of the library's risk calculation with a bump and grind approach.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Index">Product to value.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ForwardBump">Amount by which to bump forward. Default value: 1e-5.</param>
		// <param name="BackwardBump">Amount by which to bump backward. Default value: 0.0.</param>
		// <param name="BumpsAreRelative">Flag indicating whether the given bump values are relative or absolute. Default value: true.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		// <param name="EvaluationPoint">Index evaluation point for expression processing. Default value: default-constructed instance of type evaluation_point.</param>
		public object TestIndexRiskByBumping(object Model, object Index, object RefSpec, object ValuationMethod, object ForwardBump, object BackwardBump, object BumpsAreRelative, object SortLexically, object EvaluationPoint)
		{

			Hashtable TestIndexRiskByBumping_args = new Hashtable();
			TestIndexRiskByBumping_args.Add("Model", Model);
			TestIndexRiskByBumping_args.Add("Index", Index);
			TestIndexRiskByBumping_args.Add("RefSpec", RefSpec);
			TestIndexRiskByBumping_args.Add("ValuationMethod", ValuationMethod);
			TestIndexRiskByBumping_args.Add("ForwardBump", ForwardBump);
			TestIndexRiskByBumping_args.Add("BackwardBump", BackwardBump);
			TestIndexRiskByBumping_args.Add("BumpsAreRelative", BumpsAreRelative);
			TestIndexRiskByBumping_args.Add("SortLexically", SortLexically);
			TestIndexRiskByBumping_args.Add("EvaluationPoint", EvaluationPoint);
			return F3Formatter.f3_style_serialization("TestIndexRiskByBumping", TestIndexRiskByBumping_args);
		}

		// <summary>
		// Compare the results of the library's risk calculation with a bump and grind approach.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ForwardBump">Amount by which to bump forward. Default value: 1e-5.</param>
		// <param name="BackwardBump">Amount by which to bump backward. Default value: 0.0.</param>
		// <param name="BumpsAreRelative">Flag indicating whether the given bump values are relative or absolute. Default value: true.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		public object TestProductRiskByBumping(object Model, object Product, object ValuationMethod, object ForwardBump, object BackwardBump, object BumpsAreRelative, object SortLexically)
		{

			Hashtable TestProductRiskByBumping_args = new Hashtable();
			TestProductRiskByBumping_args.Add("Model", Model);
			TestProductRiskByBumping_args.Add("Product", Product);
			TestProductRiskByBumping_args.Add("ValuationMethod", ValuationMethod);
			TestProductRiskByBumping_args.Add("ForwardBump", ForwardBump);
			TestProductRiskByBumping_args.Add("BackwardBump", BackwardBump);
			TestProductRiskByBumping_args.Add("BumpsAreRelative", BumpsAreRelative);
			TestProductRiskByBumping_args.Add("SortLexically", SortLexically);
			return F3Formatter.f3_style_serialization("TestProductRiskByBumping", TestProductRiskByBumping_args);
		}

		// <summary>
		// Call another function by name, using supplied named argument values, and append the calculation time to its return value.
		// </summary>
		// <param name="FunctionName">Name of function to call.</param>
		// <param name="NamedArguments">Named arguments for function call.</param>
		// <param name="AllowFunctionOutput">If false, the valuation results are suppressed and only timing is output. Default value: false.</param>
		public object TimeFunction(object FunctionName, object NamedArguments, object AllowFunctionOutput)
		{

			Hashtable TimeFunction_args = new Hashtable();
			TimeFunction_args.Add("FunctionName", FunctionName);
			TimeFunction_args.Add("NamedArguments", NamedArguments);
			TimeFunction_args.Add("AllowFunctionOutput", AllowFunctionOutput);
			return F3Formatter.f3_style_serialization("TimeFunction", TimeFunction_args);
		}

		// <summary>
		// Calculate a start date from a trade date.
		// </summary>
		// <param name="TradeDate">Base date.</param>
		// <param name="MarketConvention">Market conventions describing trade to start date relationship.</param>
		public object TradeDateToStartDate(object TradeDate, object MarketConvention)
		{

			Hashtable TradeDateToStartDate_args = new Hashtable();
			TradeDateToStartDate_args.Add("TradeDate", TradeDate);
			TradeDateToStartDate_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("TradeDateToStartDate", TradeDateToStartDate_args);
		}

		// <summary>
		// Calculate trade dates that bound a start date.
		// </summary>
		// <param name="StartDate">Base date.</param>
		// <param name="MarketConvention">Market conventions describing trade to start date relationship.</param>
		public object TradeDatesBoundingStartDate(object StartDate, object MarketConvention)
		{

			Hashtable TradeDatesBoundingStartDate_args = new Hashtable();
			TradeDatesBoundingStartDate_args.Add("StartDate", StartDate);
			TradeDatesBoundingStartDate_args.Add("MarketConvention", MarketConvention);
			return F3Formatter.f3_style_serialization("TradeDatesBoundingStartDate", TradeDatesBoundingStartDate_args);
		}

		// <summary>
		// Form a curve tag for a tranche accrual curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object TrancheAccrualCurveTag(object CreditContract)
		{

			Hashtable TrancheAccrualCurveTag_args = new Hashtable();
			TrancheAccrualCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("TrancheAccrualCurveTag", TrancheAccrualCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a tranche default curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object TrancheDefaultCurveTag(object CreditContract)
		{

			Hashtable TrancheDefaultCurveTag_args = new Hashtable();
			TrancheDefaultCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("TrancheDefaultCurveTag", TrancheDefaultCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a tranche pool curve.
		// </summary>
		// <param name="CreditContract">The contract with which the curve should be associated.</param>
		public object TranchePoolCurveTag(object CreditContract)
		{

			Hashtable TranchePoolCurveTag_args = new Hashtable();
			TranchePoolCurveTag_args.Add("CreditContract", CreditContract);
			return F3Formatter.f3_style_serialization("TranchePoolCurveTag", TranchePoolCurveTag_args);
		}

		// <summary>
		// Return a unique identifier for this context.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object UniqueContextIdentifier(object DummyArgument)
		{

			Hashtable UniqueContextIdentifier_args = new Hashtable();
			UniqueContextIdentifier_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("UniqueContextIdentifier", UniqueContextIdentifier_args);
		}

		// <summary>
		// Return a name for a new object in this context.
		// </summary>
		// <param name="DummyArgument">Dummy argument for flow control.</param>
		public object UniqueObjectName(object DummyArgument)
		{

			Hashtable UniqueObjectName_args = new Hashtable();
			UniqueObjectName_args.Add("DummyArgument", DummyArgument);
			return F3Formatter.f3_style_serialization("UniqueObjectName", UniqueObjectName_args);
		}

		// <summary>
		// Unregister an HTTP server with a name server.
		// </summary>
		// <param name="HTTPServer">An HTTP server.</param>
		// <param name="ServerAddress">Address of the name server.</param>
		public object UnregisterWithNameServer(object HTTPServer, object ServerAddress)
		{

			Hashtable UnregisterWithNameServer_args = new Hashtable();
			UnregisterWithNameServer_args.Add("HTTPServer", HTTPServer);
			UnregisterWithNameServer_args.Add("ServerAddress", ServerAddress);
			return F3Formatter.f3_style_serialization("UnregisterWithNameServer", UnregisterWithNameServer_args);
		}

		// <summary>
		// Update the calibration strategy in an existing model.
		// </summary>
		// <param name="ModelName">Name to use for the updated model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="CurveTag">Underlying curves.</param>
		// <param name="InstrumentStrategy">New instrument strategy for the curve.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object UpdateCalibrationStrategy(object ModelName, object BaseModel, object CurveTag, object InstrumentStrategy)
		{

			Hashtable UpdateCalibrationStrategy_args = new Hashtable();
			UpdateCalibrationStrategy_args.Add("ModelName", ModelName);
			UpdateCalibrationStrategy_args.Add("BaseModel", BaseModel);
			UpdateCalibrationStrategy_args.Add("CurveTag", CurveTag);
			UpdateCalibrationStrategy_args.Add("InstrumentStrategy", InstrumentStrategy);
			return F3Formatter.f3_style_serialization("UpdateCalibrationStrategy", UpdateCalibrationStrategy_args);
		}

		// <summary>
		// Update an existing model.
		// </summary>
		// <param name="ModelName">Name to use for the updated model.</param>
		// <param name="BaseModel">Underlying model.</param>
		// <param name="MarketData">Market data to add.</param>
		// <param name="ValuationDate">New valuation date of the model. Default value: default-constructed instance of type date.</param>
		// <returns>Retuns the name of the constructed object of type Model.</returns>
		public object UpdateModel(object ModelName, object BaseModel, object MarketData, object ValuationDate)
		{

			Hashtable UpdateModel_args = new Hashtable();
			UpdateModel_args.Add("ModelName", ModelName);
			UpdateModel_args.Add("BaseModel", BaseModel);
			UpdateModel_args.Add("MarketData", MarketData);
			UpdateModel_args.Add("ValuationDate", ValuationDate);
			return F3Formatter.f3_style_serialization("UpdateModel", UpdateModel_args);
		}

		// <summary>
		// Check that internal objects have specific unique identifiers.
		// </summary>
		// <param name="RepositoryNames">Array of repository names, one per object.</param>
		// <param name="ObjectNames">Array of object names.</param>
		// <param name="UniqueIdentifiers">Array of object unique identifiers.</param>
		public object ValidateObjectState(object RepositoryNames, object ObjectNames, object UniqueIdentifiers)
		{

			Hashtable ValidateObjectState_args = new Hashtable();
			ValidateObjectState_args.Add("RepositoryNames", RepositoryNames);
			ValidateObjectState_args.Add("ObjectNames", ObjectNames);
			ValidateObjectState_args.Add("UniqueIdentifiers", UniqueIdentifiers);
			return F3Formatter.f3_style_serialization("ValidateObjectState", ValidateObjectState_args);
		}

		// <summary>
		// Perform Value-at-Risk analysis on a product or a portfolio of products.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product for which VaR is to be calculated.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ScenarioGenerator">Scenario generator.</param>
		// <param name="NumberOfScenarios">Number of scenarios to use.</param>
		// <param name="Percentile">Specification for computing a percentile of the distribution.</param>
		// <param name="Histogram">Methodology for sample collection and histogram formation. Default value: AutoSize50UniformBins.</param>
		// <param name="CalculationMethod">Computational method and strategy. Default value: Default.</param>
		// <param name="Requests">Array of information requests. Default value: VaR.</param>
		public object ValueAtRisk(object Model, object Product, object ValuationMethod, object ScenarioGenerator, object NumberOfScenarios, object Percentile, object Histogram, object CalculationMethod, object Requests)
		{

			Hashtable ValueAtRisk_args = new Hashtable();
			ValueAtRisk_args.Add("Model", Model);
			ValueAtRisk_args.Add("Product", Product);
			ValueAtRisk_args.Add("ValuationMethod", ValuationMethod);
			ValueAtRisk_args.Add("ScenarioGenerator", ScenarioGenerator);
			ValueAtRisk_args.Add("NumberOfScenarios", NumberOfScenarios);
			ValueAtRisk_args.Add("Percentile", Percentile);
			ValueAtRisk_args.Add("Histogram", Histogram);
			ValueAtRisk_args.Add("CalculationMethod", CalculationMethod);
			ValueAtRisk_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("ValueAtRisk", ValueAtRisk_args);
		}

		// <summary>
		// Value a referenced index.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Index">Index.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ReturnRisk">True if risk required in addition to the index value. Default value: false.</param>
		// <param name="SortLexically">Flag indicating whether the risk report should be ordered lexically. Default value: true.</param>
		// <param name="EvaluationPoint">Index evaluation point for expression processing. Default value: default-constructed instance of type evaluation_point.</param>
		public object ValueIndex(object Model, object Index, object RefSpec, object ValuationMethod, object ReturnRisk, object SortLexically, object EvaluationPoint)
		{

			Hashtable ValueIndex_args = new Hashtable();
			ValueIndex_args.Add("Model", Model);
			ValueIndex_args.Add("Index", Index);
			ValueIndex_args.Add("RefSpec", RefSpec);
			ValueIndex_args.Add("ValuationMethod", ValuationMethod);
			ValueIndex_args.Add("ReturnRisk", ReturnRisk);
			ValueIndex_args.Add("SortLexically", SortLexically);
			ValueIndex_args.Add("EvaluationPoint", EvaluationPoint);
			return F3Formatter.f3_style_serialization("ValueIndex", ValueIndex_args);
		}

		// <summary>
		// Value a product or portfolio of products.
		// </summary>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="Product">Product to value.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="Requests">Array of requests detailing valuation results that are required.</param>
		public object ValueProduct(object Model, object Product, object ValuationMethod, object Requests)
		{

			Hashtable ValueProduct_args = new Hashtable();
			ValueProduct_args.Add("Model", Model);
			ValueProduct_args.Add("Product", Product);
			ValueProduct_args.Add("ValuationMethod", ValuationMethod);
			ValueProduct_args.Add("Requests", Requests);
			return F3Formatter.f3_style_serialization("ValueProduct", ValueProduct_args);
		}

		// <summary>
		// Form a curve tag for a variance speed of mean reversion curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object VarianceSpeedOfMeanReversionCurveTag(object Index)
		{

			Hashtable VarianceSpeedOfMeanReversionCurveTag_args = new Hashtable();
			VarianceSpeedOfMeanReversionCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("VarianceSpeedOfMeanReversionCurveTag", VarianceSpeedOfMeanReversionCurveTag_args);
		}

		// <summary>
		// Create an AST for a referenced index, and operate with a set of visitors.
		// </summary>
		// <param name="Index">Index to build AST from.</param>
		// <param name="RefSpec">Reference point specification.</param>
		// <param name="ASTVisitors">Ordered list of AST visitors.</param>
		public object VisitIndexAST(object Index, object RefSpec, object ASTVisitors)
		{

			Hashtable VisitIndexAST_args = new Hashtable();
			VisitIndexAST_args.Add("Index", Index);
			VisitIndexAST_args.Add("RefSpec", RefSpec);
			VisitIndexAST_args.Add("ASTVisitors", ASTVisitors);
			return F3Formatter.f3_style_serialization("VisitIndexAST", VisitIndexAST_args);
		}

		// <summary>
		// Create an AST for a product, and operate with a set of visitors.
		// </summary>
		// <param name="Product">Product to build AST from.</param>
		// <param name="ASTVisitors">Ordered list of AST visitors.</param>
		public object VisitProductAST(object Product, object ASTVisitors)
		{

			Hashtable VisitProductAST_args = new Hashtable();
			VisitProductAST_args.Add("Product", Product);
			VisitProductAST_args.Add("ASTVisitors", ASTVisitors);
			return F3Formatter.f3_style_serialization("VisitProductAST", VisitProductAST_args);
		}

		// <summary>
		// As in VisitValuationCalculationNodeTree but with the set of visitors used in production.
		// </summary>
		// <param name="Product">Product to build AST from.</param>
		// <param name="Model">Model to use for valuation artifacts.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		public object VisitProductionValuationCalculationNodeTree(object Product, object Model, object ValuationMethod)
		{

			Hashtable VisitProductionValuationCalculationNodeTree_args = new Hashtable();
			VisitProductionValuationCalculationNodeTree_args.Add("Product", Product);
			VisitProductionValuationCalculationNodeTree_args.Add("Model", Model);
			VisitProductionValuationCalculationNodeTree_args.Add("ValuationMethod", ValuationMethod);
			return F3Formatter.f3_style_serialization("VisitProductionValuationCalculationNodeTree", VisitProductionValuationCalculationNodeTree_args);
		}

		// <summary>
		// Create an AST for a product in a valuation context, and operate with a set of visitors.
		// </summary>
		// <param name="Product">Product to build AST from.</param>
		// <param name="Model">Model to use for valuation.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ASTVisitors">Ordered list of AST visitors.</param>
		public object VisitValuationAST(object Product, object Model, object ValuationMethod, object ASTVisitors)
		{

			Hashtable VisitValuationAST_args = new Hashtable();
			VisitValuationAST_args.Add("Product", Product);
			VisitValuationAST_args.Add("Model", Model);
			VisitValuationAST_args.Add("ValuationMethod", ValuationMethod);
			VisitValuationAST_args.Add("ASTVisitors", ASTVisitors);
			return F3Formatter.f3_style_serialization("VisitValuationAST", VisitValuationAST_args);
		}

		// <summary>
		// Form a calculation node tree for a product in a valuation context.
		// </summary>
		// <param name="Product">Product to build AST from.</param>
		// <param name="Model">Model to use for valuation artifacts.</param>
		// <param name="ValuationMethod">Valuation methodology.</param>
		// <param name="ASTVisitors">Ordered list of AST visitors.</param>
		public object VisitValuationCalculationNodeTree(object Product, object Model, object ValuationMethod, object ASTVisitors)
		{

			Hashtable VisitValuationCalculationNodeTree_args = new Hashtable();
			VisitValuationCalculationNodeTree_args.Add("Product", Product);
			VisitValuationCalculationNodeTree_args.Add("Model", Model);
			VisitValuationCalculationNodeTree_args.Add("ValuationMethod", ValuationMethod);
			VisitValuationCalculationNodeTree_args.Add("ASTVisitors", ASTVisitors);
			return F3Formatter.f3_style_serialization("VisitValuationCalculationNodeTree", VisitValuationCalculationNodeTree_args);
		}

		// <summary>
		// Form a curve tag for a volatility curve.
		// </summary>
		// <param name="VolatileIndex">Modeled index.</param>
		public object VolatilityCurveTag(object VolatileIndex)
		{

			Hashtable VolatilityCurveTag_args = new Hashtable();
			VolatilityCurveTag_args.Add("VolatileIndex", VolatileIndex);
			return F3Formatter.f3_style_serialization("VolatilityCurveTag", VolatilityCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a volatility exponent curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object VolatilityExponentCurveTag(object Index)
		{

			Hashtable VolatilityExponentCurveTag_args = new Hashtable();
			VolatilityExponentCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("VolatilityExponentCurveTag", VolatilityExponentCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a volatility of variance curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object VolatilityOfVarianceCurveTag(object Index)
		{

			Hashtable VolatilityOfVarianceCurveTag_args = new Hashtable();
			VolatilityOfVarianceCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("VolatilityOfVarianceCurveTag", VolatilityOfVarianceCurveTag_args);
		}

		// <summary>
		// Form a curve tag for a volatility offset curve.
		// </summary>
		// <param name="Index">The index which is being simulated.</param>
		public object VolatilityOffsetCurveTag(object Index)
		{

			Hashtable VolatilityOffsetCurveTag_args = new Hashtable();
			VolatilityOffsetCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("VolatilityOffsetCurveTag", VolatilityOffsetCurveTag_args);
		}

		// <summary>
		// Form a curve tag for the term structure of volatility.
		// </summary>
		// <param name="Index">Simulated index.</param>
		public object VolatilityTermStructureCurveTag(object Index)
		{

			Hashtable VolatilityTermStructureCurveTag_args = new Hashtable();
			VolatilityTermStructureCurveTag_args.Add("Index", Index);
			return F3Formatter.f3_style_serialization("VolatilityTermStructureCurveTag", VolatilityTermStructureCurveTag_args);
		}

	}
}